{"id":"scribe-08k","title":"Implement signal handling (SIGINT, SIGTERM)","description":"Handle system signals gracefully for clean shutdown.\n\n## Signals to Handle\n| Signal | Behavior | Exit Code |\n|--------|----------|-----------|\n| SIGINT (Ctrl+C) | Cancel operation, exit | 130 |\n| SIGTERM | Cancel operation, exit | 143 |\n\n## Implementation: src/signals.ts\n```typescript\nexport function setupSignalHandlers(): void {\n  const cleanup = () =\u003e {\n    // Cleanup temp files if any write in progress\n    cleanupTempFiles();\n  };\n  \n  process.on('SIGINT', () =\u003e {\n    cleanup();\n    process.exit(130);\n  });\n  \n  process.on('SIGTERM', () =\u003e {\n    cleanup();\n    process.exit(143);\n  });\n}\n```\n\n## During Write Operations\nThe storage layer uses atomic writes:\n1. Write to .{filename}.tmp\n2. fsync\n3. rename to final path\n\nIf interrupted:\n- After step 3: Write complete, data safe\n- Before step 3: Original file intact, temp file may remain\n\n## Temp File Cleanup\n```typescript\nfunction cleanupTempFiles(): void {\n  // The storage layer tracks active temp files\n  // On signal, attempt to delete any in-progress temp files\n  // If cleanup fails, temp files (.*.tmp) can be manually deleted\n}\n```\n\n## Signal During Stdin Read\nIf Ctrl+C during stdin input:\n- Abort read immediately\n- Exit with code 130\n- Don't produce partial output\n\n## Acceptance Criteria\n- SIGINT during command cancels cleanly\n- SIGTERM during command cancels cleanly\n- No zombie temp files on clean shutdown\n- Original files never corrupted\n- Exit codes are correct (130, 143)","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-16T15:08:13.86588-06:00","updated_at":"2025-12-16T15:08:13.86588-06:00","dependencies":[{"issue_id":"scribe-08k","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T15:08:17.785539-06:00","created_by":"daemon"},{"issue_id":"scribe-08k","depends_on_id":"scribe-0yl","type":"blocks","created_at":"2025-12-16T15:08:17.831029-06:00","created_by":"daemon"}]}
{"id":"scribe-0yl","title":"Set up TypeScript and Bun build configuration","description":"Configure TypeScript compilation and Bun bundling for the CLI.\n\n## TypeScript Configuration (tsconfig.json)\n- Extend from config/tsconfig/node.json (Node.js target)\n- Enable strict mode\n- Set module to ESNext, moduleResolution to bundler\n- Include src/**/*.ts\n- Exclude node_modules, dist\n\n## Build Configuration\n- Use Bun for development builds (`bun build src/index.ts --outdir dist`)\n- Production binary: `bun build src/index.ts --compile --outfile scribe`\n- Target: Bun runtime (not Node.js for final binary)\n\n## Scripts in package.json\n- dev: Run CLI directly with bun (`bun src/index.ts`)\n- build: Development build to dist/\n- build:binary: Production single-file binary\n- typecheck: `tsc --noEmit`\n\n## ESLint Configuration\n- Create apps/cli/eslint.config.js following workspace patterns\n- Extend from config/eslint/base.js\n\n## Considerations\n- Bun compile produces ~50-80MB binary (includes runtime)\n- TypeScript paths should resolve workspace packages correctly\n- Ensure source maps work for development debugging\n\n## Acceptance Criteria\n- `bun run typecheck` passes\n- `bun run build` produces runnable dist/index.js\n- `bun run build:binary` produces standalone executable\n- Executable runs without Bun installed (on same platform)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T14:59:01.789131-06:00","updated_at":"2025-12-16T14:59:01.789131-06:00","dependencies":[{"issue_id":"scribe-0yl","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T14:59:05.868573-06:00","created_by":"daemon"},{"issue_id":"scribe-0yl","depends_on_id":"scribe-4uq","type":"blocks","created_at":"2025-12-16T14:59:05.916234-06:00","created_by":"daemon"}]}
{"id":"scribe-1fp","title":"Implement node builder (text to Lexical)","description":"Create Lexical AST nodes from plain text for safe write operations.\n\n## Purpose\nThe CLI provides semantic write operations (append paragraph, add task) that must construct valid Lexical nodes. This module handles that construction safely.\n\n## Implementation: src/node-builder.ts\n```typescript\nimport type { LexicalState } from '@scribe/shared';\n\n// Lexical node structure types (internal to this module)\ninterface LexicalNode {\n  type: string;\n  format?: string | number;\n  indent?: number;\n  direction?: 'ltr' | 'rtl' | null;\n  children?: LexicalNode[];\n  [key: string]: unknown;\n}\n\n/**\n * Create a paragraph node with text content.\n * Handles basic text (not rich formatting).\n */\nexport function createParagraphNode(text: string): LexicalNode {\n  return {\n    type: 'paragraph',\n    format: '',\n    indent: 0,\n    direction: null,\n    children: parseInlineContent(text),\n  };\n}\n\n/**\n * Create a checklist item (task) node.\n */\nexport function createChecklistItemNode(text: string, checked = false): LexicalNode {\n  return {\n    type: 'listitem',\n    format: '',\n    indent: 0,\n    direction: null,\n    value: 1,\n    listType: 'check',\n    checked,\n    children: parseInlineContent(text),\n  };\n}\n\n/**\n * Parse inline content from plain text.\n * For MVP: Just create text nodes, don't parse [[links]] or @mentions.\n * Future: Parse and create wiki-link, person-mention, tag nodes.\n */\nfunction parseInlineContent(text: string): LexicalNode[] {\n  if (text.length === 0) {\n    return [];\n  }\n  return [createTextNode(text)];\n}\n\nfunction createTextNode(text: string): LexicalNode {\n  return {\n    type: 'text',\n    format: 0,\n    style: '',\n    mode: 'normal',\n    detail: 0,\n    text,\n  };\n}\n```\n\n## Node Key Generation\n\n**Important:** Lexical nodes typically have `__key` properties auto-generated by the Lexical editor. When creating nodes programmatically from CLI:\n\n1. **Option A (Recommended for MVP):** Don't set `__key` at all. When Scribe desktop loads the note, Lexical will assign keys during deserialization.\n\n2. **Option B (Future):** Generate UUID-based keys if we need to reference nodes before desktop app loads them:\n   ```typescript\n   function generateNodeKey(): string {\n     return crypto.randomUUID().slice(0, 8);\n   }\n   ```\n\nFor MVP, use Option A - let Lexical handle key generation on load.\n\n## Appending to Note Content\n```typescript\nexport function appendParagraphToContent(\n  content: LexicalState,\n  text: string\n): LexicalState {\n  const newNode = createParagraphNode(text);\n  \n  // Deep clone to avoid mutating original\n  const updated = JSON.parse(JSON.stringify(content));\n  \n  // Append to root.children\n  if (!updated.root.children) {\n    updated.root.children = [];\n  }\n  updated.root.children.push(newNode);\n  \n  return updated;\n}\n\nexport function appendTaskToContent(\n  content: LexicalState,\n  text: string\n): LexicalState {\n  const newNode = createChecklistItemNode(text, false);\n  \n  const updated = JSON.parse(JSON.stringify(content));\n  \n  if (!updated.root.children) {\n    updated.root.children = [];\n  }\n  updated.root.children.push(newNode);\n  \n  return updated;\n}\n```\n\n## Creating Empty Note Content\n```typescript\nexport function createEmptyContent(): LexicalState {\n  return {\n    root: {\n      type: 'root',\n      format: '',\n      indent: 0,\n      direction: null,\n      children: [],\n    },\n  };\n}\n\nexport function createInitialContent(text: string): LexicalState {\n  const paragraph = createParagraphNode(text);\n  return {\n    root: {\n      type: 'root',\n      format: '',\n      indent: 0,\n      direction: null,\n      children: [paragraph],\n    },\n  };\n}\n```\n\n## Wiki-Link Detection (Future Enhancement)\nFor MVP, don't parse [[links]] - just include as plain text.\nFuture: Detect [[Note Title]] and create wiki-link nodes with proper resolution.\n\n## Person Mention Detection (Future Enhancement)\nFor MVP, don't parse @mentions - just include as plain text.\nFuture: Detect @Name and resolve to person-mention nodes.\n\n## Key Constraints\n- Node structure must match Lexical schema exactly\n- Don't set `__key` manually (let Lexical handle it)\n- Preserve existing content when appending\n- Handle empty content gracefully\n- Use `listType: 'check'` for checklist items\n\n## Testing\n- Verify generated nodes are valid Lexical JSON\n- Test appending to empty notes\n- Test appending to notes with existing content\n- Verify Scribe desktop app can read CLI-modified notes\n- Test that desktop app assigns keys properly on load\n\n## Acceptance Criteria\n- Can create valid paragraph nodes\n- Can create valid checklist item nodes\n- Appending preserves existing content\n- Desktop app can read notes modified by CLI\n- No node corruption or invalid structures\n- Empty notes are handled correctly","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T15:04:43.673428-06:00","updated_at":"2025-12-16T15:25:41.124223-06:00","dependencies":[{"issue_id":"scribe-1fp","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T15:04:47.666063-06:00","created_by":"daemon"},{"issue_id":"scribe-1fp","depends_on_id":"scribe-h54","type":"blocks","created_at":"2025-12-16T15:04:47.709661-06:00","created_by":"daemon"}]}
{"id":"scribe-1nb","title":"Scribe CLI - LLM-optimized command-line interface for vault access","description":"A command-line tool that enables LLMs (and humans) to query, navigate, and understand Scribe vaults from any terminal environment. The CLI exposes the vault's semantic structure - notes, links, tags, tasks, and relationships - through structured JSON output optimized for machine consumption.\n\n## Strategic Goals\n1. Enable LLM-powered coding assistants (Claude Code, VS Code Copilot, etc.) to reason about personal knowledge bases\n2. Provide safe, high-level write operations that preserve Lexical content integrity\n3. Output structured JSON by default for reliable LLM parsing\n4. Package as standalone binary distributed with the Scribe desktop app\n5. Support both interactive human use and programmatic LLM consumption\n\n## Architecture Decisions\n- Direct engine imports (no IPC, no running app required)\n- Atomic writes inherited from storage-fs (no cross-process locking)\n- Eventual consistency model (desktop app won't see CLI changes until restart)\n- Bun compile for single binary (~50-80MB)\n- Semantic write operations (no raw Lexical JSON exposure)\n\n## Implementation Phases\nPhase 1: Foundation - Package structure, CLI parser, vault discovery, engine wiring\nPhase 2: Read Commands - All query operations (notes, search, tags, graph, people, tasks, daily)\nPhase 3: Write Commands - Safe mutation operations with Lexical node construction\nPhase 4: Polish \u0026 Distribution - Shell completion, performance, binary bundling, Electron integration\n\n## Success Criteria\n- Cold start \u003c500ms for 1000-note vault\n- All read operations from engine packages exposed via CLI\n- Safe write operations that never corrupt Lexical content\n- LLM can successfully query vault, find related notes, and append insights\n\n## Reference\n- Spec: features/scribe-cli/spec.md\n- Related packages: @scribe/engine-core, @scribe/engine-graph, @scribe/engine-search, @scribe/storage-fs","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-16T14:58:35.992684-06:00","updated_at":"2025-12-16T14:58:35.992684-06:00"}
{"id":"scribe-1ub","title":"Implement 'notes update' command","description":"Implement updating note metadata (title, type, tags).\n\n## Command\n```bash\nscribe notes update \u003cid\u003e [options]\n```\n\n## Arguments\n- \u003cid\u003e - Note ID (required)\n\n## Options\n| Option | Description |\n|--------|-------------|\n| --title \u003ctitle\u003e | New note title |\n| --type \u003ctype\u003e | New note type |\n| --add-tags \u003ctags\u003e | Comma-separated tags to add |\n| --remove-tags \u003ctags\u003e | Comma-separated tags to remove |\n\nAt least one option must be provided.\n\n## Output Schema\n```json\n{\n  \"success\": true,\n  \"note\": {\n    \"id\": \"abc-123\",\n    \"title\": \"Meeting with Alice (Q3)\",\n    \"type\": \"meeting\",\n    \"tags\": [\"#work\", \"#1on1\", \"#important\"],\n    \"updatedAt\": \"2025-12-16T15:00:00Z\"\n  },\n  \"changes\": {\n    \"title\": { \"from\": \"Meeting with Alice\", \"to\": \"Meeting with Alice (Q3)\" },\n    \"tagsAdded\": [\"#important\"],\n    \"tagsRemoved\": []\n  }\n}\n```\n\n## Implementation\n- Get existing note\n- Apply requested changes\n- Track what changed for response\n- Save updated note\n- Do NOT modify content (use append for that)\n\n## Tag Operations\n- --add-tags: Add tags that don't already exist\n- --remove-tags: Remove tags that exist\n- Both can be used together\n- Normalize tags (add # if missing)\n\n## Validation\n- Require at least one option\n- Validate type is valid (regular, person, meeting)\n- Return NOTE_NOT_FOUND for invalid ID\n\n## Acceptance Criteria\n- Updates title when --title provided\n- Updates type when --type provided\n- Adds tags correctly\n- Removes tags correctly\n- Returns change summary\n- Content is NOT modified\n- Note readable by desktop app","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-16T15:06:22.525971-06:00","updated_at":"2025-12-16T15:06:22.525971-06:00","dependencies":[{"issue_id":"scribe-1ub","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T15:06:26.932989-06:00","created_by":"daemon"},{"issue_id":"scribe-1ub","depends_on_id":"scribe-zly","type":"blocks","created_at":"2025-12-16T15:06:26.978119-06:00","created_by":"daemon"},{"issue_id":"scribe-1ub","depends_on_id":"scribe-h54","type":"blocks","created_at":"2025-12-16T15:06:27.02211-06:00","created_by":"daemon"},{"issue_id":"scribe-1ub","depends_on_id":"scribe-r4d","type":"blocks","created_at":"2025-12-16T15:06:27.065311-06:00","created_by":"daemon"},{"issue_id":"scribe-1ub","depends_on_id":"scribe-y4f","type":"blocks","created_at":"2025-12-16T15:06:27.109043-06:00","created_by":"daemon"}]}
{"id":"scribe-2bt","title":"Implement performance optimization (lazy loading)","description":"Optimize startup time through lazy engine initialization.\n\n## Target\nCold start \u003c 500ms for 1000-note vault\n\n## Current Architecture Issue\nNaive implementation loads all engines on every command:\n```typescript\nconst ctx = await initializeContext(opts);  // Loads everything\n```\n\nThis is wasteful because:\n- `notes list` doesn't need SearchEngine\n- `search` doesn't need GraphEngine\n- Most commands don't need all engines\n\n## Solution: Lazy Context\n\n```typescript\nexport class LazyContext {\n  private _vault?: FileSystemVault;\n  private _metadataIndex?: MetadataIndex;\n  private _graphEngine?: GraphEngine;\n  private _searchEngine?: SearchEngine;\n  private _taskIndex?: TaskIndex;\n  \n  constructor(\n    public readonly vaultPath: string,\n    public readonly options: GlobalOptions\n  ) {}\n  \n  get vault(): FileSystemVault {\n    if (!this._vault) {\n      this._vault = new FileSystemVault(this.vaultPath);\n      this._vault.loadSync();  // Or async with memoization\n    }\n    return this._vault;\n  }\n  \n  get metadataIndex(): MetadataIndex {\n    if (!this._metadataIndex) {\n      this._metadataIndex = new MetadataIndex();\n      this._metadataIndex.build(this.vault.getAllNotes());\n    }\n    return this._metadataIndex;\n  }\n  \n  get graphEngine(): GraphEngine {\n    if (!this._graphEngine) {\n      this._graphEngine = new GraphEngine();\n      this._graphEngine.build(this.vault.getAllNotes());\n    }\n    return this._graphEngine;\n  }\n  \n  get searchEngine(): SearchEngine {\n    if (!this._searchEngine) {\n      this._searchEngine = new SearchEngine();\n      this._searchEngine.index(this.vault.getAllNotes());\n    }\n    return this._searchEngine;\n  }\n  \n  get taskIndex(): TaskIndex {\n    if (!this._taskIndex) {\n      this._taskIndex = new TaskIndex(this.vaultPath);\n      this._taskIndex.loadSync();\n    }\n    return this._taskIndex;\n  }\n}\n```\n\n## Command-Specific Loading Matrix\n| Command | Vault | MetadataIndex | GraphEngine | SearchEngine | TaskIndex |\n|---------|-------|---------------|-------------|--------------|-----------|\n| notes list | ✓ | ✓ | ✓ (for link counts) | | |\n| notes show | ✓ | | ✓ | | |\n| search | ✓ | | | ✓ | |\n| graph * | ✓ | | ✓ | | |\n| tasks list | | | | | ✓ |\n| tasks toggle | ✓ | | | | ✓ |\n\n## Measurement\nAdd --debug timing output:\n```\n[timing] vault load: 120ms\n[timing] metadata index build: 45ms\n[timing] command execution: 15ms\n[timing] total: 180ms\n```\n\n## Additional Optimizations\n1. **Metadata-only loading**: For list commands, don't parse full Lexical content\n2. **Index caching**: Consider persisting search/graph indices (future)\n3. **Parallel loading**: Load independent engines in parallel\n\n## Acceptance Criteria\n- Cold start \u003c 500ms for 1000-note vault\n- Only engines needed for command are initialized\n- --debug shows timing breakdown\n- No functionality regression","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-16T15:07:58.019547-06:00","updated_at":"2025-12-16T15:07:58.019547-06:00","dependencies":[{"issue_id":"scribe-2bt","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T15:08:02.113877-06:00","created_by":"daemon"},{"issue_id":"scribe-2bt","depends_on_id":"scribe-h54","type":"blocks","created_at":"2025-12-16T15:08:02.159855-06:00","created_by":"daemon"}]}
{"id":"scribe-2lo","title":"Implement 'notes append' command","description":"Implement appending paragraphs to existing notes.\n\n## Command\n```bash\nscribe notes append \u003cid\u003e \u003ctext\u003e\nscribe notes append \u003cid\u003e -  # Read from stdin\nscribe notes append \u003cid\u003e --file content.txt\n```\n\n## Arguments\n- `\u003cid\u003e` - Note ID (required)\n- `\u003ctext\u003e` - Text to append (required, or use `-` for stdin)\n\n## Options\n| Option | Description |\n|--------|-------------|\n| `--file \u003cpath\u003e` | Read content from file |\n\n## Output Schema\n```json\n{\n  \"success\": true,\n  \"note\": {\n    \"id\": \"abc-123\",\n    \"title\": \"Meeting with Alice\",\n    \"updatedAt\": \"2025-12-16T14:35:00Z\"\n  }\n}\n```\n\n## Implementation\n```typescript\nnotes\n  .command('append')\n  .argument('\u003cid\u003e', 'Note ID')\n  .argument('\u003ctext\u003e', 'Text to append (use - for stdin)')\n  .option('--file \u003cpath\u003e', 'Read content from file')\n  .action(async (id: string, text: string, options) =\u003e {\n    const ctx = await initializeContext(program.opts());\n    \n    // Resolve input (inline, stdin, or file)\n    const input = await resolveContentInput(text, options.file);\n    \n    // Get existing note - vault.read() throws if not found\n    let note: Note;\n    try {\n      note = ctx.vault.read(id);\n    } catch (err) {\n      throw noteNotFound(id);\n    }\n    \n    // Append paragraph using node builder\n    const updatedContent = appendParagraphToContent(note.content, input.text);\n    \n    // Save note - vault.save() takes the full note object\n    await ctx.vault.save({ ...note, content: updatedContent });\n    \n    output({\n      success: true,\n      note: {\n        id: note.id,\n        title: note.title,\n        updatedAt: new Date().toISOString(),\n      },\n    }, ctx.options);\n  });\n```\n\n## FileSystemVault API Notes\nThe vault has these methods (NOT the ones in earlier drafts):\n- `vault.read(id)` - Get note, **throws** `ScribeError` if not found\n- `vault.save(note)` - Save entire note object (not partial update)\n- `vault.list()` - Get all notes as array\n\n## Content Appending\n1. Get existing note content\n2. Create new paragraph node from input text (via node builder)\n3. Append to `root.children` array\n4. Save updated content\n\n## Multiline Content\n- Process `\\n` escapes for inline text\n- Preserve natural newlines from stdin/file\n- Create single paragraph with internal line breaks\n\n## Atomic Write Safety\n- Uses storage-fs atomic write (temp → fsync → rename)\n- Original file preserved on failure\n- No corruption possible\n\n## Acceptance Criteria\n- Appends text as new paragraph at end of note\n- Works with inline text, stdin, and file input\n- `\\n` escapes create actual newlines\n- Original content is preserved\n- Returns NOTE_NOT_FOUND for invalid ID\n- Note is readable by desktop app after append","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T15:05:48.393418-06:00","updated_at":"2025-12-16T15:25:15.651589-06:00","dependencies":[{"issue_id":"scribe-2lo","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T15:05:53.063321-06:00","created_by":"daemon"},{"issue_id":"scribe-2lo","depends_on_id":"scribe-1fp","type":"blocks","created_at":"2025-12-16T15:05:53.107566-06:00","created_by":"daemon"},{"issue_id":"scribe-2lo","depends_on_id":"scribe-6xk","type":"blocks","created_at":"2025-12-16T15:05:53.151809-06:00","created_by":"daemon"},{"issue_id":"scribe-2lo","depends_on_id":"scribe-zly","type":"blocks","created_at":"2025-12-16T15:05:53.195327-06:00","created_by":"daemon"},{"issue_id":"scribe-2lo","depends_on_id":"scribe-h54","type":"blocks","created_at":"2025-12-16T15:05:53.238333-06:00","created_by":"daemon"},{"issue_id":"scribe-2lo","depends_on_id":"scribe-r4d","type":"blocks","created_at":"2025-12-16T15:05:53.282158-06:00","created_by":"daemon"},{"issue_id":"scribe-2lo","depends_on_id":"scribe-y4f","type":"blocks","created_at":"2025-12-16T15:05:53.32521-06:00","created_by":"daemon"}]}
{"id":"scribe-2s6","title":"Implement daily commands (show, create)","description":"Implement daily note retrieval and creation.\n\n## Commands\n\n### scribe daily show [date]\nGet daily note for a specific date.\n\nArguments:\n- [date] - Date in YYYY-MM-DD format (default: today)\n\nOutput (found):\n```json\n{\n  \"date\": \"2025-12-15\",\n  \"note\": {\n    \"id\": \"daily-2025-12-15\",\n    \"title\": \"December 15, 2025\",\n    \"content\": {\n      \"text\": \"## Morning\\n- Team standup...\",\n      \"format\": \"plain\"\n    },\n    \"tasks\": [\n      { \"text\": \"Review PR #42\", \"completed\": true }\n    ]\n  },\n  \"found\": true\n}\n```\n\nOutput (not found):\n```json\n{\n  \"date\": \"2025-12-15\",\n  \"note\": null,\n  \"found\": false\n}\n```\n\n### scribe daily create [date]\nCreate or get daily note for a specific date (idempotent).\n\nArguments:\n- [date] - Date in YYYY-MM-DD format (default: today)\n\nOutput:\n```json\n{\n  \"date\": \"2025-12-16\",\n  \"note\": {\n    \"id\": \"daily-2025-12-16\",\n    \"title\": \"December 16, 2025\",\n    \"createdAt\": \"2025-12-16T00:00:00Z\"\n  },\n  \"created\": true\n}\n```\n\n## Daily Note ID Pattern\nDaily notes use predictable IDs: `daily-YYYY-MM-DD`\n\n## Date Validation\n- Accept YYYY-MM-DD format\n- Accept relative dates: today, yesterday, tomorrow\n- Reject invalid dates with INVALID_INPUT error\n\n## Idempotent Creation\n`daily create` should:\n1. Check if daily note already exists\n2. If exists, return it with created: false\n3. If not, create new note with template and return with created: true\n\n## Daily Note Template\nUse existing daily note template system from engine-core if available.\n\n## Acceptance Criteria\n- show returns full daily note content\n- show returns found: false if no note for date\n- create is idempotent (safe to call multiple times)\n- Date parsing accepts multiple formats\n- Tasks within daily note are included in response","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-16T15:04:19.803952-06:00","updated_at":"2025-12-16T15:04:19.803952-06:00","dependencies":[{"issue_id":"scribe-2s6","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T15:04:25.057279-06:00","created_by":"daemon"},{"issue_id":"scribe-2s6","depends_on_id":"scribe-6vs","type":"blocks","created_at":"2025-12-16T15:04:25.101658-06:00","created_by":"daemon"},{"issue_id":"scribe-2s6","depends_on_id":"scribe-zly","type":"blocks","created_at":"2025-12-16T15:04:25.145026-06:00","created_by":"daemon"},{"issue_id":"scribe-2s6","depends_on_id":"scribe-h54","type":"blocks","created_at":"2025-12-16T15:04:25.188002-06:00","created_by":"daemon"},{"issue_id":"scribe-2s6","depends_on_id":"scribe-r4d","type":"blocks","created_at":"2025-12-16T15:04:25.231391-06:00","created_by":"daemon"},{"issue_id":"scribe-2s6","depends_on_id":"scribe-y4f","type":"blocks","created_at":"2025-12-16T15:04:25.273709-06:00","created_by":"daemon"}]}
{"id":"scribe-2zc","title":"Implement 'search' command","description":"Implement full-text search across all notes.\n\n## Command\n```bash\nscribe search \u003cquery\u003e [options]\n```\n\n## Options\n| Option | Description | Default |\n|--------|-------------|---------|\n| --limit \u003cn\u003e | Max results | 20 |\n| --offset \u003cn\u003e | Skip first n results | 0 |\n| --fields \u003cfields\u003e | Search in: title, content, tags, all | all |\n\n## Output Schema\n```json\n{\n  \"results\": [\n    {\n      \"id\": \"def-456\",\n      \"title\": \"Q3 Planning\",\n      \"snippet\": \"...discussed quarterly planning goals and OKRs for the...\",\n      \"score\": 0.92,\n      \"matches\": [\n        { \"field\": \"content\", \"count\": 3 },\n        { \"field\": \"title\", \"count\": 1 }\n      ]\n    }\n  ],\n  \"total\": 8,\n  \"query\": \"quarterly planning\"\n}\n```\n\n## Implementation\n- Use SearchEngine from @scribe/engine-search\n- Generate snippets with context around matches\n- Highlight matched terms (for text format)\n- Support field filtering\n\n## Snippet Generation\n- Extract ~100 chars around first match\n- Use ellipsis (...) to indicate truncation\n- Multiple snippets for multiple matches (future enhancement)\n\n## Acceptance Criteria\n- Full-text search works across note content\n- Results include relevance scores\n- Snippets show context around matches\n- --fields filters search scope\n- Pagination works correctly","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T15:02:58.815528-06:00","updated_at":"2025-12-16T15:02:58.815528-06:00","dependencies":[{"issue_id":"scribe-2zc","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T15:03:03.93389-06:00","created_by":"daemon"},{"issue_id":"scribe-2zc","depends_on_id":"scribe-zly","type":"blocks","created_at":"2025-12-16T15:03:03.982842-06:00","created_by":"daemon"},{"issue_id":"scribe-2zc","depends_on_id":"scribe-h54","type":"blocks","created_at":"2025-12-16T15:03:04.030197-06:00","created_by":"daemon"},{"issue_id":"scribe-2zc","depends_on_id":"scribe-r4d","type":"blocks","created_at":"2025-12-16T15:03:04.077919-06:00","created_by":"daemon"},{"issue_id":"scribe-2zc","depends_on_id":"scribe-y4f","type":"blocks","created_at":"2025-12-16T15:03:04.12383-06:00","created_by":"daemon"}]}
{"id":"scribe-36w","title":"Implement binary bundling with Bun compile","description":"Create standalone binary distribution using Bun's compile feature.\n\n## Build Command\n```bash\nbun build ./src/index.ts --compile --outfile scribe\n```\n\n## Expected Output\n- Single executable binary\n- Size: ~50-80MB (includes Bun runtime)\n- No external dependencies required\n- Runs on same platform as build\n\n## Platform Builds\nFor MVP, build for current platform only.\n\nFuture: Cross-compilation for multiple targets:\n```bash\nbun build --compile --target=bun-darwin-arm64 --outfile scribe-darwin-arm64\nbun build --compile --target=bun-darwin-x64 --outfile scribe-darwin-x64\nbun build --compile --target=bun-linux-x64 --outfile scribe-linux-x64\n```\n\n## Build Script (package.json)\n```json\n{\n  \"scripts\": {\n    \"build:binary\": \"bun build ./src/index.ts --compile --outfile dist/scribe\",\n    \"build:binary:darwin-arm64\": \"bun build ./src/index.ts --compile --target=bun-darwin-arm64 --outfile dist/scribe-darwin-arm64\",\n    \"build:binary:darwin-x64\": \"bun build ./src/index.ts --compile --target=bun-darwin-x64 --outfile dist/scribe-darwin-x64\",\n    \"build:binary:linux-x64\": \"bun build ./src/index.ts --compile --target=bun-linux-x64 --outfile dist/scribe-linux-x64\"\n  }\n}\n```\n\n## Verification\nAfter building:\n```bash\n# Should work without bun installed\n./dist/scribe --version\n./dist/scribe --help\n./dist/scribe vault info --vault ~/Scribe/vault\n```\n\n## Binary Location in App Bundle\n```\nScribe.app/\n└── Contents/\n    └── Resources/\n        └── bin/\n            └── scribe    # The compiled binary\n```\n\n## Build in CI\nAdd to GitHub Actions workflow:\n```yaml\n- name: Build CLI binary\n  run: cd apps/cli \u0026\u0026 bun run build:binary\n\n- name: Upload CLI artifact\n  uses: actions/upload-artifact@v3\n  with:\n    name: scribe-cli-${{ runner.os }}\n    path: apps/cli/dist/scribe*\n```\n\n## Considerations\n- Binary includes all workspace package code (bundled)\n- Native dependencies (if any) must be compatible\n- File size is acceptable for desktop app bundle\n\n## Acceptance Criteria\n- Binary builds successfully with bun compile\n- Binary runs without Bun installed\n- Binary size is reasonable (~50-80MB)\n- All commands work in binary form\n- Binary is placed in correct location for app bundle","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T15:08:32.866919-06:00","updated_at":"2025-12-16T15:08:32.866919-06:00","dependencies":[{"issue_id":"scribe-36w","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T15:08:36.589453-06:00","created_by":"daemon"},{"issue_id":"scribe-36w","depends_on_id":"scribe-2bt","type":"blocks","created_at":"2025-12-16T15:08:36.636778-06:00","created_by":"daemon"},{"issue_id":"scribe-36w","depends_on_id":"scribe-9jy","type":"blocks","created_at":"2025-12-16T15:15:54.744706-06:00","created_by":"daemon"}]}
{"id":"scribe-48i","title":"Implement comprehensive CLI testing","description":"Create unit and integration tests for all CLI functionality.\n\n## Test Structure\n```\napps/cli/\n├── src/\n│   └── ...\n├── tests/\n│   ├── unit/\n│   │   ├── vault-resolver.test.ts\n│   │   ├── content-extractor.test.ts\n│   │   ├── node-builder.test.ts\n│   │   ├── output.test.ts\n│   │   └── errors.test.ts\n│   ├── integration/\n│   │   ├── notes-commands.test.ts\n│   │   ├── search-commands.test.ts\n│   │   ├── graph-commands.test.ts\n│   │   ├── tasks-commands.test.ts\n│   │   └── e2e-workflow.test.ts\n│   └── fixtures/\n│       └── test-vault/\n│           └── notes/\n│               └── ... (test notes)\n├── vitest.config.ts  # \u003c-- ADD THIS\n└── package.json\n```\n\n## Vitest Configuration\nCreate `apps/cli/vitest.config.ts`:\n```typescript\nimport { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    environment: 'node',\n    include: ['tests/**/*.test.ts'],\n    coverage: {\n      provider: 'v8',\n      reporter: ['text', 'json', 'html'],\n      include: ['src/**/*.ts'],\n      exclude: ['src/index.ts'],\n    },\n    setupFiles: ['./tests/setup.ts'],\n  },\n});\n```\n\n## Test Setup File\nCreate `apps/cli/tests/setup.ts`:\n```typescript\nimport { beforeEach, afterEach } from 'vitest';\nimport { tmpdir } from 'os';\nimport { mkdtemp, rm } from 'fs/promises';\nimport { join } from 'path';\n\n// Global test vault for integration tests\nexport let testVaultPath: string;\n\nbeforeEach(async () =\u003e {\n  // Create fresh temp vault for each test\n  testVaultPath = await mkdtemp(join(tmpdir(), 'scribe-test-'));\n});\n\nafterEach(async () =\u003e {\n  // Clean up temp vault\n  if (testVaultPath) {\n    await rm(testVaultPath, { recursive: true, force: true });\n  }\n});\n```\n\n## Unit Tests\n\n### vault-resolver.test.ts\n- Flag override takes precedence\n- Env var fallback works\n- Config file fallback works\n- Default path used as last resort\n- Path expansion (~) works\n- Invalid path returns structured error\n\n### content-extractor.test.ts\n- Extracts headings as ## format\n- Extracts paragraphs as plain text\n- Extracts tasks as - [ ] / - [x]\n- Extracts wiki-links as [[Title]]\n- Extracts mentions as @Name\n- Handles nested structures\n- Handles empty content\n\n### node-builder.test.ts\n- Creates valid paragraph nodes\n- Creates valid checklist nodes\n- Appending preserves existing content\n- Empty content is handled correctly\n- Node keys are NOT set (let Lexical handle)\n\n### output.test.ts\n- JSON output is valid JSON\n- Text output is human-readable\n- Verbose goes to stderr\n- Debug timing works\n\n### errors.test.ts\n- All error codes have exit codes\n- Error formatting includes details\n- Hints are included where applicable\n\n## Integration Tests\n\n### Test Fixture Vault\nCreate a test vault with:\n- Various note types (regular, person, meeting)\n- Notes with tasks\n- Linked notes (for graph tests)\n- Tagged notes\n- Daily notes\n\n### notes-commands.test.ts\n- list returns correct notes\n- list filters work (type, tag, date)\n- list pagination works\n- show returns full content\n- show returns backlinks\n- create creates note correctly\n- append adds paragraph\n- add-task adds checklist item\n- update changes metadata\n- delete with backlinks fails without --force\n- delete with --force works\n\n### search-commands.test.ts\n- Full-text search finds notes\n- Field filtering works\n- Snippets are generated\n- Pagination works\n\n### graph-commands.test.ts\n- backlinks returns correct notes\n- outlinks returns correct notes\n- neighbors combines both directions\n- stats shows accurate metrics\n\n### tasks-commands.test.ts\n- list shows all tasks\n- list filters work\n- toggle changes completion state\n- set-priority updates priority\n\n### e2e-workflow.test.ts\nSimulate LLM workflow:\n1. vault info - understand vault\n2. search \"project\" - find relevant notes\n3. notes show \u003cid\u003e - read content\n4. graph backlinks \u003cid\u003e - understand context\n5. notes append \u003cid\u003e \"Summary\" - add insight\n6. Verify note updated correctly\n\n## Test Runner\nAdd to package.json scripts:\n```json\n{\n  \"scripts\": {\n    \"test\": \"vitest\",\n    \"test:unit\": \"vitest run tests/unit\",\n    \"test:integration\": \"vitest run tests/integration\",\n    \"test:coverage\": \"vitest run --coverage\"\n  }\n}\n```\n\n## Test Utilities\n```typescript\n// tests/helpers.ts\nimport { FileSystemVault } from '@scribe/storage-fs';\nimport { initializeVault } from '@scribe/storage-fs';\n\nexport async function createTestVault(basePath: string): Promise\u003c{\n  path: string;\n  vault: FileSystemVault;\n  cleanup: () =\u003e Promise\u003cvoid\u003e;\n}\u003e {\n  // Initialize vault structure\n  await initializeVault(basePath);\n  \n  const vault = new FileSystemVault(basePath);\n  await vault.load();\n  \n  return {\n    path: basePath,\n    vault,\n    cleanup: async () =\u003e {\n      await rm(basePath, { recursive: true, force: true });\n    },\n  };\n}\n\nexport async function runCLI(args: string[]): Promise\u003c{\n  stdout: string;\n  stderr: string;\n  exitCode: number;\n}\u003e {\n  // Execute CLI with args, capture output\n  // Use spawn to run the CLI binary\n}\n```\n\n## CI Integration\nAdd to GitHub Actions:\n```yaml\n- name: Run CLI tests\n  run: cd apps/cli \u0026\u0026 bun test\n\n- name: Upload coverage\n  uses: codecov/codecov-action@v3\n  with:\n    files: apps/cli/coverage/coverage-final.json\n```\n\n## Acceptance Criteria\n- All unit tests pass\n- All integration tests pass\n- Test coverage \u003e 80%\n- Tests run in CI\n- Test vault is isolated (no side effects)\n- vitest.config.ts is created and working","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T15:09:21.404698-06:00","updated_at":"2025-12-16T15:26:11.042441-06:00","dependencies":[{"issue_id":"scribe-48i","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T15:09:25.144987-06:00","created_by":"daemon"},{"issue_id":"scribe-48i","depends_on_id":"scribe-9jy","type":"blocks","created_at":"2025-12-16T15:15:51.193533-06:00","created_by":"daemon"},{"issue_id":"scribe-48i","depends_on_id":"scribe-2lo","type":"blocks","created_at":"2025-12-16T15:15:51.772381-06:00","created_by":"daemon"},{"issue_id":"scribe-48i","depends_on_id":"scribe-2zc","type":"blocks","created_at":"2025-12-16T15:15:52.310073-06:00","created_by":"daemon"},{"issue_id":"scribe-48i","depends_on_id":"scribe-6nq","type":"blocks","created_at":"2025-12-16T15:15:52.859501-06:00","created_by":"daemon"},{"issue_id":"scribe-48i","depends_on_id":"scribe-gw0","type":"blocks","created_at":"2025-12-16T15:15:53.472604-06:00","created_by":"daemon"}]}
{"id":"scribe-4uq","title":"Create apps/cli package structure","description":"Initialize the CLI package within the monorepo structure.\n\n## Files to Create\n- apps/cli/package.json - Package manifest with dependencies and scripts\n- apps/cli/tsconfig.json - TypeScript config extending workspace base\n- apps/cli/src/index.ts - Entry point (minimal bootstrap)\n- apps/cli/bunfig.toml - Bun-specific configuration if needed\n\n## Package.json Requirements\n- name: @scribe/cli\n- bin: { scribe: ./dist/index.js } for development\n- dependencies: Commander.js (or similar CLI framework)\n- workspace dependencies: @scribe/engine-core, @scribe/engine-graph, @scribe/engine-search, @scribe/storage-fs, @scribe/shared\n\n## Considerations\n- Follow existing monorepo patterns from apps/desktop\n- Ensure turbo.json includes cli in build pipeline\n- Add to root package.json workspaces if not auto-detected\n\n## Acceptance Criteria\n- `bun install` works from repo root\n- `turbo build --filter=@scribe/cli` succeeds (even if empty)\n- Package can import from workspace packages","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T14:58:46.214349-06:00","updated_at":"2025-12-16T14:58:46.214349-06:00","dependencies":[{"issue_id":"scribe-4uq","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T14:58:50.94422-06:00","created_by":"daemon"}]}
{"id":"scribe-5xz","title":"Implement vault discovery logic","description":"Implement the vault path resolution logic with configurable precedence.\n\n## Resolution Order (Highest to Lowest Priority)\n1. --vault CLI flag\n2. SCRIBE_VAULT_PATH environment variable\n3. Config file (~/.config/scribe/config.json → vaultPath)\n4. Default: ~/Scribe/vault\n\n## Implementation: src/vault-resolver.ts\n```typescript\nimport { existsSync } from 'fs';\nimport { homedir } from 'os';\nimport { join } from 'path';\nimport { loadConfig } from './config';\n\nexport interface VaultResolutionResult {\n  path: string;\n  source: 'flag' | 'env' | 'config' | 'default';\n}\n\nexport function resolveVaultPath(flagValue?: string): VaultResolutionResult {\n  // 1. CLI flag\n  if (flagValue) {\n    return { path: expandPath(flagValue), source: 'flag' };\n  }\n  \n  // 2. Environment variable\n  const envPath = process.env.SCRIBE_VAULT_PATH;\n  if (envPath) {\n    return { path: expandPath(envPath), source: 'env' };\n  }\n  \n  // 3. Config file\n  const config = loadConfig();\n  if (config?.vaultPath) {\n    return { path: expandPath(config.vaultPath), source: 'config' };\n  }\n  \n  // 4. Default\n  return { path: join(homedir(), 'Scribe', 'vault'), source: 'default' };\n}\n\nexport function validateVaultPath(path: string): void {\n  if (!existsSync(path)) {\n    throw new VaultNotFoundError(path);\n  }\n  // Could also check for required structure (notes/, derived/, etc.)\n}\n\nfunction expandPath(path: string): string {\n  return path.startsWith('~') ? join(homedir(), path.slice(1)) : path;\n}\n```\n\n## Error Handling\nWhen vault not found, return structured error:\n```json\n{\n  \"error\": \"Vault not found at /path/to/vault\",\n  \"code\": \"VAULT_NOT_FOUND\",\n  \"path\": \"/resolved/path/to/vault\",\n  \"hint\": \"Specify vault with --vault flag or SCRIBE_VAULT_PATH environment variable\"\n}\n```\n\n## Validation\n- Check path exists\n- Check it's a directory\n- Optionally verify vault structure (has notes/, has metadata.json, etc.)\n\n## Testing Considerations\n- Test each resolution source\n- Test path expansion (~ → homedir)\n- Test error cases (path doesn't exist, not a directory)\n- Mock environment variables in tests\n\n## Acceptance Criteria\n- --vault flag takes precedence over all other sources\n- Environment variable works when no flag provided\n- Config file is read and used appropriately\n- Default path is used as last resort\n- Clear error when vault not found with helpful hint","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T14:59:40.019314-06:00","updated_at":"2025-12-16T14:59:40.019314-06:00","dependencies":[{"issue_id":"scribe-5xz","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T14:59:44.479935-06:00","created_by":"daemon"},{"issue_id":"scribe-5xz","depends_on_id":"scribe-0yl","type":"blocks","created_at":"2025-12-16T14:59:44.524599-06:00","created_by":"daemon"}]}
{"id":"scribe-6l0","title":"Implement tags commands (list, notes)","description":"Implement tag listing and tag-based note retrieval.\n\n## Commands\n\n### scribe tags list\nList all tags in the vault with usage counts.\n\nOptions:\n| Option | Description | Default |\n|--------|-------------|---------|\n| --sort \u003cfield\u003e | Sort by: name, count | count |\n| --limit \u003cn\u003e | Max results | all |\n\nOutput:\n```json\n{\n  \"tags\": [\n    { \"name\": \"#work\", \"count\": 45 },\n    { \"name\": \"#meeting\", \"count\": 32 }\n  ],\n  \"total\": 34\n}\n```\n\n### scribe tags notes \u003ctag\u003e\nGet notes with a specific tag.\n\nOptions:\n| Option | Description | Default |\n|--------|-------------|---------|\n| --limit \u003cn\u003e | Max results | 50 |\n| --offset \u003cn\u003e | Skip first n results | 0 |\n\nOutput:\n```json\n{\n  \"tag\": \"#work\",\n  \"notes\": [\n    {\n      \"id\": \"abc-123\",\n      \"title\": \"Meeting with Alice\",\n      \"type\": \"meeting\",\n      \"updatedAt\": \"2025-12-15T11:45:00Z\"\n    }\n  ],\n  \"count\": 45\n}\n```\n\n## Tag Normalization\n- Accept tags with or without # prefix\n- Always output with # prefix\n- Case-sensitive matching (tags are case-sensitive in Scribe)\n\n## Implementation\n- Build tag index from MetadataIndex\n- Sort by count descending by default (most used first)\n\n## Acceptance Criteria\n- Lists all unique tags with usage counts\n- Notes filtered by tag correctly\n- Tag normalization works (with/without #)\n- Sorting and pagination work","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-16T15:03:30.3275-06:00","updated_at":"2025-12-16T15:03:30.3275-06:00","dependencies":[{"issue_id":"scribe-6l0","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T15:03:34.262301-06:00","created_by":"daemon"},{"issue_id":"scribe-6l0","depends_on_id":"scribe-zly","type":"blocks","created_at":"2025-12-16T15:03:34.308001-06:00","created_by":"daemon"},{"issue_id":"scribe-6l0","depends_on_id":"scribe-h54","type":"blocks","created_at":"2025-12-16T15:03:34.352712-06:00","created_by":"daemon"},{"issue_id":"scribe-6l0","depends_on_id":"scribe-r4d","type":"blocks","created_at":"2025-12-16T15:03:34.402169-06:00","created_by":"daemon"},{"issue_id":"scribe-6l0","depends_on_id":"scribe-y4f","type":"blocks","created_at":"2025-12-16T15:03:34.451429-06:00","created_by":"daemon"}]}
{"id":"scribe-6nq","title":"Implement graph commands (backlinks, outlinks, neighbors, stats)","description":"Implement all graph-related commands for exploring note relationships.\n\n## Commands\n\n### scribe graph backlinks \u003cid\u003e\nGet notes that link TO a specific note.\n\n### scribe graph outlinks \u003cid\u003e\nGet notes that a specific note links TO.\n\n### scribe graph neighbors \u003cid\u003e\nGet all notes connected to a specific note (bidirectional).\n\n### scribe graph stats\nGet vault-wide graph statistics.\n\n## Output Schemas\n\n### Backlinks/Outlinks\n```json\n{\n  \"note\": { \"id\": \"def-456\", \"title\": \"Project Roadmap\" },\n  \"backlinks|outlinks\": [\n    {\n      \"id\": \"abc-123\",\n      \"title\": \"Meeting with Alice\",\n      \"type\": \"meeting\",\n      \"tags\": [\"#work\"]\n    }\n  ],\n  \"count\": 2\n}\n```\n\n### Neighbors\n```json\n{\n  \"note\": { \"id\": \"def-456\", \"title\": \"Project Roadmap\" },\n  \"neighbors\": [\n    {\n      \"id\": \"abc-123\",\n      \"title\": \"Meeting with Alice\",\n      \"direction\": \"incoming|outgoing|both\",\n      \"type\": \"link\"\n    }\n  ],\n  \"count\": 3\n}\n```\n\n### Stats\n```json\n{\n  \"nodes\": 156,\n  \"edges\": 423,\n  \"tags\": 34,\n  \"avgLinksPerNote\": 2.7,\n  \"mostLinked\": [\n    { \"id\": \"def-456\", \"title\": \"Project Roadmap\", \"linkCount\": 15 }\n  ],\n  \"orphanNotes\": 8\n}\n```\n\n## Implementation Notes\n\n### API Gap: GraphEngine.outlinks() - RESOLVED\n**BLOCKED BY scribe-xfk**: The GraphEngine currently lacks an outlinks() method. Once scribe-xfk is completed, use the new `GraphEngine.outlinks(noteId)` method directly.\n\n**TEMPORARY WORKAROUND** (until scribe-xfk is done): Reconstruct from vault:\n```typescript\nfunction getOutlinks(note: Note, vault: FileSystemVault): NoteInfo[] {\n  const outgoingIds = note.metadata.links ?? [];\n  return outgoingIds.map(id =\u003e {\n    try {\n      const linkedNote = vault.read(id);\n      return {\n        id: linkedNote.id,\n        title: linkedNote.title,\n        type: linkedNote.type,\n        tags: linkedNote.tags,\n      };\n    } catch {\n      // Linked note doesn't exist (broken link)\n      return null;\n    }\n  }).filter(Boolean);\n}\n```\n\n**AFTER scribe-xfk**: Replace workaround with:\n```typescript\nconst outlinks = graphEngine.outlinks(noteId);\n```\n\n### GraphEngine Usage\n- backlinks() - Use GraphEngine.backlinks(noteId) ✓\n- outlinks() - Use GraphEngine.outlinks(noteId) after scribe-xfk completes\n- neighbors() - Use GraphEngine.neighbors(noteId) ✓\n- stats() - Use GraphEngine.getStats() + compute extras\n\n### Stats Implementation\nGraphEngine.getStats() returns { nodes, edges, tags }. \nFor full stats, also compute:\n- avgLinksPerNote: edges / nodes\n- mostLinked: iterate nodes, find highest backlink counts\n- orphanNotes: iterate nodes, count those with no incoming AND no outgoing links\n\n## Acceptance Criteria\n- backlinks returns correct incoming links\n- outlinks returns correct outgoing links (using GraphEngine.outlinks() after scribe-xfk)\n- neighbors combines both directions\n- stats shows accurate graph metrics\n- Most-linked notes are correctly identified\n- Orphan count is accurate\n- Broken links (to non-existent notes) handled gracefully","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T15:03:15.203038-06:00","updated_at":"2025-12-16T15:22:17.52742-06:00","dependencies":[{"issue_id":"scribe-6nq","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T15:03:19.955453-06:00","created_by":"daemon"},{"issue_id":"scribe-6nq","depends_on_id":"scribe-zly","type":"blocks","created_at":"2025-12-16T15:03:19.999251-06:00","created_by":"daemon"},{"issue_id":"scribe-6nq","depends_on_id":"scribe-h54","type":"blocks","created_at":"2025-12-16T15:03:20.044685-06:00","created_by":"daemon"},{"issue_id":"scribe-6nq","depends_on_id":"scribe-r4d","type":"blocks","created_at":"2025-12-16T15:03:20.092818-06:00","created_by":"daemon"},{"issue_id":"scribe-6nq","depends_on_id":"scribe-y4f","type":"blocks","created_at":"2025-12-16T15:03:20.1402-06:00","created_by":"daemon"},{"issue_id":"scribe-6nq","depends_on_id":"scribe-xfk","type":"blocks","created_at":"2025-12-16T15:21:51.616675-06:00","created_by":"daemon"}]}
{"id":"scribe-6vs","title":"Implement content extraction (Lexical to plain text)","description":"Extract readable plain text from Lexical EditorContent JSON for LLM consumption.\n\n## Purpose\nLLMs need readable text, not complex AST JSON. This module converts Lexical content to markdown-ish plain text that preserves semantic structure.\n\n## Implementation: src/content-extractor.ts\n```typescript\nimport type { EditorContent, LexicalNode } from '@scribe/engine-core';\n\nexport interface ExtractedContent {\n  text: string;           // Plain text with markdown formatting\n  format: 'plain';        // Always 'plain' for now\n  raw?: EditorContent;    // Original Lexical JSON (only with --include-raw)\n}\n\nexport function extractContent(\n  content: EditorContent, \n  includeRaw = false\n): ExtractedContent {\n  const text = extractPlainText(content);\n  return {\n    text,\n    format: 'plain',\n    ...(includeRaw \u0026\u0026 { raw: content }),\n  };\n}\n\nfunction extractPlainText(content: EditorContent): string {\n  const lines: string[] = [];\n  traverseBlocks(content.root, (node) =\u003e {\n    const line = formatBlock(node);\n    if (line !== null) lines.push(line);\n  });\n  return lines.join('\\n\\n');\n}\n```\n\n## Block-Level Formatting\n```typescript\nfunction formatBlock(node: LexicalNode): string | null {\n  switch (node.type) {\n    case 'heading': {\n      const level = parseInt(node.tag?.slice(1) || '1');\n      const hashes = '#'.repeat(level);\n      return `${hashes} ${extractInlineText(node)}`;\n    }\n    \n    case 'paragraph':\n      return extractInlineText(node);\n    \n    case 'listitem': {\n      const prefix = node.__checked !== undefined\n        ? (node.__checked ? '- [x]' : '- [ ]')\n        : '-';\n      return `${prefix} ${extractInlineText(node)}`;\n    }\n    \n    case 'quote':\n      return `\u003e ${extractInlineText(node)}`;\n    \n    case 'code':\n      return `\\`\\`\\`\\n${node.code || ''}\\n\\`\\`\\``;\n    \n    case 'table':\n      return formatTable(node);\n    \n    case 'horizontalrule':\n      return '---';\n    \n    default:\n      // Unknown block type - try to extract text anyway\n      return extractInlineText(node) || null;\n  }\n}\n```\n\n## Inline-Level Formatting\n```typescript\nfunction extractInlineText(blockNode: LexicalNode): string {\n  const parts: string[] = [];\n  \n  traverseInline(blockNode.children || [], (node) =\u003e {\n    switch (node.type) {\n      case 'text':\n        parts.push(node.text || '');\n        break;\n      case 'wiki-link':\n        parts.push(`[[${node.targetTitle || node.targetId}]]`);\n        break;\n      case 'person-mention':\n        parts.push(`@${node.personName || node.personId}`);\n        break;\n      case 'linebreak':\n        parts.push('\\n');\n        break;\n      case 'tag':\n        parts.push(node.tag || '');\n        break;\n    }\n  });\n  \n  return parts.join('');\n}\n```\n\n## Table Formatting\n```typescript\nfunction formatTable(tableNode: LexicalNode): string {\n  const rows: string[][] = [];\n  \n  for (const row of tableNode.children || []) {\n    const cells: string[] = [];\n    for (const cell of row.children || []) {\n      cells.push(extractInlineText(cell));\n    }\n    rows.push(cells);\n  }\n  \n  if (rows.length === 0) return '';\n  \n  // Format as markdown table\n  const header = `| ${rows[0].join(' | ')} |`;\n  const separator = `| ${rows[0].map(() =\u003e '---').join(' | ')} |`;\n  const body = rows.slice(1).map(row =\u003e `| ${row.join(' | ')} |`);\n  \n  return [header, separator, ...body].join('\\n');\n}\n```\n\n## Testing Considerations\n- Test all node types from the Scribe Lexical schema\n- Test nested structures (lists within lists, etc.)\n- Test edge cases (empty nodes, missing properties)\n- Verify wiki-links preserve target info\n- Verify person-mentions preserve name/id\n\n## Acceptance Criteria\n- All Lexical node types are handled\n- Output is readable markdown-ish text\n- Wiki-links render as [[Title]] or [[id]] \n- Person mentions render as @Name\n- Tasks render as - [ ] or - [x]\n- Tables render as markdown tables\n- Headings preserve level (##, ###, etc.)\n- Unknown node types don't crash (graceful fallback)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T15:01:31.255252-06:00","updated_at":"2025-12-16T15:01:31.255252-06:00","dependencies":[{"issue_id":"scribe-6vs","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T15:01:34.765235-06:00","created_by":"daemon"},{"issue_id":"scribe-6vs","depends_on_id":"scribe-h54","type":"blocks","created_at":"2025-12-16T15:01:34.813828-06:00","created_by":"daemon"}]}
{"id":"scribe-6xk","title":"Implement stdin and file input handling","description":"Handle multi-line content input from stdin and files for write operations.\n\n## Input Methods\n\n### 1. Inline with Newline Escapes\n```bash\nscribe notes append abc-123 \"First paragraph.\\n\\nSecond paragraph.\"\n```\nInterpret \\n as newlines.\n\n### 2. Stdin Input\n```bash\n# Pipe\necho \"Content\" | scribe notes append abc-123 -\n\n# Here-doc\nscribe notes append abc-123 - \u003c\u003cEOF\nFirst paragraph.\nSecond paragraph.\nEOF\n\n# From file via pipe\ncat content.txt | scribe notes append abc-123 -\n```\n\n### 3. File Input\n```bash\nscribe notes append abc-123 --file content.txt\n```\n\n## Implementation: src/input.ts\n```typescript\nimport { readFileSync } from 'fs';\n\nexport interface ContentInput {\n  text: string;\n  source: 'inline' | 'stdin' | 'file';\n}\n\nexport async function resolveContentInput(\n  inlineText: string | undefined,\n  fileOption: string | undefined\n): Promise\u003cContentInput\u003e {\n  // 1. File input\n  if (fileOption) {\n    const text = readFileSync(fileOption, 'utf-8');\n    return { text, source: 'file' };\n  }\n  \n  // 2. Stdin input (- argument)\n  if (inlineText === '-') {\n    const text = await readStdin();\n    return { text, source: 'stdin' };\n  }\n  \n  // 3. Inline text (with newline escape processing)\n  if (inlineText) {\n    const text = processEscapes(inlineText);\n    return { text, source: 'inline' };\n  }\n  \n  throw new CLIError('No content provided', ErrorCode.INVALID_INPUT);\n}\n\nasync function readStdin(): Promise\u003cstring\u003e {\n  return new Promise((resolve, reject) =\u003e {\n    let data = '';\n    process.stdin.setEncoding('utf-8');\n    \n    process.stdin.on('data', (chunk) =\u003e {\n      data += chunk;\n      // Max size check\n      if (data.length \u003e 1_000_000) {\n        reject(new CLIError('Input exceeds 1MB limit', ErrorCode.INVALID_INPUT));\n      }\n    });\n    \n    process.stdin.on('end', () =\u003e {\n      if (data.length === 0) {\n        reject(new CLIError('Empty input', ErrorCode.INVALID_INPUT));\n      }\n      resolve(data.trim());\n    });\n    \n    process.stdin.on('error', reject);\n  });\n}\n\nfunction processEscapes(text: string): string {\n  return text\n    .replace(/\\\\n/g, '\\n')  // Literal \\n\n    .replace(/\\n/g, '\\n');    // Escaped newline\n}\n```\n\n## Stdin Behavior\n- TTY detection: If stdin is a TTY, wait for input until Ctrl+D\n- Max size: 1MB limit to prevent accidental large inputs\n- Empty input: Returns INVALID_INPUT error\n- No timeout: User controls input\n\n## Acceptance Criteria\n- Inline text with \\n creates actual newlines\n- Stdin input works via pipe and here-doc\n- File input reads content correctly\n- Empty stdin returns helpful error\n- Max size limit prevents memory issues\n- Works correctly with Bun runtime","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-16T15:05:04.594911-06:00","updated_at":"2025-12-16T15:05:04.594911-06:00","dependencies":[{"issue_id":"scribe-6xk","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T15:05:08.55413-06:00","created_by":"daemon"},{"issue_id":"scribe-6xk","depends_on_id":"scribe-zly","type":"blocks","created_at":"2025-12-16T15:05:08.599288-06:00","created_by":"daemon"}]}
{"id":"scribe-917","title":"Implement 'tasks set-priority' command","description":"Implement setting task priority levels.\n\n## Command\n```bash\nscribe tasks set-priority \u003cid\u003e \u003cpriority\u003e\n```\n\n## Arguments\n- \u003cid\u003e - Task ID (required)\n- \u003cpriority\u003e - Priority level 0-3 (required)\n\n## Priority Levels\n- 0: Urgent (highest)\n- 1: High\n- 2: Medium (default)\n- 3: Low (lowest)\n\n## Output Schema\n```json\n{\n  \"success\": true,\n  \"task\": {\n    \"id\": \"abc-123:node_1:hash123\",\n    \"text\": \"Review PR #42\",\n    \"priority\": 0,\n    \"previousPriority\": 2\n  }\n}\n```\n\n## Implementation\n```typescript\ntasks\n  .command('set-priority')\n  .argument('\u003cid\u003e', 'Task ID')\n  .argument('\u003cpriority\u003e', 'Priority level 0-3')\n  .action(async (id: string, priorityStr: string) =\u003e {\n    const ctx = await initializeContext(program.opts());\n    \n    const priority = parseInt(priorityStr, 10);\n    if (isNaN(priority) || priority \u003c 0 || priority \u003e 3) {\n      throw new CLIError(\n        'Priority must be 0-3',\n        ErrorCode.INVALID_INPUT,\n        { value: priorityStr, expected: '0, 1, 2, or 3' }\n      );\n    }\n    \n    const task = ctx.taskIndex.getTask(id);\n    if (!task) {\n      throw new CLIError('Task not found', ErrorCode.NOTE_NOT_FOUND, { id });\n    }\n    \n    const previousPriority = task.priority ?? 2;\n    \n    await ctx.taskIndex.updateTask(id, { priority });\n    await ctx.taskIndex.persist();\n    \n    output({\n      success: true,\n      task: {\n        id,\n        text: task.text,\n        priority,\n        previousPriority,\n      },\n    }, ctx.options);\n  });\n```\n\n## Where Priority is Stored\nPriority is stored ONLY in the task index (derived/tasks.jsonl), NOT in the Lexical content. This is because:\n1. Lexical checklist items don't have a priority property\n2. Priority is metadata about the task, not content\n3. Keeps Lexical content pure\n\n## Desktop App Compatibility\nThe desktop app also uses the task index for priority. After setting priority via CLI:\n- Desktop app won't see change until restart\n- Priority will persist across restarts\n\n## Acceptance Criteria\n- Sets priority in task index\n- Validates priority is 0-3\n- Returns previous priority for comparison\n- Persists to derived/tasks.jsonl\n- Priority visible in 'tasks list' command\n- Priority visible in desktop app (after restart)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-16T15:07:21.391751-06:00","updated_at":"2025-12-16T15:07:21.391751-06:00","dependencies":[{"issue_id":"scribe-917","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T15:07:25.988394-06:00","created_by":"daemon"},{"issue_id":"scribe-917","depends_on_id":"scribe-zly","type":"blocks","created_at":"2025-12-16T15:07:26.036756-06:00","created_by":"daemon"},{"issue_id":"scribe-917","depends_on_id":"scribe-h54","type":"blocks","created_at":"2025-12-16T15:07:26.082903-06:00","created_by":"daemon"},{"issue_id":"scribe-917","depends_on_id":"scribe-r4d","type":"blocks","created_at":"2025-12-16T15:07:26.129643-06:00","created_by":"daemon"},{"issue_id":"scribe-917","depends_on_id":"scribe-y4f","type":"blocks","created_at":"2025-12-16T15:07:26.176586-06:00","created_by":"daemon"}]}
{"id":"scribe-9jy","title":"Implement 'notes list' command","description":"Implement the notes list command with filtering and pagination.\n\n## Command\n```bash\nscribe notes list [options]\n```\n\n## Options\n| Option | Description | Default |\n|--------|-------------|---------|\n| --limit \u003cn\u003e | Max results | 100 |\n| --offset \u003cn\u003e | Skip first n results | 0 |\n| --type \u003ctype\u003e | Filter by type: regular, person, meeting | all |\n| --tag \u003ctag\u003e | Filter by tag (with or without #) | none |\n| --since \u003cdate\u003e | Notes updated after date | none |\n| --until \u003cdate\u003e | Notes updated before date | none |\n| --sort \u003cfield\u003e | Sort by: created, updated, title | updated |\n| --order \u003casc|desc\u003e | Sort order | desc |\n\n## Date Parsing\nSupport both ISO-8601 and relative formats:\n- ISO: 2025-12-15, 2025-12-15T10:30:00Z\n- Relative: 7d (7 days), 1w (1 week), 1m (1 month), 3M (3 months)\n\n## Tag Normalization\nAccept tags with or without # prefix:\n- --tag work → #work\n- --tag \"#meeting\" → #meeting\n\n## Output Schema\n```json\n{\n  \"notes\": [\n    {\n      \"id\": \"abc-123\",\n      \"title\": \"Meeting with Alice\",\n      \"type\": \"meeting\",\n      \"tags\": [\"#work\", \"#1on1\"],\n      \"createdAt\": \"2025-12-15T10:30:00Z\",\n      \"updatedAt\": \"2025-12-15T11:45:00Z\",\n      \"linkCount\": 3,\n      \"backlinkCount\": 1\n    }\n  ],\n  \"total\": 156,\n  \"limit\": 100,\n  \"offset\": 0\n}\n```\n\n## Implementation Approach\n1. Get all notes from MetadataIndex\n2. Apply filters (type, tag, date range)\n3. Sort by specified field\n4. Apply pagination (offset, limit)\n5. Enrich with link counts from GraphEngine\n6. Return structured response\n\n## Performance\n- For large vaults, filtering should happen before pagination\n- Consider streaming for very large result sets (future)\n- Target \u003c200ms for 1000-note vault with no filters\n\n## Acceptance Criteria\n- Lists notes with metadata (no content)\n- Pagination works correctly (limit, offset)\n- Type filter works for all types\n- Tag filter works with/without # prefix\n- Date filters work with ISO and relative formats\n- Sort and order work for all fields\n- Total count reflects filtered results (before pagination)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T15:02:10.072143-06:00","updated_at":"2025-12-16T15:02:10.072143-06:00","dependencies":[{"issue_id":"scribe-9jy","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T15:02:14.730381-06:00","created_by":"daemon"},{"issue_id":"scribe-9jy","depends_on_id":"scribe-zly","type":"blocks","created_at":"2025-12-16T15:02:14.776055-06:00","created_by":"daemon"},{"issue_id":"scribe-9jy","depends_on_id":"scribe-h54","type":"blocks","created_at":"2025-12-16T15:02:14.821622-06:00","created_by":"daemon"},{"issue_id":"scribe-9jy","depends_on_id":"scribe-r4d","type":"blocks","created_at":"2025-12-16T15:02:14.867328-06:00","created_by":"daemon"},{"issue_id":"scribe-9jy","depends_on_id":"scribe-y4f","type":"blocks","created_at":"2025-12-16T15:02:14.911174-06:00","created_by":"daemon"}]}
{"id":"scribe-9z4","title":"Implement config file loading","description":"Load CLI configuration from ~/.config/scribe/config.json.\n\n## Config File Location\n- Primary: ~/.config/scribe/config.json (XDG Base Directory spec)\n- The config file is optional - CLI works without it\n\n## Config Schema\n```typescript\ninterface ScribeConfig {\n  vaultPath?: string;      // Default vault path\n  defaultFormat?: 'json' | 'text';  // Output format default\n  defaultLimit?: number;   // Default limit for list commands\n}\n```\n\n## Implementation: src/config.ts\n```typescript\nimport { existsSync, readFileSync } from 'fs';\nimport { homedir } from 'os';\nimport { join } from 'path';\n\nconst CONFIG_PATH = join(homedir(), '.config', 'scribe', 'config.json');\n\nexport interface ScribeConfig {\n  vaultPath?: string;\n  defaultFormat?: 'json' | 'text';\n  defaultLimit?: number;\n}\n\nexport function loadConfig(): ScribeConfig | null {\n  if (!existsSync(CONFIG_PATH)) {\n    return null;\n  }\n  \n  try {\n    const content = readFileSync(CONFIG_PATH, 'utf-8');\n    return JSON.parse(content) as ScribeConfig;\n  } catch (err) {\n    // Invalid JSON or read error - log warning to stderr, continue with null\n    if (process.env.DEBUG) {\n      console.error(`Warning: Could not load config from ${CONFIG_PATH}: ${err}`);\n    }\n    return null;\n  }\n}\n\nexport function getConfigPath(): string {\n  return CONFIG_PATH;\n}\n```\n\n## Desktop App Integration\nThe desktop app should create/update this config file:\n- On first launch, write vaultPath to config\n- If user changes vault location in app, update config\n- This allows CLI to auto-detect vault without user config\n\n## Validation\n- JSON schema validation (optional, be lenient)\n- Unknown keys are ignored (forward compatibility)\n- Invalid values fallback to defaults\n\n## Considerations\n- Config loading should be fast (called on every CLI invocation)\n- Don't throw on malformed config - warn and continue\n- Consider caching config within a single CLI invocation\n\n## Acceptance Criteria\n- Config loads from ~/.config/scribe/config.json when present\n- Missing config file doesn't cause error\n- Malformed JSON logs warning, continues with defaults\n- All config values are optional\n- Config values are used in vault resolution and output formatting","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-16T14:59:59.382917-06:00","updated_at":"2025-12-16T14:59:59.382917-06:00","dependencies":[{"issue_id":"scribe-9z4","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T15:00:03.743879-06:00","created_by":"daemon"},{"issue_id":"scribe-9z4","depends_on_id":"scribe-0yl","type":"blocks","created_at":"2025-12-16T15:00:03.788382-06:00","created_by":"daemon"}]}
{"id":"scribe-bnb","title":"Implement 'notes find' command","description":"Implement fuzzy title search for notes.\n\n## Command\n```bash\nscribe notes find \u003cquery\u003e [options]\n```\n\n## Options\n| Option | Description | Default |\n|--------|-------------|---------|\n| --limit \u003cn\u003e | Max results | 10 |\n| --exact | Exact match only | false |\n\n## Output Schema\n```json\n{\n  \"results\": [\n    {\n      \"id\": \"def-456\",\n      \"title\": \"Project Roadmap\",\n      \"score\": 1.0,\n      \"type\": \"regular\"\n    }\n  ]\n}\n```\n\n## Implementation\n- Use fuzzy matching algorithm (Levenshtein distance or similar)\n- Score results by match quality (1.0 = exact match)\n- Case-insensitive by default\n- --exact flag for exact substring match\n\n## Acceptance Criteria\n- Fuzzy matches partial titles\n- Results sorted by relevance score\n- --exact limits to exact substring matches\n- Returns empty results array if no matches","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-16T15:02:44.098809-06:00","updated_at":"2025-12-16T15:02:44.098809-06:00","dependencies":[{"issue_id":"scribe-bnb","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T15:02:48.283918-06:00","created_by":"daemon"},{"issue_id":"scribe-bnb","depends_on_id":"scribe-zly","type":"blocks","created_at":"2025-12-16T15:02:48.328418-06:00","created_by":"daemon"},{"issue_id":"scribe-bnb","depends_on_id":"scribe-h54","type":"blocks","created_at":"2025-12-16T15:02:48.371977-06:00","created_by":"daemon"},{"issue_id":"scribe-bnb","depends_on_id":"scribe-r4d","type":"blocks","created_at":"2025-12-16T15:02:48.416406-06:00","created_by":"daemon"},{"issue_id":"scribe-bnb","depends_on_id":"scribe-y4f","type":"blocks","created_at":"2025-12-16T15:02:48.460905-06:00","created_by":"daemon"}]}
{"id":"scribe-cxq","title":"Implement 'vault info' command","description":"Implement the vault info command to show vault metadata and statistics.\n\n## Command\n```bash\nscribe vault info\n```\n\n## Output Schema\n```json\n{\n  \"path\": \"/Users/erik/Scribe/vault\",\n  \"stats\": {\n    \"noteCount\": 156,\n    \"tagCount\": 34,\n    \"taskCount\": 68,\n    \"openTaskCount\": 23,\n    \"personCount\": 15,\n    \"dailyNoteCount\": 45\n  },\n  \"oldestNote\": \"2024-03-15T09:00:00Z\",\n  \"newestNote\": \"2025-12-16T10:30:00Z\",\n  \"lastModified\": \"2025-12-16T14:45:00Z\"\n}\n```\n\n## Implementation: src/commands/vault.ts\n```typescript\nexport function registerVaultCommands(program: Command): void {\n  const vault = program.command('vault').description('Vault operations');\n  \n  vault\n    .command('info')\n    .description('Get vault metadata and statistics')\n    .action(async () =\u003e {\n      const ctx = await initializeContext(program.opts());\n      const stats = await getVaultStats(ctx);\n      output(stats, ctx.options);\n    });\n}\n\nasync function getVaultStats(ctx: CLIContext): Promise\u003cVaultInfo\u003e {\n  const notes = ctx.vault.getAllNotes();\n  const tags = new Set\u003cstring\u003e();\n  let tasks = { total: 0, open: 0 };\n  let personCount = 0;\n  let dailyCount = 0;\n  let oldest: Date | null = null;\n  let newest: Date | null = null;\n  \n  for (const note of notes) {\n    // Count by type\n    if (note.type === 'person') personCount++;\n    if (note.id.startsWith('daily-')) dailyCount++;\n    \n    // Collect tags\n    for (const tag of note.tags || []) tags.add(tag);\n    \n    // Track dates\n    const created = new Date(note.createdAt);\n    if (!oldest || created \u003c oldest) oldest = created;\n    if (!newest || created \u003e newest) newest = created;\n  }\n  \n  // Task stats from TaskIndex\n  const taskIndex = ctx.taskIndex;\n  tasks.total = taskIndex.getAllTasks().length;\n  tasks.open = taskIndex.getOpenTasks().length;\n  \n  return {\n    path: ctx.vaultPath,\n    stats: {\n      noteCount: notes.length,\n      tagCount: tags.size,\n      taskCount: tasks.total,\n      openTaskCount: tasks.open,\n      personCount,\n      dailyNoteCount: dailyCount,\n    },\n    oldestNote: oldest?.toISOString() || null,\n    newestNote: newest?.toISOString() || null,\n    lastModified: ctx.vault.getLastModified()?.toISOString() || null,\n  };\n}\n```\n\n## Text Format Output\n```\nVault: /Users/erik/Scribe/vault\n\nStatistics:\n  Notes: 156\n  Tags: 34\n  Tasks: 68 (23 open)\n  People: 15\n  Daily Notes: 45\n\nTimeline:\n  Oldest: Mar 15, 2024\n  Newest: Dec 16, 2025\n  Last Modified: Dec 16, 2025 2:45 PM\n```\n\n## Acceptance Criteria\n- Shows vault path\n- Shows accurate note count\n- Shows unique tag count\n- Shows task statistics (total and open)\n- Shows person count (notes with type=person)\n- Shows daily note count\n- Shows date range of notes\n- Text format is human-readable","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-16T15:01:51.352487-06:00","updated_at":"2025-12-16T15:01:51.352487-06:00","dependencies":[{"issue_id":"scribe-cxq","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T15:01:55.69117-06:00","created_by":"daemon"},{"issue_id":"scribe-cxq","depends_on_id":"scribe-zly","type":"blocks","created_at":"2025-12-16T15:01:55.745878-06:00","created_by":"daemon"},{"issue_id":"scribe-cxq","depends_on_id":"scribe-h54","type":"blocks","created_at":"2025-12-16T15:01:55.802018-06:00","created_by":"daemon"},{"issue_id":"scribe-cxq","depends_on_id":"scribe-r4d","type":"blocks","created_at":"2025-12-16T15:01:55.863661-06:00","created_by":"daemon"},{"issue_id":"scribe-cxq","depends_on_id":"scribe-y4f","type":"blocks","created_at":"2025-12-16T15:01:55.917809-06:00","created_by":"daemon"}]}
{"id":"scribe-fos","title":"Implement Electron app integration for CLI installation","description":"Integrate CLI binary into Scribe desktop app with symlink installation.\n\n## Binary Location in App Bundle\n```\nScribe.app/\n└── Contents/\n    └── Resources/\n        └── bin/\n            └── scribe    # The compiled CLI binary\n```\n\n## First-Launch Installation Flow\nOn first app launch (or from Settings menu):\n\n1. Check if CLI already installed\n2. Prompt user to install CLI to PATH\n3. Create symlink to ~/.local/bin/scribe\n4. Guide user to add ~/.local/bin to PATH if needed\n\n## Implementation in Electron Main Process\n```typescript\n// apps/desktop/electron/main/cli-installer.ts\nimport { app } from 'electron';\nimport { existsSync, symlinkSync, mkdirSync } from 'fs';\nimport { join } from 'path';\nimport { homedir } from 'os';\n\nexport async function installCLI(): Promise\u003c{ success: boolean; message: string }\u003e {\n  const resourcesPath = join(app.getAppPath(), '..', 'Resources');\n  const binaryPath = join(resourcesPath, 'bin', 'scribe');\n  const targetDir = join(homedir(), '.local', 'bin');\n  const targetPath = join(targetDir, 'scribe');\n  \n  // Check if binary exists in app bundle\n  if (!existsSync(binaryPath)) {\n    return { success: false, message: 'CLI binary not found in app bundle' };\n  }\n  \n  // Check if already installed\n  if (existsSync(targetPath)) {\n    return { success: true, message: 'CLI already installed' };\n  }\n  \n  // Create ~/.local/bin if needed\n  if (!existsSync(targetDir)) {\n    mkdirSync(targetDir, { recursive: true });\n  }\n  \n  // Create symlink\n  try {\n    symlinkSync(binaryPath, targetPath);\n    return { \n      success: true, \n      message: `CLI installed to ${targetPath}. Add to PATH: export PATH=\"/Users/erikjohansson/.local/bin:/Users/erikjohansson/.local/bin:/Users/erikjohansson/.local/bin/env:/Users/erikjohansson/.bun/bin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/opt/homebrew/bin:/Users/erikjohansson/.local/bin:/Users/erikjohansson/.local/bin/env:/Users/erikjohansson/.bun/bin:/Applications/Ghostty.app/Contents/MacOS\"`\n    };\n  } catch (err) {\n    return { success: false, message: `Failed to create symlink: ${err}` };\n  }\n}\n\nexport function isCLIInstalled(): boolean {\n  const targetPath = join(homedir(), '.local', 'bin', 'scribe');\n  return existsSync(targetPath);\n}\n\nexport function uninstallCLI(): boolean {\n  const targetPath = join(homedir(), '.local', 'bin', 'scribe');\n  if (existsSync(targetPath)) {\n    unlinkSync(targetPath);\n    return true;\n  }\n  return false;\n}\n```\n\n## IPC Handlers\n```typescript\n// In main process IPC handlers\nipcMain.handle('cli:install', async () =\u003e installCLI());\nipcMain.handle('cli:is-installed', () =\u003e isCLIInstalled());\nipcMain.handle('cli:uninstall', () =\u003e uninstallCLI());\n```\n\n## Settings UI (Future)\nAdd to Settings menu:\n- \"Install CLI\" button\n- Status indicator (installed/not installed)\n- \"Uninstall CLI\" option\n\n## Config File Creation\nOn first launch, also create/update ~/.config/scribe/config.json:\n```json\n{\n  \"vaultPath\": \"/path/to/current/vault\"\n}\n```\n\nThis allows CLI to auto-detect vault without user config.\n\n## Linux Considerations\nSame approach works for Linux:\n- Binary in app's resources directory\n- Symlink to ~/.local/bin/scribe\n\n## Acceptance Criteria\n- CLI binary is included in app bundle\n- Symlink is created to ~/.local/bin/scribe\n- User is guided to add ~/.local/bin to PATH\n- Config file is created with vault path\n- Uninstall removes symlink\n- Works on macOS and Linux","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-16T15:08:53.773519-06:00","updated_at":"2025-12-16T15:08:53.773519-06:00","dependencies":[{"issue_id":"scribe-fos","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T15:08:58.336653-06:00","created_by":"daemon"},{"issue_id":"scribe-fos","depends_on_id":"scribe-36w","type":"blocks","created_at":"2025-12-16T15:08:58.381816-06:00","created_by":"daemon"}]}
{"id":"scribe-gw0","title":"Implement 'tasks list' command","description":"Implement task listing with filtering and sorting.\n\n## Command\n```bash\nscribe tasks list [options]\n```\n\n## Options\n| Option | Description | Default |\n|--------|-------------|---------|\n| --status \u003cstatus\u003e | Filter: open, completed, all | all |\n| --note \u003cid\u003e | Filter by source note | none |\n| --priority \u003cn\u003e | Filter by priority (0-3) | all |\n| --since \u003cdate\u003e | Tasks created after date | none |\n| --limit \u003cn\u003e | Max results | 50 |\n| --offset \u003cn\u003e | Skip first n results | 0 |\n| --sort \u003cfield\u003e | Sort by: priority, created, completed | priority |\n\n## Output Schema\n```json\n{\n  \"tasks\": [\n    {\n      \"id\": \"abc-123:node_1:hash123\",\n      \"text\": \"Review PR #42\",\n      \"completed\": false,\n      \"priority\": 0,\n      \"noteId\": \"abc-123\",\n      \"noteTitle\": \"Meeting with Alice\",\n      \"createdAt\": \"2025-12-15T10:30:00Z\"\n    }\n  ],\n  \"total\": 23,\n  \"openCount\": 23,\n  \"completedCount\": 45\n}\n```\n\n## Implementation\n\n```typescript\ntasks\n  .command('list')\n  .option('--status \u003cstatus\u003e', 'Filter: open, completed, all', 'all')\n  .option('--note \u003cid\u003e', 'Filter by source note')\n  .option('--priority \u003cn\u003e', 'Filter by priority (0-3)', parseInt)\n  .option('--since \u003cdate\u003e', 'Tasks created after date')\n  .option('--limit \u003cn\u003e', 'Max results', parseInt, 50)\n  .option('--offset \u003cn\u003e', 'Skip first n results', parseInt, 0)\n  .option('--sort \u003cfield\u003e', 'Sort by: priority, created, completed', 'priority')\n  .action(async (options) =\u003e {\n    const ctx = await initializeContext(program.opts());\n    \n    // Build filter for TaskIndex.list()\n    const filter: TaskFilter = {\n      limit: options.limit,\n    };\n    \n    // Status filter\n    if (options.status === 'open') {\n      filter.completed = false;\n    } else if (options.status === 'completed') {\n      filter.completed = true;\n    }\n    // 'all' = no completed filter\n    \n    // Note filter\n    if (options.note) {\n      filter.noteId = options.note;\n    }\n    \n    // Priority filter\n    if (options.priority !== undefined) {\n      filter.priority = options.priority;\n    }\n    \n    // Get tasks using TaskIndex.list()\n    const { tasks: allTasks } = ctx.taskIndex.list(filter);\n    \n    // Apply sorting (TaskIndex may not support all sort options)\n    const sortedTasks = sortTasks(allTasks, options.sort);\n    \n    // Apply offset/limit\n    const paginatedTasks = sortedTasks.slice(options.offset, options.offset + options.limit);\n    \n    // Enrich with note titles\n    const enrichedTasks = paginatedTasks.map(task =\u003e {\n      let noteTitle = '[unknown]';\n      try {\n        const note = ctx.vault.read(task.noteId);\n        noteTitle = note.title;\n      } catch {}\n      \n      return {\n        id: task.id,\n        text: task.text,\n        completed: task.completed,\n        priority: task.priority,\n        noteId: task.noteId,\n        noteTitle,\n        createdAt: new Date(task.createdAt).toISOString(),\n        ...(task.completedAt \u0026\u0026 { completedAt: new Date(task.completedAt).toISOString() }),\n      };\n    });\n    \n    // Calculate totals\n    const allTasksUnfiltered = ctx.taskIndex.list({}).tasks;\n    const openCount = allTasksUnfiltered.filter(t =\u003e !t.completed).length;\n    const completedCount = allTasksUnfiltered.filter(t =\u003e t.completed).length;\n    \n    output({\n      tasks: enrichedTasks,\n      total: allTasks.length,\n      openCount,\n      completedCount,\n    }, ctx.options);\n  });\n\nfunction sortTasks(tasks: Task[], sortBy: string): Task[] {\n  return [...tasks].sort((a, b) =\u003e {\n    switch (sortBy) {\n      case 'priority':\n        return a.priority - b.priority;  // Lower = higher priority\n      case 'created':\n        return b.createdAt - a.createdAt;  // Newest first\n      case 'completed':\n        return (b.completedAt ?? 0) - (a.completedAt ?? 0);  // Most recently completed first\n      default:\n        return 0;\n    }\n  });\n}\n```\n\n## Task ID Format\nTask IDs are composite: `noteId:nodeKey:contentHash`\n- noteId: The note containing the task\n- nodeKey: Lexical node key (for finding the task in the AST)\n- contentHash: Hash of task text (for stability across edits)\n\nUse `parseTaskId()` from @scribe/shared to decompose.\n\n## TaskIndex.list() Filter\nThe TaskIndex.list(filter) method accepts TaskFilter:\n```typescript\ninterface TaskFilter {\n  noteId?: NoteId;     // Filter by note\n  completed?: boolean; // Filter by status\n  priority?: number;   // Filter by exact priority\n  limit?: number;      // Max results\n  // Note: offset/since/sort may need client-side implementation\n}\n```\n\n## Priority Levels\n- 0: Urgent (highest priority)\n- 1: High\n- 2: Medium (default for new tasks)\n- 3: Low (lowest priority)\n\n## Date Parsing for --since\nSupport ISO-8601 and relative dates:\n- `2025-12-01` - ISO date\n- `7d` - 7 days ago\n- `1w` - 1 week ago\n- `1m` - 1 month ago\n\n## Acceptance Criteria\n- Lists tasks with all metadata including noteTitle\n- Status filter works (open/completed/all)\n- Note filter shows only tasks from specific note\n- Priority filter works\n- Sort by priority puts urgent (0) tasks first\n- Total/open/completed counts are accurate\n- Timestamps are ISO-8601 formatted\n- Pagination (limit/offset) works correctly","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T15:04:02.851687-06:00","updated_at":"2025-12-16T15:19:27.507664-06:00","dependencies":[{"issue_id":"scribe-gw0","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T15:04:06.98327-06:00","created_by":"daemon"},{"issue_id":"scribe-gw0","depends_on_id":"scribe-zly","type":"blocks","created_at":"2025-12-16T15:04:07.026323-06:00","created_by":"daemon"},{"issue_id":"scribe-gw0","depends_on_id":"scribe-h54","type":"blocks","created_at":"2025-12-16T15:04:07.068821-06:00","created_by":"daemon"},{"issue_id":"scribe-gw0","depends_on_id":"scribe-r4d","type":"blocks","created_at":"2025-12-16T15:04:07.113375-06:00","created_by":"daemon"},{"issue_id":"scribe-gw0","depends_on_id":"scribe-y4f","type":"blocks","created_at":"2025-12-16T15:04:07.157693-06:00","created_by":"daemon"}]}
{"id":"scribe-h54","title":"Wire up engine imports from workspace packages","description":"Connect CLI to the existing engine packages for vault operations.\n\n## Required Imports\n\nBased on actual package exports:\n\n```typescript\n// From @scribe/storage-fs\nimport { FileSystemVault } from '@scribe/storage-fs';\n\n// From @scribe/engine-core (barrel exports)\nimport { \n  extractMetadata, \n  MetadataIndex,\n  extractTasksFromNote,\n} from '@scribe/engine-core';\n\n// From @scribe/engine-core (direct import - not in barrel due to Node deps)\nimport { TaskIndex } from '@scribe/engine-core/src/task-index.js';\nimport { JsonlTaskPersistence } from '@scribe/engine-core/src/task-persistence.js';\n\n// From @scribe/engine-graph\nimport { GraphEngine } from '@scribe/engine-graph';\n\n// From @scribe/engine-search\nimport { SearchEngine } from '@scribe/engine-search';\n\n// From @scribe/shared\nimport { ScribeError, ErrorCode, parseTaskId, serializeTaskId } from '@scribe/shared';\nimport type { Note, NoteId, Task, TaskFilter } from '@scribe/shared';\n```\n\n## CLI Context Object\n\n```typescript\n// src/context.ts\nimport path from 'path';\n\nexport interface CLIContext {\n  vault: FileSystemVault;\n  vaultPath: string;\n  graphEngine: GraphEngine;\n  searchEngine: SearchEngine;\n  taskIndex: TaskIndex;\n  options: GlobalOptions;\n}\n\nexport async function initializeContext(options: GlobalOptions): Promise\u003cCLIContext\u003e {\n  const { path: vaultPath } = resolveVaultPath(options.vault);\n  validateVaultPath(vaultPath);\n  \n  // Initialize vault and load notes\n  const vault = new FileSystemVault(vaultPath);\n  await vault.load();\n  const notes = vault.list();  // Note: list() not getAllNotes()\n  \n  // Initialize graph engine\n  const graphEngine = new GraphEngine();\n  for (const note of notes) {\n    graphEngine.addNote(note);\n  }\n  \n  // Initialize search engine  \n  const searchEngine = new SearchEngine();\n  for (const note of notes) {\n    searchEngine.indexNote(note);\n  }\n  \n  // Initialize task index\n  // TaskIndex needs path to derived/ directory, not vault root\n  const derivedPath = path.join(vaultPath, 'derived');\n  const taskIndex = new TaskIndex(derivedPath);\n  await taskIndex.load();\n  \n  return { vault, vaultPath, graphEngine, searchEngine, taskIndex, options };\n}\n```\n\n## Key API Notes\n\n### FileSystemVault\n- `vault.load()` - Load all notes from disk\n- `vault.list()` - Get all notes as array\n- `vault.read(id)` - Get single note (throws if not found)\n- `vault.create(options)` - Create new note\n- `vault.save(note)` - Save note\n- `vault.delete(id)` - Delete note\n\n### GraphEngine\n- `graphEngine.addNote(note)` - Add/update note in graph\n- `graphEngine.backlinks(noteId)` - Get notes linking TO this note\n- `graphEngine.neighbors(noteId)` - Get all connected notes\n- `graphEngine.notesWithTag(tag)` - Get notes with tag\n- `graphEngine.getAllTags()` - Get all unique tags\n- `graphEngine.getStats()` - Get { nodes, edges, tags }\n- Note: NO outlinks() method - use note.metadata.links directly\n\n### SearchEngine\n- `searchEngine.indexNote(note)` - Add/update note in index\n- `searchEngine.search(query, limit?)` - Full-text search\n- `searchEngine.removeNote(noteId)` - Remove from index\n\n### TaskIndex  \n- `taskIndex.load()` - Load from tasks.jsonl\n- `taskIndex.list(filter?)` - Query tasks with filter\n- `taskIndex.get(taskId)` - Get single task\n- `taskIndex.toggle(taskId)` - Toggle completion\n- `taskIndex.indexNote(note)` - Re-index tasks from note\n- `taskIndex.flush()` - Force immediate persistence\n\n## Lazy Initialization (Performance Optimization)\n\nNot all commands need all engines. Consider lazy initialization:\n\n```typescript\nexport class LazyContext {\n  private _searchEngine?: SearchEngine;\n  private _graphEngine?: GraphEngine;\n  private _taskIndex?: TaskIndex;\n  \n  constructor(\n    public readonly vault: FileSystemVault,\n    public readonly vaultPath: string,\n    public readonly options: GlobalOptions\n  ) {}\n  \n  get searchEngine(): SearchEngine {\n    if (!this._searchEngine) {\n      this._searchEngine = new SearchEngine();\n      for (const note of this.vault.list()) {\n        this._searchEngine.indexNote(note);\n      }\n    }\n    return this._searchEngine;\n  }\n  \n  // Similar for graphEngine, taskIndex...\n}\n```\n\nCommands use only what they need:\n- `notes list` - vault only\n- `search` - vault + searchEngine\n- `graph backlinks` - vault + graphEngine\n- `tasks list` - taskIndex only\n\n## Package.json Dependencies\n\n```json\n{\n  \"dependencies\": {\n    \"@scribe/engine-core\": \"workspace:*\",\n    \"@scribe/engine-graph\": \"workspace:*\",\n    \"@scribe/engine-search\": \"workspace:*\",\n    \"@scribe/storage-fs\": \"workspace:*\",\n    \"@scribe/shared\": \"workspace:*\"\n  }\n}\n```\n\n## Acceptance Criteria\n- Can import all required packages without bundler errors\n- Can instantiate FileSystemVault and load notes with `await vault.load()`\n- Can iterate notes with `vault.list()`\n- Can build GraphEngine by calling `addNote()` for each note\n- Can build SearchEngine by calling `indexNote()` for each note\n- Can load/query/update TaskIndex with derived/tasks.jsonl\n- Context object is available to all command handlers\n- Lazy initialization pattern works for performance","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T15:00:20.096655-06:00","updated_at":"2025-12-16T15:19:02.151222-06:00","dependencies":[{"issue_id":"scribe-h54","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T15:00:24.599048-06:00","created_by":"daemon"},{"issue_id":"scribe-h54","depends_on_id":"scribe-0yl","type":"blocks","created_at":"2025-12-16T15:00:24.645914-06:00","created_by":"daemon"},{"issue_id":"scribe-h54","depends_on_id":"scribe-5xz","type":"blocks","created_at":"2025-12-16T15:00:24.690364-06:00","created_by":"daemon"}]}
{"id":"scribe-hvm","title":"Implement 'notes create' command","description":"Implement note creation with title, type, tags, and optional content.\n\n## Command\n```bash\nscribe notes create [options]\n```\n\n## Options\n| Option | Description | Default |\n|--------|-------------|---------|\n| --title \u003ctitle\u003e | Note title | \"Untitled\" |\n| --type \u003ctype\u003e | Note type: regular, person, meeting | regular |\n| --tags \u003ctags\u003e | Comma-separated tags | none |\n| --content \u003ctext\u003e | Initial plain text content | empty |\n\n## Output Schema\n```json\n{\n  \"success\": true,\n  \"note\": {\n    \"id\": \"new-note-id\",\n    \"title\": \"New Project Ideas\",\n    \"type\": \"regular\",\n    \"tags\": [\"#work\", \"#brainstorm\"],\n    \"createdAt\": \"2025-12-16T14:30:00Z\",\n    \"updatedAt\": \"2025-12-16T14:30:00Z\"\n  }\n}\n```\n\n## Implementation\n```typescript\nnotes\n  .command('create')\n  .option('--title \u003ctitle\u003e', 'Note title', 'Untitled')\n  .option('--type \u003ctype\u003e', 'Note type: regular, person, meeting', 'regular')\n  .option('--tags \u003ctags\u003e', 'Comma-separated tags')\n  .option('--content \u003ctext\u003e', 'Initial content')\n  .action(async (options) =\u003e {\n    const ctx = await initializeContext(program.opts());\n    \n    const tags = options.tags\n      ? options.tags.split(',').map(normalizeTag)\n      : [];\n    \n    const content = options.content\n      ? createInitialContent(options.content)\n      : createEmptyContent();\n    \n    const note = await ctx.vault.createNote({\n      title: options.title,\n      type: options.type,\n      tags,\n      content,\n    });\n    \n    output({ success: true, note }, ctx.options);\n  });\n```\n\n## Content Creation\nUse node builder to create initial content if provided:\n```typescript\nfunction createInitialContent(text: string): EditorContent {\n  const paragraph = createParagraphNode(text);\n  return {\n    root: {\n      type: 'root',\n      format: '',\n      indent: 0,\n      direction: null,\n      children: [paragraph],\n    },\n  };\n}\n```\n\n## Tag Normalization\n- Accept with or without # prefix\n- Output always includes # prefix\n\n## Type Validation\n- Validate type is one of: regular, person, meeting\n- Return INVALID_INPUT for unknown types\n\n## Acceptance Criteria\n- Creates note with specified title\n- Type defaults to 'regular'\n- Tags are normalized and stored correctly\n- Optional content is added as paragraph\n- Returns new note ID and metadata\n- Note is readable by desktop app","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T15:05:29.577876-06:00","updated_at":"2025-12-16T15:05:29.577876-06:00","dependencies":[{"issue_id":"scribe-hvm","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T15:05:34.4647-06:00","created_by":"daemon"},{"issue_id":"scribe-hvm","depends_on_id":"scribe-1fp","type":"blocks","created_at":"2025-12-16T15:05:34.507186-06:00","created_by":"daemon"},{"issue_id":"scribe-hvm","depends_on_id":"scribe-zly","type":"blocks","created_at":"2025-12-16T15:05:34.552001-06:00","created_by":"daemon"},{"issue_id":"scribe-hvm","depends_on_id":"scribe-h54","type":"blocks","created_at":"2025-12-16T15:05:34.594995-06:00","created_by":"daemon"},{"issue_id":"scribe-hvm","depends_on_id":"scribe-r4d","type":"blocks","created_at":"2025-12-16T15:05:34.640949-06:00","created_by":"daemon"},{"issue_id":"scribe-hvm","depends_on_id":"scribe-y4f","type":"blocks","created_at":"2025-12-16T15:05:34.68392-06:00","created_by":"daemon"}]}
{"id":"scribe-i86","title":"Implement 'tasks toggle' command","description":"Implement toggling task completion status.\n\n## Command\n```bash\nscribe tasks toggle \u003cid\u003e\n```\n\n## Arguments\n- \u003cid\u003e - Task ID (required, format: noteId:nodeKey:hash)\n\n## Output Schema\n```json\n{\n  \"success\": true,\n  \"task\": {\n    \"id\": \"abc-123:node_1:hash123\",\n    \"text\": \"Review PR #42\",\n    \"completed\": true,\n    \"completedAt\": \"2025-12-16T14:45:00Z\"\n  }\n}\n```\n\n## Implementation\n```typescript\ntasks\n  .command('toggle')\n  .argument('\u003cid\u003e', 'Task ID')\n  .action(async (id: string) =\u003e {\n    const ctx = await initializeContext(program.opts());\n    \n    // Parse task ID to get noteId\n    const { noteId } = parseTaskId(id);\n    \n    // Get note\n    const note = ctx.vault.read(noteId);\n    \n    // Find and toggle task in Lexical content\n    const { updatedContent, taskNode, newState } = toggleTaskInContent(note.content, id);\n    \n    if (!taskNode) {\n      throw new CLIError('Task not found in note', ErrorCode.NOTE_NOT_FOUND, { id });\n    }\n    \n    // Save note with updated content\n    await ctx.vault.save({ ...note, content: updatedContent });\n    \n    // Update task index - USE THE BUILT-IN toggle() METHOD\n    const updatedTask = ctx.taskIndex.toggle(id);\n    if (!updatedTask) {\n      // Task wasn't in index, but we already toggled it in content\n      // This shouldn't happen but handle gracefully\n      console.warn('Task not found in index, re-indexing note');\n      ctx.taskIndex.indexNote(note);\n    }\n    \n    // Persist task index changes\n    await ctx.taskIndex.flush();\n    \n    output({\n      success: true,\n      task: {\n        id,\n        text: extractTextFromNode(taskNode),\n        completed: newState,\n        ...(newState ? { completedAt: new Date().toISOString() } : {}),\n      },\n    }, ctx.options);\n  });\n```\n\n## Task ID Parsing\nUse shared utility from @scribe/shared:\n```typescript\nimport { parseTaskId } from '@scribe/shared';\n// Returns { noteId, nodeKey, textHash }\n```\n\n## Finding and Toggling Task in Lexical Content\n```typescript\nfunction toggleTaskInContent(content: EditorContent, taskId: string) {\n  const { nodeKey } = parseTaskId(taskId);\n  \n  // Deep clone content to avoid mutations\n  const updated = JSON.parse(JSON.stringify(content));\n  let foundNode = null;\n  let newState = false;\n  \n  // Traverse and find checklist item node by key\n  traverseNodes(updated.root, (node) =\u003e {\n    if (node.type === 'listitem' \u0026\u0026 node.__key === nodeKey \u0026\u0026 node.__checked !== undefined) {\n      newState = !node.__checked;\n      node.__checked = newState;\n      foundNode = node;\n    }\n  });\n  \n  return { updatedContent: updated, taskNode: foundNode, newState };\n}\n```\n\n## Critical: Both Updates Required\nToggle requires updating TWO things:\n1. **Lexical content** - The __checked property in the note file\n2. **Task index** - The completed/completedAt fields in tasks.jsonl\n\nThe TaskIndex.toggle() method handles #2, but we must also update #1 in the note content.\n\n## Using TaskIndex Correctly\nThe TaskIndex has a built-in toggle() method:\n```typescript\ntoggle(taskId: string): Task | null\n// - Returns null if task not found\n// - Toggles completed state\n// - Sets/clears completedAt\n// - Schedules persistence (debounced)\n```\n\nCall `await ctx.taskIndex.flush()` after toggle to ensure immediate persistence.\n\n## Acceptance Criteria\n- Toggles completion in note content (__checked property)\n- Toggles completion in task index via TaskIndex.toggle()\n- Returns new completion state\n- completedAt is set when completing\n- completedAt is cleared when uncompleting\n- Desktop app shows toggled state after restart\n- Works with tasks that exist in content but not yet in index","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T15:07:02.757169-06:00","updated_at":"2025-12-16T15:18:08.20579-06:00","dependencies":[{"issue_id":"scribe-i86","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T15:07:09.321141-06:00","created_by":"daemon"},{"issue_id":"scribe-i86","depends_on_id":"scribe-zly","type":"blocks","created_at":"2025-12-16T15:07:09.367903-06:00","created_by":"daemon"},{"issue_id":"scribe-i86","depends_on_id":"scribe-h54","type":"blocks","created_at":"2025-12-16T15:07:09.4138-06:00","created_by":"daemon"},{"issue_id":"scribe-i86","depends_on_id":"scribe-r4d","type":"blocks","created_at":"2025-12-16T15:07:09.459985-06:00","created_by":"daemon"},{"issue_id":"scribe-i86","depends_on_id":"scribe-y4f","type":"blocks","created_at":"2025-12-16T15:07:09.504515-06:00","created_by":"daemon"}]}
{"id":"scribe-jwx","title":"Implement 'notes show' command","description":"Implement the notes show command to display full note content and metadata.\n\n## Command\n```bash\nscribe notes show \u003cid\u003e [options]\n```\n\n## Options\n| Option | Description |\n|--------|-------------|\n| --include-raw | Include raw Lexical JSON in response |\n\n## Output Schema\n```json\n{\n  \"id\": \"abc-123\",\n  \"title\": \"Meeting with Alice\",\n  \"type\": \"meeting\",\n  \"tags\": [\"#work\", \"#1on1\"],\n  \"createdAt\": \"2025-12-15T10:30:00Z\",\n  \"updatedAt\": \"2025-12-15T11:45:00Z\",\n  \"content\": {\n    \"text\": \"Discussed Q3 roadmap...\\n\\n## Action Items\\n- [ ] Review budget\",\n    \"format\": \"plain\",\n    \"raw\": { /* Lexical JSON, only with --include-raw */ }\n  },\n  \"metadata\": {\n    \"links\": [\n      { \"id\": \"def-456\", \"title\": \"Project Roadmap\" }\n    ],\n    \"backlinks\": [\n      { \"id\": \"jkl-012\", \"title\": \"Weekly Summary\" }\n    ],\n    \"mentions\": [\n      { \"id\": \"person-bob\", \"name\": \"Bob\" }\n    ]\n  }\n}\n```\n\n## Implementation\n```typescript\nnotes\n  .command('show')\n  .argument('\u003cid\u003e', 'Note ID')\n  .option('--include-raw', 'Include raw Lexical JSON')\n  .action(async (id: string, options: { includeRaw?: boolean }) =\u003e {\n    const ctx = await initializeContext(program.opts());\n    \n    // Get note from vault\n    let note;\n    try {\n      note = ctx.vault.read(id);  // Note: vault.read() throws if not found\n    } catch (err) {\n      throw noteNotFound(id);\n    }\n    \n    // Extract content using content-extractor module\n    const content = extractContent(note.content, options.includeRaw);\n    \n    // Get backlinks from graph engine\n    const backlinks = ctx.graphEngine.backlinks(id);\n    \n    // Get outlinks from note metadata (not from graph engine - it doesn't have outlinks method)\n    const outlinks = getOutlinksFromNote(note, ctx.vault);\n    \n    // Get mentions from note metadata\n    const mentions = getMentionsFromNote(note, ctx.vault);\n    \n    output({\n      id: note.id,\n      title: note.title,\n      type: note.type,\n      tags: note.tags,\n      createdAt: new Date(note.createdAt).toISOString(),\n      updatedAt: new Date(note.updatedAt).toISOString(),\n      content,\n      metadata: {\n        links: outlinks,\n        backlinks: backlinks.map(l =\u003e ({ id: l.id, title: l.title })),\n        mentions,\n      },\n    }, ctx.options);\n  });\n\n// Helper: Get outgoing links with titles\nfunction getOutlinksFromNote(note: Note, vault: FileSystemVault): { id: string; title: string }[] {\n  const linkIds = note.metadata.links ?? [];\n  return linkIds.map(id =\u003e {\n    try {\n      const linkedNote = vault.read(id);\n      return { id: linkedNote.id, title: linkedNote.title };\n    } catch {\n      // Linked note doesn't exist (broken link) - still include but without title\n      return { id, title: '[deleted]' };\n    }\n  });\n}\n\n// Helper: Get mentions with names\nfunction getMentionsFromNote(note: Note, vault: FileSystemVault): { id: string; name: string }[] {\n  const mentionIds = note.metadata.mentions ?? [];\n  return mentionIds.map(id =\u003e {\n    try {\n      const personNote = vault.read(id);\n      return { id: personNote.id, name: personNote.title };\n    } catch {\n      return { id, name: '[unknown]' };\n    }\n  });\n}\n```\n\n## API Notes\n- `vault.read(id)` throws ScribeError if note not found\n- `graphEngine.backlinks(id)` returns GraphNode[] with id, title, type, tags\n- Outlinks come from `note.metadata.links` (array of NoteIds)\n- Mentions come from `note.metadata.mentions` (array of NoteIds)\n\n## Timestamp Formatting\nNote timestamps are stored as Unix milliseconds. Convert to ISO-8601 for output.\n\n## Content Extraction\nUses the content-extractor module (scribe-6vs dependency) to convert Lexical JSON to readable text.\n\n## Error Handling\n- NOTE_NOT_FOUND if ID doesn't exist\n- Gracefully handle broken links (notes that were deleted)\n- Include ID in error details for debugging\n\n## Acceptance Criteria\n- Shows full note content as plain text\n- Shows all metadata (title, type, tags, dates)\n- Shows outgoing links with titles (handles broken links)\n- Shows incoming backlinks with titles\n- Shows person mentions with names\n- --include-raw includes full Lexical JSON\n- Returns NOTE_NOT_FOUND error for invalid ID\n- Timestamps are ISO-8601 formatted","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T15:02:29.533302-06:00","updated_at":"2025-12-16T15:18:29.950956-06:00","dependencies":[{"issue_id":"scribe-jwx","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T15:02:35.86369-06:00","created_by":"daemon"},{"issue_id":"scribe-jwx","depends_on_id":"scribe-6vs","type":"blocks","created_at":"2025-12-16T15:02:35.908534-06:00","created_by":"daemon"},{"issue_id":"scribe-jwx","depends_on_id":"scribe-zly","type":"blocks","created_at":"2025-12-16T15:02:35.955291-06:00","created_by":"daemon"},{"issue_id":"scribe-jwx","depends_on_id":"scribe-h54","type":"blocks","created_at":"2025-12-16T15:02:36.000794-06:00","created_by":"daemon"},{"issue_id":"scribe-jwx","depends_on_id":"scribe-r4d","type":"blocks","created_at":"2025-12-16T15:02:36.044739-06:00","created_by":"daemon"},{"issue_id":"scribe-jwx","depends_on_id":"scribe-y4f","type":"blocks","created_at":"2025-12-16T15:02:36.089456-06:00","created_by":"daemon"}]}
{"id":"scribe-m1i","title":"Implement 'notes delete' command","description":"Implement note deletion with backlink protection.\n\n## Command\n```bash\nscribe notes delete \u003cid\u003e [options]\n```\n\n## Arguments\n- \u003cid\u003e - Note ID (required)\n\n## Options\n| Option | Description | Default |\n|--------|-------------|---------|\n| --force | Delete even if note has backlinks | false |\n\n## Output Schema (has backlinks, no --force)\n```json\n{\n  \"success\": false,\n  \"error\": \"Note has incoming links from other notes\",\n  \"code\": \"HAS_BACKLINKS\",\n  \"noteId\": \"abc-123\",\n  \"backlinkCount\": 3,\n  \"backlinks\": [\n    { \"id\": \"def-456\", \"title\": \"Weekly Summary\" }\n  ],\n  \"hint\": \"Use --force to delete anyway (backlinks will become broken)\"\n}\n```\n\n## Output Schema (success)\n```json\n{\n  \"success\": true,\n  \"deleted\": {\n    \"id\": \"abc-123\",\n    \"title\": \"Meeting with Alice\"\n  },\n  \"brokenBacklinks\": 0\n}\n```\n\n## Output Schema (with --force and backlinks)\n```json\n{\n  \"success\": true,\n  \"deleted\": {\n    \"id\": \"abc-123\",\n    \"title\": \"Meeting with Alice\"\n  },\n  \"brokenBacklinks\": 3,\n  \"warning\": \"3 notes now have broken links to this note\"\n}\n```\n\n## Implementation Flow\n1. Check if note exists\n2. Get backlinks from GraphEngine\n3. If backlinks exist and no --force, return HAS_BACKLINKS error\n4. If --force or no backlinks, delete note file\n5. Return success with broken backlink count\n\n## Safety Considerations\n- Deletion is PERMANENT (no undo)\n- Backlinks in other notes become broken\n- Desktop app has same behavior (no special handling of broken links)\n- Task index entries for deleted note should be cleaned up\n\n## Acceptance Criteria\n- Returns HAS_BACKLINKS if note has incoming links (without --force)\n- Includes list of backlinks in error for user awareness\n- --force deletes even with backlinks\n- Success response includes broken backlink count\n- Note file is removed from disk\n- Task index is updated (tasks from deleted note removed)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-16T15:06:40.747894-06:00","updated_at":"2025-12-16T15:06:40.747894-06:00","dependencies":[{"issue_id":"scribe-m1i","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T15:06:45.209866-06:00","created_by":"daemon"},{"issue_id":"scribe-m1i","depends_on_id":"scribe-6nq","type":"blocks","created_at":"2025-12-16T15:06:45.256908-06:00","created_by":"daemon"},{"issue_id":"scribe-m1i","depends_on_id":"scribe-zly","type":"blocks","created_at":"2025-12-16T15:06:45.302288-06:00","created_by":"daemon"},{"issue_id":"scribe-m1i","depends_on_id":"scribe-h54","type":"blocks","created_at":"2025-12-16T15:06:45.351202-06:00","created_by":"daemon"},{"issue_id":"scribe-m1i","depends_on_id":"scribe-r4d","type":"blocks","created_at":"2025-12-16T15:06:45.396821-06:00","created_by":"daemon"},{"issue_id":"scribe-m1i","depends_on_id":"scribe-y4f","type":"blocks","created_at":"2025-12-16T15:06:45.443893-06:00","created_by":"daemon"}]}
{"id":"scribe-r4d","title":"Implement error handling framework","description":"Create a consistent error handling system with structured error output and exit codes.\n\n## Error Types (src/errors.ts)\n```typescript\nexport enum ErrorCode {\n  INTERNAL_ERROR = 'INTERNAL_ERROR',\n  VAULT_NOT_FOUND = 'VAULT_NOT_FOUND',\n  NOTE_NOT_FOUND = 'NOTE_NOT_FOUND',\n  INVALID_INPUT = 'INVALID_INPUT',\n  WRITE_FAILED = 'WRITE_FAILED',\n  PERMISSION_DENIED = 'PERMISSION_DENIED',\n  HAS_BACKLINKS = 'HAS_BACKLINKS',\n}\n\nexport const EXIT_CODES: Record\u003cErrorCode, number\u003e = {\n  INTERNAL_ERROR: 1,\n  VAULT_NOT_FOUND: 2,\n  NOTE_NOT_FOUND: 3,\n  INVALID_INPUT: 4,\n  WRITE_FAILED: 5,\n  PERMISSION_DENIED: 6,\n  HAS_BACKLINKS: 3, // Same as NOT_FOUND - still an error\n};\n\nexport class CLIError extends Error {\n  constructor(\n    message: string,\n    public code: ErrorCode,\n    public details?: Record\u003cstring, unknown\u003e,\n    public hint?: string\n  ) {\n    super(message);\n    this.name = 'CLIError';\n  }\n}\n```\n\n## Error Output Format\n```typescript\nexport interface ErrorOutput {\n  error: string;      // Human-readable message\n  code: ErrorCode;    // Machine-readable code\n  details?: Record\u003cstring, unknown\u003e;  // Additional context\n  hint?: string;      // Suggested fix\n}\n\nexport function formatError(err: CLIError): ErrorOutput {\n  return {\n    error: err.message,\n    code: err.code,\n    ...(err.details \u0026\u0026 { details: err.details }),\n    ...(err.hint \u0026\u0026 { hint: err.hint }),\n  };\n}\n```\n\n## Global Error Handler\n```typescript\n// In src/index.ts\nprocess.on('uncaughtException', (err) =\u003e {\n  const cliError = err instanceof CLIError \n    ? err \n    : new CLIError(err.message, ErrorCode.INTERNAL_ERROR);\n  \n  console.log(JSON.stringify(formatError(cliError)));\n  process.exit(EXIT_CODES[cliError.code]);\n});\n```\n\n## Specific Error Constructors\n```typescript\nexport function vaultNotFound(path: string): CLIError {\n  return new CLIError(\n    `Vault not found at ${path}`,\n    ErrorCode.VAULT_NOT_FOUND,\n    { path },\n    'Specify vault with --vault flag or SCRIBE_VAULT_PATH environment variable'\n  );\n}\n\nexport function noteNotFound(id: string): CLIError {\n  return new CLIError(\n    'Note not found',\n    ErrorCode.NOTE_NOT_FOUND,\n    { id }\n  );\n}\n\nexport function hasBacklinks(noteId: string, backlinks: Array\u003c{id: string, title: string}\u003e): CLIError {\n  return new CLIError(\n    'Note has incoming links from other notes',\n    ErrorCode.HAS_BACKLINKS,\n    { noteId, backlinkCount: backlinks.length, backlinks },\n    'Use --force to delete anyway (backlinks will become broken)'\n  );\n}\n```\n\n## Text Format Errors\nWhen --format text, errors should be human-readable:\n```\nError: Vault not found at /path/to/vault\nHint: Specify vault with --vault flag or SCRIBE_VAULT_PATH environment variable\n```\n\n## Acceptance Criteria\n- All errors produce structured JSON output\n- Exit codes match the documented values\n- Errors include helpful hints where applicable\n- Text format produces human-readable errors\n- Uncaught exceptions are caught and formatted\n- Error details include relevant context (paths, IDs, etc.)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T15:00:40.358109-06:00","updated_at":"2025-12-16T15:00:40.358109-06:00","dependencies":[{"issue_id":"scribe-r4d","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T15:00:44.729534-06:00","created_by":"daemon"},{"issue_id":"scribe-r4d","depends_on_id":"scribe-0yl","type":"blocks","created_at":"2025-12-16T15:00:44.774031-06:00","created_by":"daemon"}]}
{"id":"scribe-rh3","title":"Implement shell completion generation","description":"Generate shell completion scripts for bash, zsh, and fish.\n\n## Command\n```bash\nscribe completion \u003cshell\u003e\n```\n\n## Arguments\n- \u003cshell\u003e - Shell type: bash, zsh, fish\n\n## Usage\n```bash\n# Generate and source directly\neval \"$(scribe completion bash)\"\n\n# Or save to file\nscribe completion zsh \u003e ~/.zfunc/_scribe\nscribe completion fish \u003e ~/.config/fish/completions/scribe.fish\n```\n\n## Implementation with Commander.js\nCommander.js has built-in completion support, but may need customization.\n\nAlternative: Use a completion library like tabtab or omelette.\n\n## Completions to Include\n- All commands and subcommands\n- Option names (--vault, --format, etc.)\n- Static option values (--format json, --format text, --status open, etc.)\n\n## Not Included (MVP)\n- Dynamic completion of note IDs (requires vault loading)\n- Dynamic completion of tag names (requires vault loading)\n- Dynamic completion of task IDs\n\nReason: Dynamic completion would require loading the vault on every tab press, which is too slow.\n\n## Output Format\nScripts should be valid for each shell and work when sourced/evaled.\n\n## Acceptance Criteria\n- bash completion works when sourced\n- zsh completion works with compinit\n- fish completion works in fish shell\n- Completes all commands and subcommands\n- Completes all option names\n- Completes static option values","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-16T15:07:37.97974-06:00","updated_at":"2025-12-16T15:07:37.97974-06:00","dependencies":[{"issue_id":"scribe-rh3","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T15:07:41.725489-06:00","created_by":"daemon"},{"issue_id":"scribe-rh3","depends_on_id":"scribe-zly","type":"blocks","created_at":"2025-12-16T15:07:41.769623-06:00","created_by":"daemon"}]}
{"id":"scribe-thf","title":"Implement 'notes add-task' command","description":"Implement adding tasks (checkbox items) to notes.\n\n## Command\n```bash\nscribe notes add-task \u003cid\u003e \u003ctext\u003e\n```\n\n## Arguments\n- \u003cid\u003e - Note ID (required)\n- \u003ctext\u003e - Task text (required)\n\n## Output Schema\n```json\n{\n  \"success\": true,\n  \"task\": {\n    \"id\": \"abc-123:node_xyz:a1b2c3d4\",\n    \"text\": \"Send meeting notes to team\",\n    \"completed\": false,\n    \"noteId\": \"abc-123\",\n    \"noteTitle\": \"Meeting with Alice\"\n  }\n}\n```\n\n## Task ID Generation\nTask IDs are composite: `noteId:nodeKey:contentHash`\n- nodeKey: Generated unique key for the Lexical node\n- contentHash: First 8 chars of SHA256 hash of task text\n\n## Implementation\n```typescript\nnotes\n  .command('add-task')\n  .argument('\u003cid\u003e', 'Note ID')\n  .argument('\u003ctext\u003e', 'Task text')\n  .action(async (id: string, text: string) =\u003e {\n    const ctx = await initializeContext(program.opts());\n    \n    const note = ctx.vault.getNote(id);\n    if (!note) throw noteNotFound(id);\n    \n    // Create checklist item node\n    const taskNode = createChecklistItemNode(text, false);\n    \n    // Find or create checklist in note, append task\n    const updatedContent = appendTaskToContent(note.content, taskNode);\n    \n    // Save note\n    await ctx.vault.updateNote(id, { content: updatedContent });\n    \n    // Update task index\n    const taskId = generateTaskId(id, taskNode, text);\n    await ctx.taskIndex.addTask({\n      id: taskId,\n      text,\n      completed: false,\n      noteId: id,\n      createdAt: new Date().toISOString(),\n    });\n    await ctx.taskIndex.persist();\n    \n    output({\n      success: true,\n      task: {\n        id: taskId,\n        text,\n        completed: false,\n        noteId: id,\n        noteTitle: note.title,\n      },\n    }, ctx.options);\n  });\n```\n\n## Appending Strategy\nOptions for where to add the task:\n1. Append to existing checklist if note has one\n2. Create new checklist at end of note if no existing checklist\n3. Always append at end of note (simplest for MVP)\n\nFor MVP: Always append as new listitem at end of note.\n\n## Task Index Update\nAfter adding task to note content, must also:\n1. Generate task ID\n2. Add to TaskIndex\n3. Persist index to derived/tasks.jsonl\n\n## Acceptance Criteria\n- Creates unchecked task in note\n- Returns generated task ID\n- Task index is updated\n- Task visible in desktop app\n- Task visible in 'tasks list' command","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T15:06:07.809463-06:00","updated_at":"2025-12-16T15:06:07.809463-06:00","dependencies":[{"issue_id":"scribe-thf","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T15:06:11.839986-06:00","created_by":"daemon"},{"issue_id":"scribe-thf","depends_on_id":"scribe-1fp","type":"blocks","created_at":"2025-12-16T15:06:11.889326-06:00","created_by":"daemon"},{"issue_id":"scribe-thf","depends_on_id":"scribe-zly","type":"blocks","created_at":"2025-12-16T15:06:11.934696-06:00","created_by":"daemon"},{"issue_id":"scribe-thf","depends_on_id":"scribe-h54","type":"blocks","created_at":"2025-12-16T15:06:11.980651-06:00","created_by":"daemon"},{"issue_id":"scribe-thf","depends_on_id":"scribe-r4d","type":"blocks","created_at":"2025-12-16T15:06:12.024226-06:00","created_by":"daemon"},{"issue_id":"scribe-thf","depends_on_id":"scribe-y4f","type":"blocks","created_at":"2025-12-16T15:06:12.068593-06:00","created_by":"daemon"}]}
{"id":"scribe-w22","title":"Implement people commands (list, mentions)","description":"Implement person listing and mention tracking.\n\n## Commands\n\n### scribe people list\nList all person notes with mention statistics.\n\nOptions:\n| Option | Description | Default |\n|--------|-------------|---------|\n| --limit \u003cn\u003e | Max results | 100 |\n\nOutput:\n```json\n{\n  \"people\": [\n    {\n      \"id\": \"person-alice\",\n      \"name\": \"Alice Smith\",\n      \"mentionCount\": 12,\n      \"lastMentioned\": \"2025-12-15T10:30:00Z\"\n    }\n  ],\n  \"total\": 15\n}\n```\n\n### scribe people mentions \u003cid\u003e\nGet notes that mention a specific person.\n\nOutput:\n```json\n{\n  \"person\": {\n    \"id\": \"person-alice\",\n    \"name\": \"Alice Smith\"\n  },\n  \"mentions\": [\n    {\n      \"id\": \"abc-123\",\n      \"title\": \"Meeting with Alice\",\n      \"type\": \"meeting\",\n      \"mentionContext\": \"...sync with @Alice about the Q3...\"\n    }\n  ],\n  \"count\": 12\n}\n```\n\n## Implementation\n- Person notes have type='person'\n- Mentions are tracked via person-mention nodes in Lexical content\n- Extract mention context (text around @mention) for better LLM understanding\n- Sort by mention count descending by default\n\n## Mention Context\n- Extract ~50 chars before and after the mention\n- Multiple mentions in same note = multiple context snippets\n- Use first mention context for the response\n\n## Acceptance Criteria\n- Lists all person notes with accurate mention counts\n- Mention retrieval finds all notes mentioning a person\n- Context snippets show relevant text around mentions\n- Last mentioned date is accurate","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-16T15:03:44.604996-06:00","updated_at":"2025-12-16T15:03:44.604996-06:00","dependencies":[{"issue_id":"scribe-w22","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T15:03:50.142407-06:00","created_by":"daemon"},{"issue_id":"scribe-w22","depends_on_id":"scribe-zly","type":"blocks","created_at":"2025-12-16T15:03:50.185455-06:00","created_by":"daemon"},{"issue_id":"scribe-w22","depends_on_id":"scribe-h54","type":"blocks","created_at":"2025-12-16T15:03:50.228088-06:00","created_by":"daemon"},{"issue_id":"scribe-w22","depends_on_id":"scribe-r4d","type":"blocks","created_at":"2025-12-16T15:03:50.272015-06:00","created_by":"daemon"},{"issue_id":"scribe-w22","depends_on_id":"scribe-y4f","type":"blocks","created_at":"2025-12-16T15:03:50.314314-06:00","created_by":"daemon"}]}
{"id":"scribe-xfk","title":"Add outlinks() method to GraphEngine","description":"Add outlinks() method to GraphEngine.\n\n## Background\nThe GraphEngine already maintains outgoing edges in `private outgoing: Map\u003cNoteId, Set\u003cNoteId\u003e\u003e` but has no public method to access them. The `backlinks()` method exists for incoming edges - we need the symmetric `outlinks()` method.\n\n## Implementation\nAdd to `packages/engine-graph/src/graph-engine.ts`:\n\n```typescript\n/**\n * Get all notes that the given note links to (outlinks)\n */\noutlinks(noteId: NoteId): GraphNode[] {\n  const outgoingIds = this.outgoing.get(noteId);\n  if (!outgoingIds) {\n    return [];\n  }\n\n  return Array.from(outgoingIds)\n    .map((id) =\u003e this.nodes.get(id))\n    .filter((node): node is GraphNode =\u003e node !== undefined);\n}\n```\n\n## Testing\nAdd to `packages/engine-graph/src/graph-engine.test.ts`:\n\n```typescript\ndescribe('outlinks', () =\u003e {\n  it('returns notes that the given note links to', () =\u003e {\n    const noteA = createNote({ id: 'a', title: 'A', links: ['b', 'c'] });\n    const noteB = createNote({ id: 'b', title: 'B', links: [] });\n    const noteC = createNote({ id: 'c', title: 'C', links: [] });\n    \n    engine.addNote(noteA);\n    engine.addNote(noteB);\n    engine.addNote(noteC);\n    \n    const outlinks = engine.outlinks('a');\n    expect(outlinks).toHaveLength(2);\n    expect(outlinks.map(n =\u003e n.id)).toContain('b');\n    expect(outlinks.map(n =\u003e n.id)).toContain('c');\n  });\n  \n  it('returns empty array for note with no outlinks', () =\u003e {\n    const note = createNote({ id: 'a', title: 'A', links: [] });\n    engine.addNote(note);\n    expect(engine.outlinks('a')).toEqual([]);\n  });\n  \n  it('returns empty array for unknown note', () =\u003e {\n    expect(engine.outlinks('unknown')).toEqual([]);\n  });\n  \n  it('filters out broken links to deleted notes', () =\u003e {\n    const noteA = createNote({ id: 'a', title: 'A', links: ['b'] });\n    engine.addNote(noteA);\n    // Note 'b' is never added, so it's a broken link\n    \n    const outlinks = engine.outlinks('a');\n    expect(outlinks).toEqual([]);  // Broken links are filtered\n  });\n});\n```\n\n## Why Priority 1\nThis is a blocker for `scribe-6nq` (graph commands). The workaround in that bead is less elegant and duplicates logic. Better to add the proper API method.\n\n## Acceptance Criteria\n- `outlinks()` method returns GraphNode[] of notes the target note links to\n- Broken links (to non-existent notes) are filtered out\n- Returns empty array for unknown note IDs\n- Unit tests pass","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T15:21:48.178039-06:00","updated_at":"2025-12-16T15:24:57.854154-06:00","dependencies":[{"issue_id":"scribe-xfk","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T15:21:52.802286-06:00","created_by":"daemon"}]}
{"id":"scribe-y4f","title":"Implement output formatting (JSON and text)","description":"Create the output formatting system that handles JSON (default) and text output modes.\n\n## Output Module (src/output.ts)\n```typescript\nexport type OutputFormat = 'json' | 'text';\n\nexport interface OutputOptions {\n  format: OutputFormat;\n  quiet?: boolean;\n  verbose?: boolean;\n}\n\nexport function output(data: unknown, options: OutputOptions): void {\n  if (options.format === 'json') {\n    outputJSON(data);\n  } else {\n    outputText(data);\n  }\n}\n\nfunction outputJSON(data: unknown): void {\n  // Pretty-print with 2-space indent for human readability\n  // Could add --compact flag for minified output if needed\n  console.log(JSON.stringify(data, null, 2));\n}\n\nfunction outputText(data: unknown): void {\n  // Data-type specific text formatting\n  // Each command response type needs a text formatter\n  const formatted = formatAsText(data);\n  console.log(formatted);\n}\n```\n\n## Text Formatters\nEach response type needs a text formatter:\n\n```typescript\n// For notes list\nfunction formatNotesList(data: NotesListResponse): string {\n  return data.notes.map(note =\u003e \n    `${note.title} (${note.id})\\n  Type: ${note.type} | Tags: ${note.tags.join(', ')}\\n  Updated: ${formatDate(note.updatedAt)}`\n  ).join('\\n\\n') + `\\n\\nTotal: ${data.total} notes`;\n}\n\n// For note show\nfunction formatNoteShow(data: NoteShowResponse): string {\n  return `# ${data.title}\nType: ${data.type} | Tags: ${data.tags.join(', ')}\nCreated: ${formatDate(data.createdAt)} | Updated: ${formatDate(data.updatedAt)}\n\n${data.content.text}\n\nLinks: ${data.metadata.links.map(l =\u003e l.title).join(', ')}\nBacklinks: ${data.metadata.backlinks.map(l =\u003e l.title).join(', ')}`;\n}\n```\n\n## Verbose/Debug Output\nWrite to stderr to not pollute JSON output:\n\n```typescript\nexport function verbose(message: string, options: OutputOptions): void {\n  if (options.verbose) {\n    console.error(`[verbose] ${message}`);\n  }\n}\n\nexport function debug(message: string, options: OutputOptions): void {\n  if (options.debug) {\n    console.error(`[debug] ${message}`);\n  }\n}\n\n// Timing helper for debug mode\nexport function timed\u003cT\u003e(label: string, fn: () =\u003e T, options: OutputOptions): T {\n  if (!options.debug) return fn();\n  \n  const start = performance.now();\n  const result = fn();\n  const elapsed = performance.now() - start;\n  console.error(`[timing] ${label}: ${elapsed.toFixed(2)}ms`);\n  return result;\n}\n```\n\n## Date Formatting\nConsistent date formatting for text output:\n```typescript\nfunction formatDate(iso: string): string {\n  const date = new Date(iso);\n  return date.toLocaleString('en-US', {\n    year: 'numeric',\n    month: 'short',\n    day: 'numeric',\n    hour: '2-digit',\n    minute: '2-digit',\n  });\n}\n```\n\n## Considerations\n- JSON is the primary format - text is for human debugging\n- Text formatters can be added incrementally as commands are implemented\n- Consider table formatting for list output (align columns)\n- Truncate long content in text mode for readability\n\n## Acceptance Criteria\n- JSON output is valid, parseable JSON\n- JSON is pretty-printed with 2-space indent\n- Text output is human-readable\n- Verbose/debug messages go to stderr\n- Date formatting is consistent across commands\n- Each command type has appropriate text formatter","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T15:01:03.178048-06:00","updated_at":"2025-12-16T15:01:03.178048-06:00","dependencies":[{"issue_id":"scribe-y4f","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T15:01:07.256973-06:00","created_by":"daemon"},{"issue_id":"scribe-y4f","depends_on_id":"scribe-0yl","type":"blocks","created_at":"2025-12-16T15:01:07.304965-06:00","created_by":"daemon"}]}
{"id":"scribe-zly","title":"Implement CLI parser with Commander.js","description":"Set up the command-line argument parsing infrastructure using Commander.js.\n\n## Why Commander.js\n- Well-established, stable library\n- Excellent TypeScript support\n- Built-in help generation\n- Subcommand support (notes, search, graph, etc.)\n- Easy to add shell completion later\n\n## Implementation: src/cli.ts\n```typescript\nimport { Command } from 'commander';\n\nexport function createCLI(): Command {\n  const program = new Command()\n    .name('scribe')\n    .description('Query and modify Scribe vaults from the command line')\n    .version('0.1.0');\n  \n  // Global options (available to all commands)\n  program\n    .option('--vault \u003cpath\u003e', 'Override vault path')\n    .option('--format \u003cformat\u003e', 'Output format: json or text', 'json')\n    .option('--include-raw', 'Include raw Lexical JSON in content responses')\n    .option('--quiet', 'Suppress non-essential output')\n    .option('--verbose', 'Show detailed operation info (to stderr)')\n    .option('--debug', 'Show debug information including timing (to stderr)');\n\n  // Subcommand registration points\n  // registerNotesCommands(program);\n  // registerSearchCommands(program);\n  // etc.\n\n  return program;\n}\n```\n\n## Entry Point: src/index.ts\n```typescript\nimport { createCLI } from './cli';\n\nconst cli = createCLI();\ncli.parseAsync(process.argv).catch((err) =\u003e {\n  console.error(JSON.stringify({ error: err.message, code: 'INTERNAL_ERROR' }));\n  process.exit(1);\n});\n```\n\n## Global Options Handling\n- Options should be accessible in command handlers via program.opts()\n- --format affects all output (JSON vs human-readable text)\n- --verbose and --debug write to stderr (not stdout, to not pollute JSON output)\n\n## Subcommand Structure\n- notes (list, show, find, create, append, add-task, update, delete)\n- search\n- graph (backlinks, outlinks, neighbors, stats)\n- tags (list, notes)\n- people (list, mentions)\n- tasks (list, toggle, set-priority)\n- daily (show, create)\n- vault (info)\n- completion (bash, zsh, fish)\n\n## Considerations\n- Keep cli.ts focused on argument structure, not business logic\n- Each command group gets its own file (src/commands/*.ts)\n- Command handlers receive parsed options and call appropriate engine methods\n\n## Acceptance Criteria\n- `scribe --help` shows all commands and global options\n- `scribe notes --help` shows notes subcommands\n- Unknown commands produce helpful error\n- Global options are accessible in all command handlers","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-16T14:59:20.794577-06:00","updated_at":"2025-12-16T14:59:20.794577-06:00","dependencies":[{"issue_id":"scribe-zly","depends_on_id":"scribe-1nb","type":"parent-child","created_at":"2025-12-16T14:59:25.994999-06:00","created_by":"daemon"},{"issue_id":"scribe-zly","depends_on_id":"scribe-0yl","type":"blocks","created_at":"2025-12-16T14:59:26.039975-06:00","created_by":"daemon"}]}
