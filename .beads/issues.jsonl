{"id":"scribe-0fq","title":"Refactor ScribeError into specialized error subclasses","description":"**Problem**: `ScribeError` (errors.ts) is the only error class, with all types distinguished by enum. This limits:\n- Pattern matching with `instanceof`\n- Type-safe error handling\n- Extension with domain-specific data\n\n**Missing system error codes in `fromSystemError()`**:\n- EEXIST (file exists)\n- EISDIR (is a directory)\n- ENOTDIR (not a directory)\n- EMFILE/ENFILE (too many open files)\n- ENOTEMPTY (directory not empty)\n\n**Solution**: Introduce subclasses:\n```typescript\nclass FileSystemError extends ScribeError { path: string; }\nclass NoteError extends ScribeError { noteId: NoteId; }\nclass VaultError extends ScribeError { vaultPath: VaultPath; }\nclass EngineError extends ScribeError { engine: string; }\n```\n\n**Files**: packages/shared/src/errors.ts\n**Impact**: Enables `catch (e) { if (e instanceof FileSystemError) ... }` pattern","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:00:33.416373-06:00","updated_at":"2025-12-12T22:40:04.208069-06:00","closed_at":"2025-12-12T22:40:04.208069-06:00","dependencies":[{"issue_id":"scribe-0fq","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:00:36.802445-06:00","created_by":"daemon"}]}
{"id":"scribe-0o7","title":"Remove or integrate unused design system primitives","description":"Several design system primitives are exported but never used in the application:\n\n**Unused Primitives:**\n- Input (packages/design-system/src/primitives/Input/)\n- Overlay (packages/design-system/src/primitives/Overlay/)\n- Portal (packages/design-system/src/primitives/Portal/)\n- List (packages/design-system/src/primitives/List/)\n- ListItem (packages/design-system/src/primitives/List/)\n- HistoryIcon (packages/design-system/src/icons/icons.tsx)\n\n**Options:**\n1. Remove unused primitives to reduce bundle size\n2. Document these as 'available for future use'\n3. Integrate them into the application where appropriate\n\n**Files:**\n- packages/design-system/src/primitives/\n- packages/design-system/src/icons/icons.tsx","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:19:40.402099-06:00","updated_at":"2025-12-13T01:17:56.79462-06:00","closed_at":"2025-12-13T01:17:56.79462-06:00","dependencies":[{"issue_id":"scribe-0o7","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:20:26.622773-06:00","created_by":"daemon"}]}
{"id":"scribe-0w9","title":"Code Cleanup \u0026 Technical Debt Reduction","description":"Epic tracking 88 code cleanup issues organized into parallel work tracks.\n\n## Work Tracks\n\n**Track A - Critical Bugs (P1):** scribe-f47, scribe-k5r (race conditions), scribe-ys3 (determinism), scribe-3r5 (memory leak)\n\n**Track B - Main Process:** scribe-930 (IPC refactor) → scribe-5na, scribe-8fq, scribe-0w9.4\n\n**Track C - TaskIndex:** scribe-l59 → scribe-ct6 → scribe-3px → scribe-9jq\n\n**Track D - FileSystemVault:** scribe-8xm, scribe-xub, scribe-1rf, scribe-bk5 (parallel)\n\n**Track E - Plugins:** scribe-9cl → scribe-6my, scribe-bq3, scribe-a0k\n\n**Track F - UI Refactoring:** scribe-1sh → scribe-5lp, scribe-arr; scribe-5es\n\n**Track G - Type System:** scribe-9st, scribe-ncq, scribe-0fq, scribe-zz5 (parallel)\n\n**Track H - Tests:** 20+ test tasks (highly parallel)\n\n**Track I - Design System:** scribe-99n, scribe-3ix, scribe-69x, scribe-rwj\n\n## Execution Order\n1. Track A first (critical bugs)\n2. All other tracks can run in parallel\n3. Within tracks, follow → arrows (blocks dependencies)","status":"closed","priority":2,"issue_type":"epic","created_at":"2025-12-12T20:59:09.984968-06:00","updated_at":"2025-12-13T01:41:17.380626-06:00","closed_at":"2025-12-13T01:41:17.380626-06:00"}
{"id":"scribe-0w9.1","title":"Add tests for SlashMenuPlugin interactions","description":"apps/desktop/renderer/src/components/Editor/SlashMenu/SlashMenuPlugin.tsx is 341 lines of trigger detection, query filtering, keyboard handling, and portal rendering logic, but there are zero tests referencing it. Regressions in slash command insertion or menu dismissal will only show up in manual QA. Add unit/integration tests that cover: detecting the '/' trigger at valid positions, updating the query as text changes, handling escape/down/up/enter shortcuts, executing the selected SlashCommand, and preventing retrigger loops via the insertion counter. Mock Lexical editor state so the tests can assert that command actions remove the trigger text and that the menu closes when focus or selection moves away. Also cover the fast-dismiss path when the user types a space after the trigger.","acceptance_criteria":"- Tests fail if trigger detection breaks (e.g., slash typed mid-word)\n- Tests cover keyboard navigation and command execution states\n- Menu dismissal on space/escape and on selection change is verified","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:26:04.245708-06:00","updated_at":"2025-12-12T21:43:17.282164-06:00","closed_at":"2025-12-12T21:43:17.282164-06:00","dependencies":[{"issue_id":"scribe-0w9.1","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:26:04.246064-06:00","created_by":"daemon"},{"issue_id":"scribe-0w9.1","depends_on_id":"scribe-yhw","type":"related","created_at":"2025-12-12T21:42:23.234136-06:00","created_by":"daemon"}]}
{"id":"scribe-0w9.2","title":"Add tests for SelectionToolbarPlugin formatting","description":"apps/desktop/renderer/src/components/Editor/SelectionToolbar/SelectionToolbarPlugin.tsx is a 333-line Lexical plugin that positions the floating format toolbar, tracks active marks, and toggles heading transformations, but there is no automated coverage. Bugs in selection detection, toolbar positioning logic, or heading toggling would only surface manually. Add tests that simulate Lexical selections and native selection events to verify: toolbar only appears for non-empty selections, positioning clamps within the viewport, active format state reflects bold/italic/underline/highlight/heading combos, and clicking toolbar buttons dispatches the expected Lexical commands (FORMAT_TEXT_COMMAND, heading conversion back to paragraph, etc.). Also cover the \"Ask AI\" placeholder to ensure it stays a no-op until implemented.","acceptance_criteria":"- Tests fail when toolbar incorrectly appears/disappears for selections\n- Formatting button interactions are asserted via Lexical dispatch mocks\n- Positioning/viewport clamping logic is covered","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:26:14.533127-06:00","updated_at":"2025-12-12T21:43:17.330099-06:00","closed_at":"2025-12-12T21:43:17.330099-06:00","dependencies":[{"issue_id":"scribe-0w9.2","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:26:14.533484-06:00","created_by":"daemon"},{"issue_id":"scribe-0w9.2","depends_on_id":"scribe-mii","type":"related","created_at":"2025-12-12T21:42:23.279845-06:00","created_by":"daemon"}]}
{"id":"scribe-0w9.3","title":"Add tests for TableUIPlugin hover controls","description":"apps/desktop/renderer/src/components/Editor/plugins/TableUIPlugin.tsx (417 lines) renders the floating add/delete row \u0026 column controls, but no automated tests assert its hover detection or Lexical mutations. The plugin debounces mousemove events, tracks DOMRects, and issues Lexical table mutations ($insertTableRowAtSelection, $deleteTableColumnAtSelection, etc.). Bugs here would break table editing without failing CI. Add tests that simulate mouse movement near tables to verify the hover zone behavior, ensure we only show add/delete buttons at the edges, and assert that clicking those buttons dispatches the correct Lexical helpers. Include coverage for hiding controls when the cursor leaves the hover zone and for the delete button positioning logic.","acceptance_criteria":"- Table hover simulation tests fail if add/delete buttons render at the wrong times\n- Lexical mutations invoked by insert/delete handlers are asserted\n- Hover-zone timeouts and hide timers are covered","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:26:19.434307-06:00","updated_at":"2025-12-12T21:43:17.379511-06:00","closed_at":"2025-12-12T21:43:17.379511-06:00","dependencies":[{"issue_id":"scribe-0w9.3","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:26:19.434648-06:00","created_by":"daemon"},{"issue_id":"scribe-0w9.3","depends_on_id":"scribe-rmk","type":"related","created_at":"2025-12-12T21:42:23.324185-06:00","created_by":"daemon"}]}
{"id":"scribe-0w9.4","title":"Deduplicate preload API surface and renderer type definitions","description":"The preload bridge in apps/desktop/electron/preload/src/preload.ts (378 lines) hand-wires every IPC channel with inline docs, and apps/desktop/renderer/src/types/scribe.d.ts (213 lines) re-declares the same shape so the renderer gets TypeScript support. This duplication is already drifting (e.g., preload exports update.onAvailable/onDownloaded docs that do not exist in the d.ts), and every new IPC endpoint has to be added in two places manually. Extract a shared contract (e.g., a typed interface or literal object in packages/shared) and generate both the preload bridge implementation and the renderer ambient type declarations from it. This ensures the renderer cannot call APIs that the preload layer forgot to expose and eliminates ~200 lines of redundant documentation.","acceptance_criteria":"- Single source of truth defines the Scribe IPC surface\n- Preload bridge imports that contract instead of duplicating docs\n- Renderer ambient types come from the same source (codegen or shared interface)\n- Existing API consumers keep type safety","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:26:24.267426-06:00","updated_at":"2025-12-12T23:59:41.603286-06:00","closed_at":"2025-12-12T23:59:41.603286-06:00","dependencies":[{"issue_id":"scribe-0w9.4","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:26:24.267799-06:00","created_by":"daemon"},{"issue_id":"scribe-0w9.4","depends_on_id":"scribe-930","type":"related","created_at":"2025-12-12T21:42:18.072834-06:00","created_by":"daemon"}]}
{"id":"scribe-0zb","title":"Add tests for ErrorBoundary component","description":"ErrorBoundary.tsx has NO tests despite being a critical error handling component.\n\n**Test scenarios:**\n- Error catching and display\n- Error message formatting\n- Recovery/retry functionality\n- Child component rendering when no error\n- Error logging behavior\n\n**Files:**\n- apps/desktop/renderer/src/components/ErrorBoundary/ErrorBoundary.tsx","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:27:35.940983-06:00","updated_at":"2025-12-12T23:52:21.543269-06:00","closed_at":"2025-12-12T23:52:21.543269-06:00","dependencies":[{"issue_id":"scribe-0zb","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:27:41.840474-06:00","created_by":"daemon"}]}
{"id":"scribe-15q","title":"Add concurrent modification tests for TaskIndex","description":"Add tests for concurrent/race condition scenarios in task-index.test.ts:\n- Multiple rapid indexNote() calls on same note\n- Concurrent toggle() calls on same task\n- indexNote() during scheduled persist (debounce timer running)\n- Multiple notes being indexed simultaneously\n- reorder() during indexNote() on overlapping tasks\n\nCurrent tests cover basic CRUD but don't test timing/concurrency edge cases.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:00:49.468977-06:00","updated_at":"2025-12-13T01:12:41.234687-06:00","closed_at":"2025-12-13T01:12:41.234687-06:00","dependencies":[{"issue_id":"scribe-15q","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:00:52.899864-06:00","created_by":"daemon"}]}
{"id":"scribe-1rf","title":"Refactor FileSystemVault: Extract NoteValidator for structure checks","description":"FileSystemVault.isValidNote() (lines 322-385) is a 63-line validation method with complex nested field checks.\n\n**Extract: NoteValidator**\n- Move isValidNote() method entirely\n- Encapsulate all field validation rules\n- Add specific error messages for each validation failure\n\n**Interface:**\n```typescript\ninterface NoteValidator {\n  validate(note: unknown): note is Note\n  validateWithErrors(note: unknown): { valid: boolean; errors: string[] }\n}\n```\n\n**Current validations embedded:**\n- Core fields: id, createdAt, updatedAt, content, metadata\n- Optional title (string if present)\n- Optional tags (array of strings)\n- Optional daily { date: string }\n- Optional meeting { date, dailyNoteId, attendees[] }\n\n**Benefits:**\n- Validation rules documented in one place\n- Easier to add new note types with custom validation\n- Better error reporting for debugging corrupt notes\n- Validation testable without full vault setup","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:00:49.981406-06:00","updated_at":"2025-12-12T22:45:46.56177-06:00","closed_at":"2025-12-12T22:45:46.56177-06:00","dependencies":[{"issue_id":"scribe-1rf","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:00:53.428347-06:00","created_by":"daemon"}]}
{"id":"scribe-1sh","title":"Extract App.tsx state and effects into custom hooks","description":"The App.tsx component in apps/desktop/renderer/src/App.tsx is ~635 lines with 20+ useState calls and complex state interdependencies. This makes the component hard to reason about and test.\n\n## Analysis\n\n### State Variables (20+ useState calls, lines 33-52)\n**UI State:**\n- isPaletteOpen, paletteMode (command palette)\n- backlinkResults, showBacklinks (backlinks panel)\n- sidebarOpen, contextPanelOpen (panel visibility)\n- sidebarWidth, contextPanelWidth (panel dimensions)\n- globalError (error display)\n\n**Data State:**\n- historyEntries (navigation history with titles)\n- promptPlaceholder + promptResolverRef (prompt input modal)\n\n**Already Extracted:**\n- noteState (useNoteState hook)\n- navigation (useNavigationHistory hook)\n- theme (useTheme hook)\n- toasts (useToast hook)\n- scroll (useScrollHeader hook)\n\n### Effects and Callbacks\n- Command registration effect (~140 lines, lines 138-279)\n- Keyboard shortcut handler (~60 lines, lines 281-342)\n- handleCommandSelect (~30 lines, lines 345-375)\n- History entries fetching (~25 lines, lines 396-424)\n- Various click/navigation handlers\n\n## Proposed Solution\n\n### 1. useCommandPalette.ts\nExtract command palette state and logic:\n```typescript\nconst {\n  isOpen,\n  mode,\n  promptPlaceholder,\n  open,\n  close,\n  setMode,\n  promptInput,\n  resolvePrompt,\n} = useCommandPalette();\n```\nState: isPaletteOpen, paletteMode, promptPlaceholder, promptResolverRef\n\n### 2. useBacklinks.ts\nExtract backlinks panel state:\n```typescript\nconst {\n  results,\n  isVisible,\n  show,\n  hide,\n  fetchForNote,\n} = useBacklinks();\n```\nState: backlinkResults, showBacklinks\n\n### 3. usePanelState.ts\nExtract side panel state (generic for sidebar and context panel):\n```typescript\nconst sidebar = usePanelState(SIDEBAR_DEFAULT_WIDTH);\nconst contextPanel = usePanelState(CONTEXT_PANEL_DEFAULT_WIDTH);\n// Returns: { isOpen, width, toggle, setWidth }\n```\n\n### 4. useHistoryEntries.ts (or merge into useNavigationHistory)\nExtract history entries with titles fetching:\n```typescript\nconst historyEntries = useHistoryEntries(historyStack, sidebarOpen);\n```\n\n### 5. useAppCommands.ts\nExtract command registration into a hook that returns void but registers commands on mount:\n```typescript\nuseAppCommands({\n  createNote: noteState.createNote,\n  setPaletteMode,\n  resolvedTheme,\n  setTheme,\n  // ... other dependencies\n});\n```\n\n### 6. useAppKeyboardShortcuts.ts\nExtract keyboard shortcut handling:\n```typescript\nuseAppKeyboardShortcuts({\n  isPaletteOpen,\n  setPaletteMode,\n  openPalette,\n  createNote,\n  canGoBack,\n  canGoForward,\n  navigateBack,\n  navigateForward,\n  toggleSidebar,\n  toggleContextPanel,\n});\n```\n\n### Result\nApp.tsx becomes primarily:\n- Hook composition (~50 lines)\n- JSX layout (~150 lines)\n- Total: ~200-250 lines\n\nEach hook is independently testable and has clear responsibility boundaries.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:00:29.554154-06:00","updated_at":"2025-12-12T21:59:14.754693-06:00","closed_at":"2025-12-12T21:59:14.754693-06:00","dependencies":[{"issue_id":"scribe-1sh","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:00:32.804009-06:00","created_by":"daemon"}]}
{"id":"scribe-22l","title":"Extract shared traverseNodes() utility from engine packages","description":"The traverseNodes() function for walking Lexical AST trees is duplicated in 3 files:\n- packages/engine-core/src/metadata.ts (lines 170-178)\n- packages/engine-core/src/task-extraction.ts (lines 134-142 as traverseForText, 95-107 as traverseForTasks)  \n- packages/engine-search/src/text-extraction.ts (lines 83-91)\n- apps/desktop/electron/main/src/main.ts (lines 1047-1054)\n\nAll implementations are nearly identical: iterate nodes, call callback, recurse on children.\n\n**Suggested fix**: Create a shared @scribe/shared or @scribe/engine-core/ast-utils module exporting:\n- traverseNodes(nodes, callback) - basic traversal\n- traverseNodesWithAncestors(nodes, callback) - traversal with parent context (for task-extraction)\n- findNodeByKey(nodes, key) - key-based lookup\n- extractTextFromNode(node) - text extraction helper\n\nEstimate: ~1 hour","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:00:11.92009-06:00","updated_at":"2025-12-13T00:23:01.777216-06:00","closed_at":"2025-12-13T00:23:01.777216-06:00","dependencies":[{"issue_id":"scribe-22l","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:00:15.843528-06:00","created_by":"daemon"}]}
{"id":"scribe-2wh","title":"Create window.scribe type declaration for tests","description":"Test files extensively mock `window.scribe` API but use 'any' types throughout:\n\n**Pattern in 80+ test locations:**\n```typescript\n(window as any).scribe = {\n  notes: { list: vi.fn(), ... },\n  search: { query: vi.fn(), ... },\n  // etc\n}\n```\n\n**Solution:**\nCreate a proper type declaration:\n\n1. Create `apps/desktop/renderer/src/types/scribe.d.ts`:\n```typescript\ninterface ScribeAPI {\n  notes: {\n    list(): Promise\u003cNote[]\u003e;\n    read(id: NoteId): Promise\u003cNote\u003e;\n    create(note: Partial\u003cNote\u003e): Promise\u003cNote\u003e;\n    save(note: Note): Promise\u003cvoid\u003e;\n    delete(id: NoteId): Promise\u003cvoid\u003e;\n    // ... other methods\n  };\n  search: {\n    query(text: string): Promise\u003cSearchResult[]\u003e;\n  };\n  // ... other namespaces\n}\n\ndeclare global {\n  interface Window {\n    scribe: ScribeAPI;\n  }\n}\n```\n\n2. Update tests to use typed mocks:\n```typescript\nwindow.scribe = {\n  notes: { list: vi.fn\u003c[], Promise\u003cNote[]\u003e\u003e(), ... },\n};\n```\n\n**Impact:** Eliminates ~80 'any' usages in tests, improves test type safety","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:26:38.510129-06:00","updated_at":"2025-12-13T01:25:49.05249-06:00","closed_at":"2025-12-13T01:25:49.05249-06:00","dependencies":[{"issue_id":"scribe-2wh","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:26:45.414327-06:00","created_by":"daemon"}]}
{"id":"scribe-2xy","title":"Deduplicate fadeIn keyframe in design-system","description":"The fadeIn keyframe animation is defined twice in the design system:\n\n1. packages/design-system/src/tokens/animations.css.ts (lines 12-15):\n```typescript\nexport const fadeIn = keyframes({\n  '0%': { opacity: 0 },\n  '100%': { opacity: 1 },\n});\n```\n\n2. packages/design-system/src/primitives/Overlay/Overlay.css.ts (lines 4-7):\n```typescript\nconst fadeIn = keyframes({\n  from: { opacity: 0 },\n  to: { opacity: 1 },\n});\n```\n\nBoth are semantically identical (0%/100% vs from/to).\n\n**Suggested fix**: \n1. Remove the local fadeIn definition in Overlay.css.ts\n2. Import from the shared animations tokens:\n   `import { fadeIn } from '../../tokens/animations.css';`\n\nThis is a small change but establishes the pattern that animation keyframes should come from the token layer.\n\nEstimate: ~15 minutes","status":"closed","priority":4,"issue_type":"task","created_at":"2025-12-12T21:01:05.045138-06:00","updated_at":"2025-12-13T01:17:38.15908-06:00","closed_at":"2025-12-13T01:17:38.15908-06:00","dependencies":[{"issue_id":"scribe-2xy","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:01:08.117838-06:00","created_by":"daemon"}]}
{"id":"scribe-397","title":"Document hash algorithm in task-extraction.ts","description":"The hash algorithm in task-extraction.ts has minimal documentation.\n\n**computeTextHash (lines 148-158):**\n```typescript\nexport function computeTextHash(text: string): string {\n  // Simple hash implementation based on DJB2 algorithm\n  let hash = 5381;\n  for (let i = 0; i \u003c text.length; i++) {\n    hash = (hash * 33) ^ text.charCodeAt(i);\n  }\n  // Convert to hex and pad/truncate to 16 chars\n  const hexHash = Math.abs(hash).toString(16).padStart(16, '0');\n  return hexHash.slice(0, 16);\n}\n```\n\n**Missing documentation:**\n- Why DJB2 was chosen over other algorithms\n- Collision probability analysis\n- Why 16 characters was chosen\n- Warning about non-cryptographic nature\n- Performance characteristics\n\n**getNodeKey (lines 164-172):**\n- Fallback key generation uses Math.random()\n- When fallback is triggered\n- Consequences of random key generation\n\n**Files:**\n- packages/engine-core/src/task-extraction.ts","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:20:19.15432-06:00","updated_at":"2025-12-13T00:33:05.035928-06:00","closed_at":"2025-12-13T00:33:05.035928-06:00","dependencies":[{"issue_id":"scribe-397","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:20:26.460289-06:00","created_by":"daemon"}]}
{"id":"scribe-3hh","title":"Add circular reference tests for GraphEngine","description":"Add tests for circular link handling in graph-engine.test.ts:\n- A links to B, B links to A (simple bidirectional)\n- A -\u003e B -\u003e C -\u003e A (cycle of 3)\n- Longer cycles (A -\u003e B -\u003e C -\u003e D -\u003e A)\n- neighbors() with circular refs (no infinite loop, no duplicates)\n- backlinks() with circular refs\n- Verify edge counts are correct with cycles\n- removeNote() properly cleans up circular references\n\nCurrent tests have one bidirectional test but don't cover true cycles.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:01:08.059983-06:00","updated_at":"2025-12-13T00:34:52.193887-06:00","closed_at":"2025-12-13T00:34:52.193887-06:00","dependencies":[{"issue_id":"scribe-3hh","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:01:11.010536-06:00","created_by":"daemon"}]}
{"id":"scribe-3iq","title":"Add tests for FocusNodePlugin","description":"FocusNodePlugin.tsx (218 lines) has NO tests.\n\n**Functions needing tests:**\n- Node focus/scroll behavior\n- Task focus handling\n- Section focus handling\n- Integration with Lexical editor\n\n**Files:**\n- apps/desktop/renderer/src/components/Editor/plugins/FocusNodePlugin.tsx","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:27:13.524717-06:00","updated_at":"2025-12-13T01:27:00.893627-06:00","closed_at":"2025-12-13T01:27:00.893627-06:00","dependencies":[{"issue_id":"scribe-3iq","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:27:20.878639-06:00","created_by":"daemon"}]}
{"id":"scribe-3ix","title":"Extract inline style objects to CSS/design tokens in widget components","description":"TasksWidget.tsx:42, AttendeesWidget.tsx:44, and ReferencesWidget.tsx:124 create new style objects on every render (e.g., style={{ color: '#22c55e' }}). This causes unnecessary object allocations and re-renders. Additionally, these use hardcoded hex colors (#22c55e, #10b981, #8b5cf6) instead of design tokens. Fix: Move styles to CSS classes using design system color tokens.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:00:50.032793-06:00","updated_at":"2025-12-12T22:45:47.314936-06:00","closed_at":"2025-12-12T22:45:47.314936-06:00","dependencies":[{"issue_id":"scribe-3ix","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:00:53.361114-06:00","created_by":"daemon"},{"issue_id":"scribe-3ix","depends_on_id":"scribe-99n","type":"related","created_at":"2025-12-12T21:42:11.451441-06:00","created_by":"daemon"}]}
{"id":"scribe-3px","title":"Extract TaskIndex.indexNote() reconciliation logic into helper functions","description":"The indexNote() method in packages/engine-core/src/task-index.ts (lines 162-258) is ~97 lines of dense reconciliation logic that handles multiple responsibilities.\n\n## Analysis\n\nThe method performs these distinct operations:\n1. **Task extraction** (line 167-171): Calls extractTasksFromNote()\n2. **Index snapshot** (lines 173-188): Creates lookup maps for existing tasks by nodeKey and textHash\n3. **Matching tracking** (lines 190-197): Setup for tracking matched/new tasks\n4. **Reconciliation loop** (lines 199-235): Main loop that:\n   - Finds existing tasks by nodeKey or textHash fallback\n   - Either updates existing or creates new tasks\n   - Manages byNote index updates\n5. **Orphan removal** (lines 237-249): Removes tasks no longer in note\n6. **Persistence trigger** (lines 251-257): Marks dirty and schedules persist\n\n### Complexity Issues\n- The method is doing 6 distinct things in sequence\n- The reconciliation loop has nested conditionals for match finding\n- Index management (byNote) is interleaved with business logic\n- Hard to unit test individual reconciliation rules\n\n## Proposed Solution\n\nExtract into focused helper functions:\n\n### 1. buildExistingTaskMaps()\n```typescript\nfunction buildExistingTaskMaps(tasks: Map\u003cstring, Task\u003e, taskIds: Set\u003cstring\u003e): {\n  byNodeKey: Map\u003cstring, Task\u003e;\n  byTextHash: Map\u003cstring, Task\u003e;\n}\n```\nExtracts lines 177-188.\n\n### 2. findMatchingTask()\n```typescript\nfunction findMatchingTask(\n  ext: ExtractedTask,\n  byNodeKey: Map\u003cstring, Task\u003e,\n  byTextHash: Map\u003cstring, Task\u003e\n): Task | undefined\n```\nExtracts the matching logic from lines 201-207.\n\n### 3. processExtractedTasks()\n```typescript\nfunction processExtractedTasks(\n  extracted: ExtractedTask[],\n  existingMaps: { byNodeKey; byTextHash },\n  maxPriority: number,\n  now: number\n): {\n  toUpdate: Task[];\n  toAdd: Task[];\n  matchedIds: Set\u003cstring\u003e;\n}\n```\nExtracts lines 199-235 into a pure function that returns what to do.\n\n### 4. findOrphanedTaskIds()\n```typescript\nfunction findOrphanedTaskIds(\n  existingIds: Set\u003cstring\u003e,\n  matchedIds: Set\u003cstring\u003e\n): string[]\n```\nSimple set difference, extracts the logic from lines 239-249.\n\n### Refactored indexNote()\n```typescript\nindexNote(note: Note): TaskChangeEvent[] {\n  const changes: TaskChangeEvent[] = [];\n  const now = Date.now();\n  \n  const extracted = extractTasksFromNote(note);\n  const existingIds = new Set(this.byNote.get(note.id) ?? []);\n  const existingMaps = buildExistingTaskMaps(this.tasks, existingIds);\n  \n  const { toUpdate, toAdd, matchedIds } = processExtractedTasks(\n    extracted,\n    existingMaps,\n    this.getMaxPriority(),\n    now\n  );\n  \n  // Apply updates\n  for (const task of toUpdate) {\n    this.tasks.set(task.id, task);\n    changes.push({ type: 'updated', task });\n  }\n  \n  // Apply additions\n  for (const task of toAdd) {\n    this.addTaskToIndex(task);\n    changes.push({ type: 'added', task });\n  }\n  \n  // Remove orphans\n  for (const taskId of findOrphanedTaskIds(existingIds, matchedIds)) {\n    this.removeTaskFromIndex(taskId, note.id);\n    changes.push({ type: 'removed', taskId });\n  }\n  \n  if (changes.length \u003e 0) {\n    this.dirty = true;\n    this.schedulePersist();\n  }\n  \n  return changes;\n}\n```\n\nBenefits:\n- Each helper is pure and easily unit testable\n- Reconciliation rules are explicit and documented\n- Main method is readable at a high level (~30 lines)\n- Index management is isolated in addTaskToIndex/removeTaskFromIndex","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:00:53.323898-06:00","updated_at":"2025-12-12T23:14:11.04001-06:00","closed_at":"2025-12-12T23:14:11.04001-06:00","dependencies":[{"issue_id":"scribe-3px","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:00:56.517999-06:00","created_by":"daemon"}]}
{"id":"scribe-3r5","title":"Fix memory leak: setInterval not cleared in auto-updater.ts","description":"In auto-updater.ts lines 70-74, setInterval() creates a periodic update check but the interval ID is never stored or cleared. If setupAutoUpdater() is called multiple times (e.g., window recreation, hot reload), intervals accumulate causing: 1) Multiple concurrent update checks, 2) Memory leak from retained closures, 3) Potential race conditions. Fix: Store interval ID at module level, clear existing interval before creating new one, and/or add cleanup function.","acceptance_criteria":"- Interval ID stored at module level\n- clearInterval() called before creating new interval\n- Add cleanup function exported for testing\n- Unit test verifies only one interval active after multiple setupAutoUpdater() calls","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-12T21:01:05.066027-06:00","updated_at":"2025-12-12T21:52:35.492997-06:00","closed_at":"2025-12-12T21:52:35.492997-06:00","dependencies":[{"issue_id":"scribe-3r5","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:01:07.905344-06:00","created_by":"daemon"}]}
{"id":"scribe-4pv","title":"Fix any type usage in TaskItem drag-and-drop","description":"TaskItem.tsx uses 'any' type for drag-and-drop attributes:\n\n**Location:** apps/desktop/renderer/src/components/Tasks/TaskItem.tsx\n\n**Code (lines 54-57):**\n```typescript\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nattributes: any;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nlisteners: any;\n```\n\n**Root Cause:**\nThe @dnd-kit library types are not being used properly.\n\n**Solution:**\nImport proper types from @dnd-kit/core:\n```typescript\nimport { DraggableAttributes } from '@dnd-kit/core';\nimport { SyntheticListenerMap } from '@dnd-kit/core/dist/hooks/utilities';\n\ninterface TaskItemProps {\n  attributes: DraggableAttributes;\n  listeners: SyntheticListenerMap | undefined;\n  // ...\n}\n```\n\n**Impact:** Removes eslint-disable comments, improves type safety","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:26:22.466077-06:00","updated_at":"2025-12-12T23:46:29.221218-06:00","closed_at":"2025-12-12T23:46:29.221218-06:00","dependencies":[{"issue_id":"scribe-4pv","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:26:45.312276-06:00","created_by":"daemon"}]}
{"id":"scribe-52x","title":"Add tests for Sidebar component","description":"Sidebar.tsx (161 lines) and related components have NO tests.\n\n**Files needing tests:**\n- apps/desktop/renderer/src/components/Sidebar/Sidebar.tsx (161 lines)\n- apps/desktop/renderer/src/components/Sidebar/HistoryListItem.tsx\n\n**Test scenarios:**\n- Sidebar open/close toggle\n- History list rendering\n- Note selection from history\n- Resize handle behavior\n- Empty state rendering\n\n**Files:**\n- apps/desktop/renderer/src/components/Sidebar/*","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:27:24.299984-06:00","updated_at":"2025-12-13T01:29:26.500977-06:00","closed_at":"2025-12-13T01:29:26.500977-06:00","dependencies":[{"issue_id":"scribe-52x","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:27:33.272302-06:00","created_by":"daemon"}]}
{"id":"scribe-5es","title":"Create useErrorHandler hook for consistent error handling","description":"Error handling is inconsistent across 24+ locations with repeated pattern:\n```typescript\nconsole.error('Failed to \u003caction\u003e:', error);\n```\n\n**Files with repeated pattern:**\n- TasksWidget.tsx (4 occurrences)\n- TasksScreen.tsx (4 occurrences)\n- CommandPalette.tsx (3 occurrences)\n- ContextPanel.tsx (2 occurrences)\n- PersonMentionAutocomplete.tsx, PersonMentionPlugin.tsx, AttendeesWidget.tsx, etc.\n\n**Issues:**\n1. No centralized error handling\n2. Inconsistent error message formatting\n3. ScribeError.getUserMessage() exists but isn't used in UI\n4. Errors only logged to console - no user feedback\n\n**Solution:**\nCreate `useErrorHandler` hook:\n```typescript\nfunction useErrorHandler() {\n  const { showToast } = useToast();\n  \n  return useCallback((error: unknown, context?: string) =\u003e {\n    const message = error instanceof ScribeError \n      ? error.getUserMessage()\n      : 'An unexpected error occurred';\n    \n    console.error(context ? `${context}:` : 'Error:', error);\n    showToast({ message, type: 'error' });\n  }, [showToast]);\n}\n```\n\n**Files:**\n- New: apps/desktop/renderer/src/hooks/useErrorHandler.ts\n- Update: All files with console.error patterns","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:25:45.260291-06:00","updated_at":"2025-12-12T21:59:15.149346-06:00","closed_at":"2025-12-12T21:59:15.149346-06:00","dependencies":[{"issue_id":"scribe-5es","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:26:45.013691-06:00","created_by":"daemon"}]}
{"id":"scribe-5lp","title":"Refactor CommandPalette props drilling with React context or composition","description":"App.tsx passes 15+ props to CommandPalette (lines 518-564) including method callbacks like onCommandSelect, onSearchResultSelect, onNoteSelect, onModeChange, showToast, noteState object with 5 methods, onPromptSubmit, onPromptCancel. This creates tight coupling and makes the component harder to maintain. Consider: 1) CommandPaletteContext for shared state/callbacks, 2) Composition pattern with specialized sub-components, 3) Custom hooks for related functionality.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:00:57.257181-06:00","updated_at":"2025-12-12T23:14:12.670145-06:00","closed_at":"2025-12-12T23:14:12.670145-06:00","dependencies":[{"issue_id":"scribe-5lp","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:01:00.673922-06:00","created_by":"daemon"},{"issue_id":"scribe-5lp","depends_on_id":"scribe-1sh","type":"blocks","created_at":"2025-12-12T21:42:09.614506-06:00","created_by":"daemon"}]}
{"id":"scribe-5na","title":"Add tests for main.ts IPC handlers","description":"CRITICAL: apps/desktop/electron/main/src/main.ts (1216 lines) has NO tests. This file contains ALL IPC handlers for the application.\n\n**Missing Test Coverage:**\n- notes:* handlers (CRUD, findByDate, findByTitle)\n- search:* handlers\n- graph:* handlers  \n- tasks:* handlers (toggle, list, update)\n- people:* handlers\n- daily/meeting note creation handlers\n- Helper functions: toggleChecklistNode, createPersonContent, etc.\n\n**Priority:** This is the most critical test coverage gap - all data operations flow through these handlers.\n\n**Recommendation:** \n1. Extract IPC handlers into separate testable modules (see scribe-930)\n2. Add integration tests for each handler category\n3. Add unit tests for helper functions\n\n**Files:**\n- apps/desktop/electron/main/src/main.ts","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-12T21:19:02.613563-06:00","updated_at":"2025-12-12T22:11:59.247223-06:00","closed_at":"2025-12-12T22:11:59.247223-06:00","dependencies":[{"issue_id":"scribe-5na","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:20:24.60974-06:00","created_by":"daemon"},{"issue_id":"scribe-5na","depends_on_id":"scribe-930","type":"blocks","created_at":"2025-12-12T21:41:45.555226-06:00","created_by":"daemon"}]}
{"id":"scribe-5v4","title":"Replace console.log with proper logging in main.ts","description":"main.ts (1215 lines) has 12 console.log statements that should be replaced with a proper logging system:\n\n**Startup diagnostics (lines 66-103):**\n- 'Vault initialized at:', vaultPath\n- 'Loaded ${noteCount} notes from vault'\n- 'Graph initialized with ${notes.length} notes'\n- 'Search index initialized with ${searchEngine.size()} notes'\n- 'Task index initialized with ${taskIndex.size} tasks'\n- 'Graph stats: ${stats.nodes} nodes, ${stats.edges} edges, ${stats.tags} tags'\n- 'Task index flushed successfully' (line 1210)\n\n**Debug logging (line 217 in App.tsx):**\n- 'Backlinks for current note:', backlinks\n\n**Solution:**\n1. Create a Logger class with log levels (debug, info, warn, error)\n2. Use DEBUG/INFO for startup diagnostics\n3. Disable debug logs in production builds\n4. Consider writing logs to file for debugging production issues\n\n**Files:**\n- apps/desktop/electron/main/src/main.ts\n- apps/desktop/renderer/src/App.tsx","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:25:29.826795-06:00","updated_at":"2025-12-12T23:36:33.822569-06:00","closed_at":"2025-12-12T23:36:33.822569-06:00","dependencies":[{"issue_id":"scribe-5v4","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:26:44.912439-06:00","created_by":"daemon"},{"issue_id":"scribe-5v4","depends_on_id":"scribe-5es","type":"related","created_at":"2025-12-12T21:42:05.318567-06:00","created_by":"daemon"}]}
{"id":"scribe-69x","title":"Add emptyState primitive to design system","description":"The `emptyState` style is duplicated 9 times across the codebase:\n\n**Files with duplicate emptyState:**\n1. ContextPanel.css.ts (line 292)\n2. ReferencesWidget.css.ts (line 100)\n3. AttendeesWidget.css.ts (line 257)\n4. Sidebar.css.ts (line 146)\n5. DraggableTaskList.css.ts (line 22)\n6. WikiLinkAutocomplete.css.ts (line 94)\n7. PersonMentionAutocomplete.css.ts (line 98)\n8. SlashMenu.css.ts (line 82)\n9. TasksScreen.css.ts (line 73)\n\n**Common Pattern:**\n```typescript\nexport const emptyState = style({\n  fontSize: vars.typography.size.sm,\n  color: vars.color.foregroundMuted,\n  padding: vars.spacing['2'] || vars.spacing['4'],\n  textAlign: 'center',\n  fontStyle: 'italic', // in some cases\n});\n```\n\n**Solution:**\nAdd to design system primitives:\n```typescript\n// packages/design-system/src/primitives/States/\nexport const emptyState = style({ ... });\nexport const loadingState = style({ ... });\n```\n\n**Estimated savings:** ~45 lines","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:18:53.296415-06:00","updated_at":"2025-12-13T01:30:02.74249-06:00","closed_at":"2025-12-13T01:30:02.74249-06:00","dependencies":[{"issue_id":"scribe-69x","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:20:26.945071-06:00","created_by":"daemon"}]}
{"id":"scribe-6my","title":"Extract useAutocompletePlugin hook from WikiLinkPlugin and PersonMentionPlugin","description":"~300 lines of autocomplete plugin logic are duplicated between:\n- apps/desktop/renderer/src/components/Editor/plugins/WikiLinkPlugin.tsx (424 lines)\n- apps/desktop/renderer/src/components/Editor/plugins/PersonMentionPlugin.tsx (427 lines)\n\nBoth plugins share identical patterns for:\n1. Trigger state management (isActive, startOffset, anchorKey, query) \n2. Autocomplete state (isOpen, query, results, selectedIndex, position, isLoading)\n3. Debounced search with timeout refs\n4. Cursor position calculation from DOM selection\n5. Keyboard navigation (ArrowUp/Down, Enter/Tab, Escape)\n6. Lexical update listener for trigger detection\n7. Command registration for insertion\n8. Portal rendering of autocomplete dropdown\n\n**Suggested fix**: Create a useAutocompletePlugin hook that abstracts:\n- Trigger character detection (configurable: '[[' vs '@')\n- State management for trigger and autocomplete\n- Keyboard navigation handlers\n- Position calculation\n- Debounced search integration\n\nEach plugin would then only define:\n- Trigger pattern\n- Search function\n- Node creation logic\n- Custom autocomplete UI component\n\nEstimate: ~3 hours","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:00:26.020958-06:00","updated_at":"2025-12-13T00:20:55.788351-06:00","closed_at":"2025-12-13T00:20:55.788351-06:00","dependencies":[{"issue_id":"scribe-6my","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:00:29.038723-06:00","created_by":"daemon"},{"issue_id":"scribe-6my","depends_on_id":"scribe-9cl","type":"blocks","created_at":"2025-12-12T21:42:03.534113-06:00","created_by":"daemon"}]}
{"id":"scribe-6tq","title":"Extract magic numbers to constants in engine-core and engine-search packages","description":"Extract hardcoded magic numbers to named constants for better maintainability:\n\n**engine-core/src/metadata.ts:49**\n- `slice(0, 200)` - MAX_TITLE_LENGTH for title truncation\n\n**engine-core/src/task-extraction.ts:151-157**\n- `5381` - DJB2_HASH_INITIAL (DJB2 hash algorithm initial value)\n- `33` - DJB2_HASH_MULTIPLIER\n- `16` - TEXT_HASH_LENGTH (hex characters for hash)\n\n**engine-search/src/search-engine.ts**\n- Line 96: `1000` - MAX_INDEXED_CONTENT_LENGTH\n- Line 239, 252: `160` - SNIPPET_MAX_LENGTH\n- Line 248: `80` - SNIPPET_CONTEXT_RADIUS\n- Lines 221-225: Field weights (10, 5, 1) - SEARCH_WEIGHT_TITLE, SEARCH_WEIGHT_TAGS, SEARCH_WEIGHT_CONTENT\n\nConsider creating a constants.ts file in each package or a shared config.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:00:16.874344-06:00","updated_at":"2025-12-13T00:22:21.919178-06:00","closed_at":"2025-12-13T00:22:21.919178-06:00","dependencies":[{"issue_id":"scribe-6tq","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:00:20.838992-06:00","created_by":"daemon"}]}
{"id":"scribe-6vz","title":"Add tests for packages/shared utility functions","description":"packages/shared/src/ has NO tests despite containing utility functions used throughout the codebase.\n\n**Files needing tests:**\n\n**types.ts (functions):**\n- serializeTaskId(noteId, nodeKey) - serializes task identifiers\n- parseTaskId(taskId) - parses task ID back to components\n- isSystemNoteId(id) - checks for system note IDs\n\n**errors.ts (104 lines):**\n- ScribeError class methods\n- getUserMessage() - user-friendly error messages\n- fromSystemError() - converts system errors to ScribeError\n- Error code mapping for ENOENT, EACCES, ENOSPC, etc.\n\n**Impact:** These utilities are used across all packages and the desktop app.\n\n**Files:**\n- packages/shared/src/types.ts\n- packages/shared/src/errors.ts","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:19:12.446752-06:00","updated_at":"2025-12-12T23:25:37.363021-06:00","closed_at":"2025-12-12T23:25:37.363021-06:00","dependencies":[{"issue_id":"scribe-6vz","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:20:25.021332-06:00","created_by":"daemon"}]}
{"id":"scribe-782","title":"Add tests for useTaskSubscription hook","description":"apps/desktop/renderer/src/hooks/useTaskSubscription.ts (120 lines) has NO tests.\n\n**What needs testing:**\n- Task change event subscription\n- Event batching behavior\n- Cleanup on unmount\n- Filtering by note ID\n- Debouncing behavior\n\n**Files:**\n- apps/desktop/renderer/src/hooks/useTaskSubscription.ts","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:19:18.214183-06:00","updated_at":"2025-12-13T01:14:54.792285-06:00","closed_at":"2025-12-13T01:14:54.792285-06:00","dependencies":[{"issue_id":"scribe-782","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:20:26.892663-06:00","created_by":"daemon"}]}
{"id":"scribe-7id","title":"Extract shared widget card styles in ContextPanel components","description":"Context panel widget components have duplicated card styles (~60 lines duplicated):\n\n**Duplicated Files:**\n- ContextPanel.css.ts (lines 82-134)\n- ReferencesWidget.css.ts (lines 14-45)\n- AttendeesWidget.css.ts (lines 14-46)\n\n**Duplicated Patterns:**\n- `card` style (backgroundColor, borderRadius, padding, marginBottom, boxShadow, border, transition)\n- `cardHeader` style (display: flex, alignItems, gap, marginBottom, color, fontWeight)\n- `cardIcon` style (width, height, flexShrink)\n- `cardTitle` style (fontSize)\n\n**Solution:**\nExtract to shared styles:\n```typescript\n// ContextPanel/shared.css.ts\nexport const widgetCard = style({ ... });\nexport const widgetCardHeader = style({ ... });\n```\n\n**Estimated savings:** ~60 lines","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:18:32.700848-06:00","updated_at":"2025-12-13T01:35:04.381704-06:00","closed_at":"2025-12-13T01:35:04.381704-06:00","dependencies":[{"issue_id":"scribe-7id","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:20:27.101058-06:00","created_by":"daemon"}]}
{"id":"scribe-8c8","title":"quarantineFile() silently fails, leaving corrupt files in place","description":"In packages/storage-fs/src/storage.ts lines 77-79, quarantineFile() logs an error but continues silently if file move fails. Corrupt files remain in notes directory and will cause repeated parse failures on each startup. Should propagate error or retry with alternative strategy.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-12T20:59:57.995945-06:00","updated_at":"2025-12-12T22:12:02.080995-06:00","closed_at":"2025-12-12T22:12:02.080995-06:00","dependencies":[{"issue_id":"scribe-8c8","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:00:10.823603-06:00","created_by":"daemon"}]}
{"id":"scribe-8f8","title":"Fix any type usage in SearchEngine","description":"SearchEngine uses 'any' type assertions when working with MiniSearch results:\n\n**Location:** packages/engine-search/src/search-engine.ts\n\n**Code (lines 141, 149):**\n```typescript\n// Line 141\nresults as any[]\n\n// Line 149\n(item as any).doc as SearchDocument\n```\n\n**Root Cause:**\nMiniSearch's TypeScript types may not be properly parameterized.\n\n**Solution:**\n1. Configure MiniSearch with proper generic types:\n```typescript\nconst miniSearch = new MiniSearch\u003cSearchDocument\u003e({\n  // options\n});\n```\n\n2. Create proper type for search results:\n```typescript\ninterface MiniSearchResult {\n  id: string;\n  score: number;\n  match: Record\u003cstring, string[]\u003e;\n  doc?: SearchDocument;\n}\n```\n\n**Impact:** Removes type unsafety in search results handling","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:26:31.032684-06:00","updated_at":"2025-12-12T23:52:18.526432-06:00","closed_at":"2025-12-12T23:52:18.526432-06:00","dependencies":[{"issue_id":"scribe-8f8","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:26:45.363967-06:00","created_by":"daemon"}]}
{"id":"scribe-8fq","title":"Document IPC handler contracts in main.ts","description":"apps/desktop/electron/main/src/main.ts (1216 lines) contains all IPC handlers but they lack documentation.\n\n**Needs documentation:**\n\n**Handler Categories:**\n- notes:* (CRUD, findByDate, findByTitle) - parameter validation, return types, error codes\n- search:* - query syntax, result format\n- graph:* - node/edge semantics\n- tasks:* - toggle behavior, state transitions\n- people:* - auto-creation behavior\n- daily/meeting notes - creation rules, date handling\n\n**Helper Functions:**\n- toggleChecklistNode (lines 977-1026) - fallback chain algorithm, mutation semantics\n- createPersonContent - content structure\n- Date handling logic (lines 381-427) - format expectations, filtering rules\n\n**Business Logic:**\n- Title matching precedence (lines 359-378)\n- Daily note creation timing (noon timezone fix, lines 686-704)\n- Meeting note auto-creation (lines 740-771)\n\n**Files:**\n- apps/desktop/electron/main/src/main.ts","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:20:02.513951-06:00","updated_at":"2025-12-12T23:36:32.713206-06:00","closed_at":"2025-12-12T23:36:32.713206-06:00","dependencies":[{"issue_id":"scribe-8fq","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:20:24.858138-06:00","created_by":"daemon"},{"issue_id":"scribe-8fq","depends_on_id":"scribe-930","type":"blocks","created_at":"2025-12-12T21:42:18.118171-06:00","created_by":"daemon"}]}
{"id":"scribe-8xm","title":"Refactor FileSystemVault: Extract AtomicFileWriter for safe I/O","description":"FileSystemVault.atomicWrite() (lines 285-314) implements crash-safe file writing that could be reused across the codebase.\n\n**Extract: AtomicFileWriter**\n- Move atomicWrite() method (temp file → fsync → rename pattern)\n- Make reusable for any file type (not just notes)\n- Handle temp file cleanup on errors\n\n**Interface:**\n```typescript\ninterface AtomicFileWriter {\n  write(filePath: string, content: string): Promise\u003cvoid\u003e\n  writeJSON\u003cT\u003e(filePath: string, data: T): Promise\u003cvoid\u003e\n}\n```\n\n**Current implementation details:**\n- Creates .filename.tmp in same directory\n- Writes content to temp file\n- Opens file handle, calls sync()\n- Atomic rename to final path\n- Cleanup temp on error\n\n**Benefits:**\n- Reusable by TaskPersistence (also uses temp+rename)\n- Consistent crash-safety across all file writes\n- Single place to tune fsync behavior\n- Could add options for sync frequency","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:00:59.588403-06:00","updated_at":"2025-12-12T23:14:13.539718-06:00","closed_at":"2025-12-12T23:14:13.539718-06:00","dependencies":[{"issue_id":"scribe-8xm","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:01:02.816232-06:00","created_by":"daemon"},{"issue_id":"scribe-8xm","depends_on_id":"scribe-xub","type":"related","created_at":"2025-12-12T21:41:57.738506-06:00","created_by":"daemon"}]}
{"id":"scribe-930","title":"Refactor setupIPCHandlers() into domain-specific handler modules","description":"The setupIPCHandlers() function in apps/desktop/electron/main/src/main.ts is ~710 lines and handles 8+ distinct domains in a single monolithic function. This violates single responsibility and makes the main process hard to navigate.\n\n## Analysis\n\nThe function contains IPC handlers for these distinct domains:\n1. **Notes CRUD** (lines 246-458): list, read, create, save, delete, findByTitle, findByDate, searchTitles\n2. **Search** (lines 460-466): query handler\n3. **Graph** (lines 468-490): forNote, backlinks, notesWithTag handlers\n4. **People** (lines 492-558): list, create, search handlers\n5. **App/Config** (lines 560-603): openDevTools, getLastOpenedNote, setLastOpenedNote, getConfig, setConfig, shell:openExternal\n6. **Dictionary/Spellcheck** (lines 607-659): addWord, removeWord, getLanguages, setLanguages, getAvailableLanguages\n7. **Daily Notes** (lines 661-718): getOrCreate, find handlers\n8. **Meeting Notes** (lines 720-835): create, addAttendee, removeAttendee handlers\n9. **Tasks** (lines 837-949): toggle, list, get, reorder handlers\n\n## Proposed Solution\n\nExtract each domain into its own handler module under electron/main/src/handlers/:\n\n- notesHandlers.ts - Notes CRUD operations\n- searchHandlers.ts - Search operations\n- graphHandlers.ts - Graph traversal operations\n- peopleHandlers.ts - People management\n- appHandlers.ts - App config and shell operations\n- dictionaryHandlers.ts - Spellcheck dictionary management\n- dailyHandlers.ts - Daily note operations\n- meetingHandlers.ts - Meeting note operations\n- tasksHandlers.ts - Task operations\n\nEach handler module should:\n1. Export a setup function that receives dependencies (vault, graphEngine, searchEngine, taskIndex, mainWindow)\n2. Register its own IPC handlers\n3. Handle its own error wrapping\n\nThis reduces main.ts to ~100-150 lines of initialization and handler registration.","acceptance_criteria":"- Create handlers/ directory under electron/main/src/\n- Each domain module exports setup function taking (vault, graphEngine, searchEngine, taskIndex, mainWindow)\n- main.ts reduced to \u003c200 lines of initialization\n- All existing IPC channels still work (no breaking changes)\n- Each handler module has own error wrapping","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T20:59:44.950606-06:00","updated_at":"2025-12-12T21:59:13.438445-06:00","closed_at":"2025-12-12T21:59:13.438445-06:00","dependencies":[{"issue_id":"scribe-930","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T20:59:48.996334-06:00","created_by":"daemon"}]}
{"id":"scribe-95c","title":"Adopt useErrorHandler hook in existing components","description":"Follow-up to scribe-5es. Update components to use the new useErrorHandler hook instead of raw console.error calls.\n\n**Prerequisites:**\n- Toast context or showToast prop must be available in components\n- May depend on App.tsx refactoring (scribe-1sh) to establish patterns\n\n**Components to update (when showToast is available):**\n- TasksWidget.tsx (4 occurrences)\n- TasksScreen.tsx (4 occurrences)  \n- CommandPalette.tsx (3 occurrences)\n- ContextPanel.tsx (2 occurrences)\n- useNoteState.ts (6 occurrences)\n- PersonMentionAutocomplete.tsx, PersonMentionPlugin.tsx\n- WikiLinkNode.ts, PersonMentionNode.ts\n- LinkClickPlugin.tsx, InitialStatePlugin.tsx\n- AttendeesWidget.tsx\n- App.tsx (2 occurrences)\n- index.tsx (2 occurrences)\n- commands/people.ts\n\n**Pattern:**\n```typescript\n// Before\nconsole.error('Failed to load tasks:', error);\n\n// After\nhandleError(error, 'Failed to load tasks');\n```","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:57:08.593365-06:00","updated_at":"2025-12-13T01:35:06.204823-06:00","closed_at":"2025-12-13T01:35:06.204823-06:00","dependencies":[{"issue_id":"scribe-95c","depends_on_id":"scribe-5es","type":"discovered-from","created_at":"2025-12-12T21:57:08.593841-06:00","created_by":"daemon"}]}
{"id":"scribe-99n","title":"Migrate inline SVG icons to design system","description":"Multiple components define inline SVG icons instead of using the design system's Lucide icons:\n\n**Files with inline SVGs:**\n- TasksWidget.tsx: CheckCircleIcon\n- ReferencesWidget.tsx: ExternalLinkIcon, ReferenceIcon\n- AttendeesWidget.tsx: AttendeesIcon (Users icon)\n- LinkedMentions.tsx: FileTextIcon, LinkIcon, ChevronIcon\n- CalendarWidget.tsx: CalendarIcon, ClockIcon\n- TaskItem.tsx: CheckmarkIcon, GripIcon\n\n**Issues:**\n1. Duplicate icon definitions across files\n2. Inconsistent sizing/styling\n3. Design system already exports Lucide icons from @scribe/design-system\n\n**Solution:**\n1. Add missing icons to packages/design-system/src/icons/icons.tsx:\n   - ExternalLink, CheckCircle, Users, Clock, ChevronDown, ChevronUp, GripVertical\n2. Replace all inline SVG components with design system imports\n3. Create colored icon wrapper if needed for widget headers\n\n**Estimated savings:** ~100 lines of duplicate SVG code","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:25:37.247008-06:00","updated_at":"2025-12-12T23:46:26.295506-06:00","closed_at":"2025-12-12T23:46:26.295506-06:00","dependencies":[{"issue_id":"scribe-99n","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:26:44.963748-06:00","created_by":"daemon"}]}
{"id":"scribe-9cl","title":"Extract shared TriggerableAutocompletePlugin base from WikiLinkPlugin and PersonMentionPlugin","description":"WikiLinkPlugin.tsx (424 lines) and PersonMentionPlugin.tsx (427 lines) share nearly identical patterns:\n\n**Duplicated Code (~300 lines):**\n- TriggerState interface (identical in both)\n- Autocomplete state management (isOpen, query, position, selectedIndex, results, isLoading)\n- Insert command pattern (INSERT_WIKILINK_COMMAND vs INSERT_PERSON_MENTION_COMMAND)\n- Keyboard navigation logic (ArrowUp/ArrowDown/Enter/Tab handling)\n- Update listener registration with text detection\n- Escape key handling\n\n**Solution:**\nCreate an abstract `TriggerableAutocompletePlugin` base that handles:\n- Trigger detection pattern (customizable trigger char: `[[` vs `@`)\n- Autocomplete state management\n- Keyboard navigation\n- Escape handling\n\n**Files:**\n- apps/desktop/renderer/src/components/Editor/plugins/WikiLinkPlugin.tsx\n- apps/desktop/renderer/src/components/Editor/plugins/PersonMentionPlugin.tsx\n\n**Estimated savings:** ~300 lines of duplicated code","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:18:07.237611-06:00","updated_at":"2025-12-12T23:19:22.243229-06:00","closed_at":"2025-12-12T23:19:22.243229-06:00","dependencies":[{"issue_id":"scribe-9cl","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:20:25.247247-06:00","created_by":"daemon"}]}
{"id":"scribe-9jq","title":"Refactor TaskIndex: Extract TaskQuery for filtering/pagination","description":"TaskIndex.list() (lines 294-368) bundles filtering, sorting, and cursor pagination into one 74-line method.\n\n**Extract: TaskQuery**\n- Move list() filtering logic (lines 298-325)\n- Move sorting logic (lines 328-347)\n- Move cursor encode/decode (lines 571-586)\n- Move pagination slicing (lines 350-367)\n\n**Interface:**\n```typescript\ninterface TaskQuery {\n  execute(\n    tasks: Iterable\u003cTask\u003e,\n    filter?: TaskFilter\n  ): { tasks: Task[]; nextCursor?: string }\n}\n```\n\n**Current filters embedded in method:**\n- completed (boolean)\n- noteId (string)\n- createdAfter/createdBefore (number)\n- completedAfter/completedBefore (number)\n- sortBy: 'priority' | 'createdAt'\n- sortOrder: 'asc' | 'desc'\n- cursor-based pagination\n\n**Benefits:**\n- Query logic reusable across different indexes\n- Cursor encoding strategy swappable\n- Filter composition becomes easier to extend","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:00:41.702488-06:00","updated_at":"2025-12-12T23:25:35.213319-06:00","closed_at":"2025-12-12T23:25:35.213319-06:00","dependencies":[{"issue_id":"scribe-9jq","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:00:45.074193-06:00","created_by":"daemon"},{"issue_id":"scribe-9jq","depends_on_id":"scribe-3px","type":"blocks","created_at":"2025-12-12T21:41:54.795116-06:00","created_by":"daemon"}]}
{"id":"scribe-9nb","title":"Extract magic strings and values in storage-fs and desktop app","description":"Extract hardcoded magic strings and values to named constants:\n\n**storage-fs/src/storage.ts**\n- Lines 183, 229, 426: `'Untitled'` repeated 3 times - DEFAULT_NOTE_TITLE\n- Consider exporting from @scribe/shared for consistency across packages\n\n**desktop/electron/main/src/main.ts:1086-1087**\n- `1200` - DEFAULT_WINDOW_WIDTH\n- `800` - DEFAULT_WINDOW_HEIGHT\n- Line 1089: `{ x: 16, y: 16 }` - TRAFFIC_LIGHT_POSITION\n\nThese should be moved to a config/constants file for easy adjustment and documentation.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:00:27.613762-06:00","updated_at":"2025-12-13T00:22:39.010307-06:00","closed_at":"2025-12-13T00:22:39.010307-06:00","dependencies":[{"issue_id":"scribe-9nb","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:00:30.651525-06:00","created_by":"daemon"}]}
{"id":"scribe-9st","title":"Introduce branded types for NoteId and VaultPath","description":"**Problem**: `NoteId = string` and `VaultPath = string` (types.ts:11,16) provide no compile-time safety. A NoteId can be accidentally passed where a VaultPath is expected and vice versa.\n\n**Solution**: Use branded/opaque types:\n```typescript\ntype NoteId = string \u0026 { __brand: 'NoteId' };\ntype VaultPath = string \u0026 { __brand: 'VaultPath' };\n\n// Factory functions\nfunction noteId(id: string): NoteId { return id as NoteId; }\nfunction vaultPath(path: string): VaultPath { return path as VaultPath; }\n```\n\n**Files**: packages/shared/src/types.ts\n**Impact**: Prevents bugs from type confusion at compile time","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:00:24.456954-06:00","updated_at":"2025-12-12T22:40:03.421626-06:00","closed_at":"2025-12-12T22:40:03.421626-06:00","dependencies":[{"issue_id":"scribe-9st","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:00:27.602594-06:00","created_by":"daemon"}]}
{"id":"scribe-9uc","title":"Bundle vault-eval CLI with Scribe desktop app","description":"Package the vault-eval CLI binary with the Electron app so it's available for LLM/MCP integrations.\n\n## Why Bundle vault-eval?\n\nThe vault-eval CLI provides LLM-friendly commands for querying Scribe vaults. Bundling it with the desktop app enables:\n- MCP server integration (Model Context Protocol)\n- External LLM agents to query vault content\n- Automation and scripting workflows\n\n## Architecture\n\n```\nScribe.app/\n  Contents/\n    Resources/\n      bin/\n        vault-eval          # Platform-specific binary\n      app.asar              # Electron app\n```\n\nThe binary is placed in `Resources/bin/` via electron-builder's `extraResources` mechanism.\n\n## Platform Matrix\n\n| Platform | Bun Target | Binary Name |\n|----------|-----------|-------------|\n| macOS arm64 | bun-darwin-arm64 | vault-eval-darwin-arm64 |\n| macOS x64 | bun-darwin-x64 | vault-eval-darwin-x64 |\n| Linux x64 | bun-linux-x64 | vault-eval-linux-x64 |\n| Windows x64 | bun-windows-x64 | vault-eval-windows-x64.exe |\n\n## Key Files\n\n- `apps/desktop/package.json` - electron-builder config\n- `apps/desktop/electron/main/src/vault-eval-path.ts` - runtime path resolution\n- `packages/vault-eval/package.json` - CLI build targets\n- `.github/workflows/release.yml` - CI/CD pipeline\n\n## Parallelization\n\nPhase 1 (parallel):\n- scribe-9uc.6: electron-builder extraResources + build scripts\n- scribe-9uc.7: vault-eval path resolution helper\n\nPhase 2 (depends on Phase 1):\n- scribe-9uc.8: CI release workflow update\n\nPhase 3 (depends on all):\n- scribe-9uc.9: Integration testing","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-15T21:30:31.766996-06:00","updated_at":"2025-12-15T21:32:51.976493-06:00"}
{"id":"scribe-9uc.1","title":"Add extraResources config to electron-builder","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-15T21:30:31.841291-06:00","updated_at":"2025-12-15T21:32:38.628268-06:00","closed_at":"2025-12-15T21:32:38.628268-06:00","dependencies":[{"issue_id":"scribe-9uc.1","depends_on_id":"scribe-9uc","type":"parent-child","created_at":"2025-12-15T21:30:31.841611-06:00","created_by":"daemon"}]}
{"id":"scribe-9uc.2","title":"Create vault-eval path resolution helper","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-15T21:30:31.912565-06:00","updated_at":"2025-12-15T21:32:39.244315-06:00","closed_at":"2025-12-15T21:32:39.244315-06:00","dependencies":[{"issue_id":"scribe-9uc.2","depends_on_id":"scribe-9uc","type":"parent-child","created_at":"2025-12-15T21:30:31.912872-06:00","created_by":"daemon"}]}
{"id":"scribe-9uc.3","title":"Update desktop build scripts to compile vault-eval first","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-15T21:30:31.974631-06:00","updated_at":"2025-12-15T21:32:39.768073-06:00","closed_at":"2025-12-15T21:32:39.768073-06:00","dependencies":[{"issue_id":"scribe-9uc.3","depends_on_id":"scribe-9uc","type":"parent-child","created_at":"2025-12-15T21:30:31.974963-06:00","created_by":"daemon"}]}
{"id":"scribe-9uc.4","title":"Add vault-eval binary build step to CI release workflow","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T21:30:32.04374-06:00","updated_at":"2025-12-15T21:32:40.409971-06:00","closed_at":"2025-12-15T21:32:40.409971-06:00","dependencies":[{"issue_id":"scribe-9uc.4","depends_on_id":"scribe-9uc","type":"parent-child","created_at":"2025-12-15T21:30:32.044085-06:00","created_by":"daemon"}]}
{"id":"scribe-9uc.5","title":"Test packaged app includes working vault-eval binary","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T21:30:32.106944-06:00","updated_at":"2025-12-15T21:32:40.698947-06:00","closed_at":"2025-12-15T21:32:40.698947-06:00","dependencies":[{"issue_id":"scribe-9uc.5","depends_on_id":"scribe-9uc","type":"parent-child","created_at":"2025-12-15T21:30:32.107304-06:00","created_by":"daemon"}]}
{"id":"scribe-9uc.6","title":"Configure electron-builder extraResources and build scripts for vault-eval","description":"## Overview\n\nConfigure electron-builder to bundle the vault-eval binary and update build scripts to compile it before packaging.\n\n---\n\n## Files to Modify\n\n**`apps/desktop/package.json`**\n\n---\n\n## Implementation\n\n### 1. Add extraResources to electron-builder config\n\nAdd this to the `\"build\"` section:\n\n```json\n\"extraResources\": [\n  {\n    \"from\": \"../../packages/vault-eval/dist/vault-eval-${os}-${arch}${os === 'win32' ? '.exe' : ''}\",\n    \"to\": \"bin/vault-eval${os === 'win32' ? '.exe' : ''}\"\n  }\n]\n```\n\n**IMPORTANT**: electron-builder uses different variable names than Bun:\n- `${os}` = `mac`, `win`, `linux` (NOT `darwin`, `win32`)\n- `${arch}` = `x64`, `arm64`\n\nSo we need a different approach. Use platform-specific extraResources:\n\n```json\n\"extraResources\": [\n  {\n    \"from\": \"../../packages/vault-eval/dist/vault-eval-${platform}-${arch}\",\n    \"to\": \"bin/vault-eval\"\n  }\n]\n```\n\nWhere `${platform}` is resolved by a pre-build script that copies the right binary.\n\n**Alternative (simpler)**: Use a staging directory approach:\n\n```json\n\"extraResources\": [\n  {\n    \"from\": \"bin/vault-eval\",\n    \"to\": \"bin/vault-eval\"\n  }\n]\n```\n\nThen add a script that copies the correct platform binary to `apps/desktop/bin/vault-eval` before electron-builder runs.\n\n### 2. Add pre-dist script to copy correct binary\n\nAdd to scripts in `apps/desktop/package.json`:\n\n```json\n\"scripts\": {\n  \"prebuild:vault-eval\": \"cd ../../packages/vault-eval \u0026\u0026 bun run build:all\",\n  \"stage:vault-eval\": \"node scripts/stage-vault-eval.mjs\",\n  \"dist\": \"bun run prebuild:vault-eval \u0026\u0026 bun run stage:vault-eval \u0026\u0026 bun run build \u0026\u0026 electron-builder --publish never\",\n  \"dist:mac\": \"bun run prebuild:vault-eval \u0026\u0026 bun run stage:vault-eval \u0026\u0026 bun run build \u0026\u0026 electron-builder --mac --publish never\"\n}\n```\n\n### 3. Create staging script\n\nCreate `apps/desktop/scripts/stage-vault-eval.mjs`:\n\n```javascript\nimport { copyFileSync, mkdirSync, existsSync } from 'fs';\nimport { join, dirname } from 'path';\nimport { fileURLToPath } from 'url';\n\nconst __dirname = dirname(fileURLToPath(import.meta.url));\nconst desktopRoot = join(__dirname, '..');\nconst vaultEvalDist = join(desktopRoot, '../../packages/vault-eval/dist');\nconst targetDir = join(desktopRoot, 'bin');\n\n// Map Node.js platform/arch to Bun target names\nconst platformMap = {\n  darwin: 'darwin',\n  win32: 'windows',\n  linux: 'linux'\n};\n\nconst platform = platformMap[process.platform] || process.platform;\nconst arch = process.arch; // x64, arm64\n\nconst sourceName = `vault-eval-${platform}-${arch}${process.platform === 'win32' ? '.exe' : ''}`;\nconst targetName = `vault-eval${process.platform === 'win32' ? '.exe' : ''}`;\n\nconst sourcePath = join(vaultEvalDist, sourceName);\nconst targetPath = join(targetDir, targetName);\n\nif (!existsSync(sourcePath)) {\n  console.error(`ERROR: vault-eval binary not found at ${sourcePath}`);\n  console.error(`Run 'bun run prebuild:vault-eval' first, or check that the platform is supported.`);\n  process.exit(1);\n}\n\nmkdirSync(targetDir, { recursive: true });\ncopyFileSync(sourcePath, targetPath);\n\n// Make executable on Unix\nif (process.platform !== 'win32') {\n  const { chmodSync } = await import('fs');\n  chmodSync(targetPath, 0o755);\n}\n\nconsole.log(`Staged vault-eval binary: ${sourcePath} -\u003e ${targetPath}`);\n```\n\n### 4. Update .gitignore\n\nAdd to `apps/desktop/.gitignore` (create if doesn't exist):\n\n```\n# Staged binaries (generated during build)\nbin/\n```\n\n---\n\n## electron-builder extraResources Config\n\nFinal config in `apps/desktop/package.json`:\n\n```json\n\"build\": {\n  ...existing config...\n  \"extraResources\": [\n    {\n      \"from\": \"bin/vault-eval${os === 'win32' ? '.exe' : ''}\",\n      \"to\": \"bin/vault-eval${os === 'win32' ? '.exe' : ''}\"\n    }\n  ]\n}\n```\n\nWait, electron-builder doesn't support template literals in extraResources paths. Use this instead:\n\n```json\n\"extraResources\": [\n  {\n    \"from\": \"bin/\",\n    \"to\": \"bin/\",\n    \"filter\": [\"**/*\"]\n  }\n]\n```\n\nThis copies everything from `apps/desktop/bin/` to `Resources/bin/` in the packaged app.\n\n---\n\n## Exit Criteria\n\n- [ ] `bun run dist:mac` compiles vault-eval and stages the binary\n- [ ] Packaged app contains `Resources/bin/vault-eval` \n- [ ] Binary is executable (Unix permissions preserved)\n- [ ] Build works for both arm64 and x64 on macOS\n- [ ] `.gitignore` excludes staged binaries\n\n---\n\n## Verification\n\nAfter running `bun run dist:mac`, check:\n\n```bash\n# macOS\nls -la apps/desktop/dist/mac-arm64/Scribe.app/Contents/Resources/bin/\n# Should show: vault-eval (executable)\n```\n\n---\n\n## Edge Cases\n\n1. **Windows .exe extension**: staging script handles this\n2. **Missing binary**: staging script fails fast with clear error\n3. **Permissions**: staging script sets 755 on Unix\n\n---\n\n## Estimated Time\n\n2-3 hours","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-15T21:33:18.641228-06:00","updated_at":"2025-12-15T21:33:18.641228-06:00","dependencies":[{"issue_id":"scribe-9uc.6","depends_on_id":"scribe-9uc","type":"parent-child","created_at":"2025-12-15T21:33:18.641632-06:00","created_by":"daemon"}]}
{"id":"scribe-9uc.7","title":"Create vault-eval path resolution helper for Electron main process","description":"## Overview\n\nCreate a helper module that resolves the correct path to the vault-eval binary at runtime, handling both development and production environments.\n\n---\n\n## Files to Create\n\n**`apps/desktop/electron/main/src/vault-eval-path.ts`**\n\n---\n\n## Implementation\n\n```typescript\nimport { app } from 'electron';\nimport { join } from 'path';\nimport { existsSync } from 'fs';\n\n/**\n * Platform name mappings from Node.js to Bun target naming convention.\n * Node uses: darwin, win32, linux\n * Bun uses: darwin, windows, linux\n */\nconst PLATFORM_MAP: Record\u003cstring, string\u003e = {\n  darwin: 'darwin',\n  win32: 'windows',\n  linux: 'linux',\n};\n\n/**\n * Get the file extension for executables on the current platform.\n */\nfunction getExecutableExtension(): string {\n  return process.platform === 'win32' ? '.exe' : '';\n}\n\n/**\n * Get the path to the vault-eval binary.\n * \n * In production (packaged app):\n *   - macOS: Scribe.app/Contents/Resources/bin/vault-eval\n *   - Windows: resources/bin/vault-eval.exe\n *   - Linux: resources/bin/vault-eval\n * \n * In development:\n *   - packages/vault-eval/dist/vault-eval-{platform}-{arch}\n * \n * @returns Absolute path to the vault-eval binary\n * @throws Error if binary is not found\n */\nexport function getVaultEvalPath(): string {\n  const ext = getExecutableExtension();\n  \n  if (app.isPackaged) {\n    // Production: binary is in Resources/bin/\n    const binaryPath = join(process.resourcesPath, 'bin', `vault-eval${ext}`);\n    \n    if (!existsSync(binaryPath)) {\n      throw new Error(\n        `vault-eval binary not found at ${binaryPath}. ` +\n        `This may indicate a packaging error.`\n      );\n    }\n    \n    return binaryPath;\n  }\n  \n  // Development: use compiled binary from packages/vault-eval/dist/\n  const platform = PLATFORM_MAP[process.platform] || process.platform;\n  const arch = process.arch;\n  const binaryName = `vault-eval-${platform}-${arch}${ext}`;\n  \n  // Path from electron/main/src/ to packages/vault-eval/dist/\n  const binaryPath = join(\n    __dirname,\n    '..', '..', '..', '..', '..', // apps/desktop → repo root\n    'packages', 'vault-eval', 'dist',\n    binaryName\n  );\n  \n  if (!existsSync(binaryPath)) {\n    throw new Error(\n      `vault-eval binary not found at ${binaryPath}. ` +\n      `Run 'cd packages/vault-eval \u0026\u0026 bun run build' to compile it.`\n    );\n  }\n  \n  return binaryPath;\n}\n\n/**\n * Check if vault-eval binary is available.\n * \n * @returns true if binary exists, false otherwise\n */\nexport function isVaultEvalAvailable(): boolean {\n  try {\n    getVaultEvalPath();\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Get vault-eval version by executing --version.\n * \n * @returns Version string or null if unavailable\n */\nexport async function getVaultEvalVersion(): Promise\u003cstring | null\u003e {\n  try {\n    const binaryPath = getVaultEvalPath();\n    const { execFile } = await import('child_process');\n    const { promisify } = await import('util');\n    const execFileAsync = promisify(execFile);\n    \n    const { stdout } = await execFileAsync(binaryPath, ['--version']);\n    return stdout.trim();\n  } catch {\n    return null;\n  }\n}\n```\n\n---\n\n## Path Resolution Logic\n\n### Production (app.isPackaged === true)\n\n```\nmacOS:\n  Scribe.app/Contents/Resources/bin/vault-eval\n  └── process.resourcesPath = Scribe.app/Contents/Resources\n\nWindows:\n  C:\\Program Files\\Scribe\\resources\\bin\\vault-eval.exe\n  └── process.resourcesPath = C:\\Program Files\\Scribe\\resources\n\nLinux:\n  /opt/Scribe/resources/bin/vault-eval\n  └── process.resourcesPath = /opt/Scribe/resources\n```\n\n### Development (app.isPackaged === false)\n\n```\npackages/vault-eval/dist/vault-eval-darwin-arm64  (macOS arm64)\npackages/vault-eval/dist/vault-eval-darwin-x64    (macOS x64)\npackages/vault-eval/dist/vault-eval-linux-x64     (Linux)\npackages/vault-eval/dist/vault-eval-windows-x64.exe (Windows)\n```\n\n---\n\n## Usage Example\n\n```typescript\n// In an IPC handler or main process code\nimport { getVaultEvalPath, isVaultEvalAvailable } from './vault-eval-path.js';\nimport { spawn } from 'child_process';\n\n// Check availability\nif (!isVaultEvalAvailable()) {\n  console.warn('vault-eval not available');\n  return;\n}\n\n// Execute a command\nconst vaultEval = spawn(getVaultEvalPath(), ['info', '--vault', vaultPath, '--json']);\n\nvaultEval.stdout.on('data', (data) =\u003e {\n  const result = JSON.parse(data.toString());\n  // Handle result\n});\n```\n\n---\n\n## Export from Index\n\nAdd to `apps/desktop/electron/main/src/index.ts` (if it exists) or ensure it's importable:\n\n```typescript\nexport { getVaultEvalPath, isVaultEvalAvailable, getVaultEvalVersion } from './vault-eval-path.js';\n```\n\n---\n\n## Exit Criteria\n\n- [ ] `getVaultEvalPath()` returns correct path in development\n- [ ] `getVaultEvalPath()` returns correct path in packaged app\n- [ ] `isVaultEvalAvailable()` returns true when binary exists\n- [ ] `isVaultEvalAvailable()` returns false when binary missing\n- [ ] Throws helpful error messages when binary not found\n- [ ] Handles Windows .exe extension correctly\n- [ ] Unit tests cover all platforms (mock process.platform)\n\n---\n\n## Unit Tests\n\nCreate `apps/desktop/electron/main/src/vault-eval-path.test.ts`:\n\n```typescript\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\n\n// Tests should mock:\n// - app.isPackaged\n// - process.resourcesPath\n// - process.platform\n// - process.arch\n// - existsSync\n\ndescribe('getVaultEvalPath', () =\u003e {\n  it('returns production path when packaged on macOS', () =\u003e {\n    // Mock packaged app on macOS\n  });\n  \n  it('returns development path when not packaged', () =\u003e {\n    // Mock development environment\n  });\n  \n  it('throws when binary not found', () =\u003e {\n    // Mock missing binary\n  });\n  \n  it('handles Windows .exe extension', () =\u003e {\n    // Mock Windows platform\n  });\n});\n```\n\n---\n\n## Parallelization\n\nThis task can run in parallel with scribe-9uc.6 (electron-builder config) since they modify different files.\n\n---\n\n## Estimated Time\n\n1-2 hours","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-15T21:33:45.685073-06:00","updated_at":"2025-12-15T21:33:45.685073-06:00","dependencies":[{"issue_id":"scribe-9uc.7","depends_on_id":"scribe-9uc","type":"parent-child","created_at":"2025-12-15T21:33:45.685428-06:00","created_by":"daemon"}]}
{"id":"scribe-9uc.8","title":"Update CI release workflow to build vault-eval binaries","description":"## Overview\n\nUpdate the GitHub Actions release workflow to build vault-eval binaries before packaging the Electron app.\n\n---\n\n## Files to Modify\n\n**`.github/workflows/release.yml`**\n\n---\n\n## Current State\n\nThe release workflow currently:\n1. Checks out code at the release tag\n2. Installs dependencies with `bun install`\n3. Builds all packages with `bun run build`\n4. Runs `bun run dist:mac` in apps/desktop\n\nThe issue: vault-eval binaries are NOT built by `bun run build` - they require explicit compilation with `bun run build:all` in packages/vault-eval.\n\n---\n\n## Implementation\n\n### Option A: Build in workflow (Recommended)\n\nAdd vault-eval build step before the Electron build:\n\n```yaml\n- name: Build vault-eval binaries\n  run: |\n    cd packages/vault-eval\n    # Build only the platform we're packaging for\n    # macOS runner: build darwin-arm64 and darwin-x64\n    bun run build:darwin-arm64\n    bun run build:darwin-x64\n\n- name: Build Electron App\n  # ... existing step\n```\n\n### Option B: Leverage updated dist scripts\n\nIf scribe-9uc.6 updates the dist script to include vault-eval build:\n\n```json\n\"dist:mac\": \"bun run prebuild:vault-eval \u0026\u0026 bun run stage:vault-eval \u0026\u0026 bun run build \u0026\u0026 electron-builder --mac --publish never\"\n```\n\nThen the workflow doesn't need changes - but the prebuild step will try to build ALL platforms, which is wasteful.\n\n**Recommendation**: Use Option A for efficiency and clarity.\n\n---\n\n## Full Updated Workflow\n\n```yaml\nname: Release\n\non:\n  schedule:\n    - cron: '0 2 * * *'\n  workflow_dispatch:\n    inputs:\n      tag:\n        description: 'Tag to release (e.g., v1.2.3). Defaults to latest tag.'\n        required: false\n        type: string\n\njobs:\n  resolve-tag:\n    # ... unchanged ...\n\n  build-macos:\n    name: Build macOS\n    runs-on: macos-latest\n    needs: [resolve-tag]\n    if: needs.resolve-tag.outputs.should_release == 'true'\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          ref: ${{ needs.resolve-tag.outputs.tag }}\n\n      - uses: ./.github/actions/setup-bun\n\n      - name: Install dependencies\n        run: bun install --frozen-lockfile\n\n      - name: Sync version to desktop package\n        run: |\n          VERSION=$(jq -r .version package.json)\n          echo \"Syncing version $VERSION to apps/desktop/package.json\"\n          jq --arg v \"$VERSION\" '.version = $v' apps/desktop/package.json \u003e tmp.json \u0026\u0026 mv tmp.json apps/desktop/package.json\n\n      - name: Build all packages\n        run: bun run build\n\n      # NEW STEP: Build vault-eval for macOS\n      - name: Build vault-eval binaries (macOS)\n        run: |\n          cd packages/vault-eval\n          echo \"Building vault-eval for macOS arm64...\"\n          bun run build:darwin-arm64\n          echo \"Building vault-eval for macOS x64...\"\n          bun run build:darwin-x64\n          echo \"Built binaries:\"\n          ls -la dist/\n\n      # NEW STEP: Stage vault-eval binary\n      - name: Stage vault-eval binary\n        run: |\n          cd apps/desktop\n          node scripts/stage-vault-eval.mjs\n\n      - name: Build Electron App\n        env:\n          CSC_LINK: ${{ secrets.CSC_LINK }}\n          CSC_KEY_PASSWORD: ${{ secrets.CSC_KEY_PASSWORD }}\n          APPLE_ID: ${{ secrets.APPLE_ID }}\n          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}\n          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}\n        run: |\n          cd apps/desktop\n          if [ -z \"$CSC_LINK\" ] || [ -z \"$CSC_KEY_PASSWORD\" ]; then\n            echo \"::warning::Code signing disabled (missing CSC_LINK or CSC_KEY_PASSWORD)\"\n            export CSC_IDENTITY_AUTO_DISCOVERY=false\n          else\n            echo \"Code signing enabled\"\n          fi\n          if [ -z \"$APPLE_ID\" ] || [ -z \"$APPLE_APP_SPECIFIC_PASSWORD\" ] || [ -z \"$APPLE_TEAM_ID\" ]; then\n            echo \"::warning::Notarization disabled (missing APPLE_ID, APPLE_APP_SPECIFIC_PASSWORD, or APPLE_TEAM_ID)\"\n          else\n            echo \"Notarization enabled\"\n          fi\n          # Note: dist:mac now expects staged binary, not prebuild\n          bun run build \u0026\u0026 electron-builder --mac --publish never\n\n      - name: Verify vault-eval in package\n        run: |\n          echo \"Checking arm64 package...\"\n          if [ -d \"apps/desktop/dist/mac-arm64\" ]; then\n            ls -la \"apps/desktop/dist/mac-arm64/Scribe.app/Contents/Resources/bin/\" || echo \"bin/ not found\"\n          fi\n          echo \"Checking x64 package...\"\n          if [ -d \"apps/desktop/dist/mac-x64\" ]; then\n            ls -la \"apps/desktop/dist/mac-x64/Scribe.app/Contents/Resources/bin/\" || echo \"bin/ not found\"\n          fi\n\n      - name: Upload artifacts\n        uses: actions/upload-artifact@v4\n        with:\n          name: macos-artifacts\n          path: |\n            apps/desktop/dist/*.dmg\n            apps/desktop/dist/*.zip\n            apps/desktop/dist/latest-mac.yml\n\n  publish-release:\n    # ... unchanged ...\n```\n\n---\n\n## Cross-Architecture Build Consideration\n\nThe macOS runner builds both arm64 and x64 apps. electron-builder handles this by building twice. However, the staging script only stages ONE binary (for the runner's native architecture).\n\n**Solution**: Modify the workflow to stage the correct binary for each architecture build:\n\n```yaml\n- name: Build Electron App (arm64)\n  run: |\n    cd apps/desktop\n    # Force staging for arm64\n    STAGE_ARCH=arm64 node scripts/stage-vault-eval.mjs\n    electron-builder --mac --arm64 --publish never\n\n- name: Build Electron App (x64)\n  run: |\n    cd apps/desktop\n    # Force staging for x64\n    STAGE_ARCH=x64 node scripts/stage-vault-eval.mjs\n    electron-builder --mac --x64 --publish never\n```\n\nThis requires updating the staging script to accept STAGE_ARCH env var override.\n\n---\n\n## Staging Script Update (for CI)\n\nAdd arch override support to `apps/desktop/scripts/stage-vault-eval.mjs`:\n\n```javascript\n// Override arch via env var (useful for CI cross-compilation)\nconst arch = process.env.STAGE_ARCH || process.arch;\n```\n\n---\n\n## Dependencies\n\n- **Blocked by**: scribe-9uc.6 (needs staging script to exist first)\n\n---\n\n## Exit Criteria\n\n- [ ] CI builds vault-eval binaries for both macOS architectures\n- [ ] Packaged DMGs contain vault-eval in Resources/bin/\n- [ ] arm64 package has arm64 binary\n- [ ] x64 package has x64 binary\n- [ ] Verification step confirms binary presence\n- [ ] Release workflow completes successfully\n\n---\n\n## Testing\n\n1. Create a test branch\n2. Trigger workflow_dispatch manually\n3. Verify artifacts include vault-eval\n\n---\n\n## Estimated Time\n\n2-3 hours","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-15T21:34:18.05146-06:00","updated_at":"2025-12-15T21:34:18.05146-06:00","dependencies":[{"issue_id":"scribe-9uc.8","depends_on_id":"scribe-9uc","type":"parent-child","created_at":"2025-12-15T21:34:18.051874-06:00","created_by":"daemon"},{"issue_id":"scribe-9uc.8","depends_on_id":"scribe-9uc.6","type":"blocks","created_at":"2025-12-15T21:34:50.397577-06:00","created_by":"daemon"}]}
{"id":"scribe-9uc.9","title":"Integration test: verify vault-eval bundled and executable in packaged app","description":"## Overview\n\nCreate an integration test that verifies vault-eval is correctly bundled in the packaged Electron app and is executable.\n\n---\n\n## Test Approach\n\nThis is a **manual verification task** with optional automation. The goal is to confirm that the full packaging pipeline works end-to-end.\n\n---\n\n## Manual Verification Checklist\n\n### 1. Build the packaged app locally\n\n```bash\ncd apps/desktop\nbun run dist:mac\n```\n\n### 2. Verify binary exists in package\n\n```bash\n# For arm64 (if on Apple Silicon)\nls -la dist/mac-arm64/Scribe.app/Contents/Resources/bin/\n# Should show: vault-eval (executable, ~50-70MB)\n\n# For x64 (if on Intel or running with Rosetta)\nls -la dist/mac-x64/Scribe.app/Contents/Resources/bin/\n```\n\n### 3. Verify binary is executable\n\n```bash\n# Direct execution from package\ndist/mac-arm64/Scribe.app/Contents/Resources/bin/vault-eval --version\n# Should output: vault-eval 0.1.0 (or similar)\n\ndist/mac-arm64/Scribe.app/Contents/Resources/bin/vault-eval --help\n# Should show help text\n```\n\n### 4. Verify binary works with a vault\n\n```bash\n# Create a test vault or use an existing one\nVAULT_PATH=~/Documents/TestVault\ndist/mac-arm64/Scribe.app/Contents/Resources/bin/vault-eval info --vault \"$VAULT_PATH\" --json\n# Should output vault statistics JSON\n```\n\n### 5. Test from within running app (optional)\n\nIf there's IPC integration:\n1. Launch Scribe.app\n2. Trigger vault-eval command via IPC\n3. Verify response\n\n---\n\n## Automated Test (Optional)\n\nCreate `apps/desktop/vault-eval-packaging.integration.test.ts`:\n\n```typescript\nimport { describe, it, expect, beforeAll } from 'bun:test';\nimport { existsSync, statSync } from 'fs';\nimport { join } from 'path';\nimport { execSync } from 'child_process';\n\n/**\n * Integration tests for vault-eval packaging.\n * \n * Prerequisites:\n * - Run `bun run dist:mac` before running these tests\n * - These tests verify the BUILT artifacts, not the build process\n */\ndescribe('vault-eval packaging', () =\u003e {\n  const distDir = join(__dirname, 'dist');\n  const arm64AppPath = join(distDir, 'mac-arm64', 'Scribe.app');\n  const x64AppPath = join(distDir, 'mac-x64', 'Scribe.app');\n  \n  // Determine which architecture to test based on build availability\n  const appPath = existsSync(arm64AppPath) ? arm64AppPath : x64AppPath;\n  const binPath = join(appPath, 'Contents', 'Resources', 'bin', 'vault-eval');\n  \n  beforeAll(() =\u003e {\n    if (!existsSync(appPath)) {\n      console.warn('Skipping tests: packaged app not found. Run `bun run dist:mac` first.');\n    }\n  });\n  \n  it('vault-eval binary exists in Resources/bin/', () =\u003e {\n    if (!existsSync(appPath)) return; // Skip if no build\n    \n    expect(existsSync(binPath)).toBe(true);\n  });\n  \n  it('vault-eval binary is executable', () =\u003e {\n    if (!existsSync(appPath)) return;\n    \n    const stats = statSync(binPath);\n    // Check executable bit (0o111)\n    const isExecutable = (stats.mode \u0026 0o111) !== 0;\n    expect(isExecutable).toBe(true);\n  });\n  \n  it('vault-eval --version returns valid output', () =\u003e {\n    if (!existsSync(appPath)) return;\n    \n    const output = execSync(`\"${binPath}\" --version`, { encoding: 'utf-8' });\n    expect(output.trim()).toMatch(/^vault-eval \\d+\\.\\d+\\.\\d+/);\n  });\n  \n  it('vault-eval --help returns help text', () =\u003e {\n    if (!existsSync(appPath)) return;\n    \n    const output = execSync(`\"${binPath}\" --help`, { encoding: 'utf-8' });\n    expect(output).toContain('vault-eval');\n    expect(output).toContain('COMMANDS');\n  });\n  \n  it('vault-eval binary size is reasonable', () =\u003e {\n    if (!existsSync(appPath)) return;\n    \n    const stats = statSync(binPath);\n    const sizeMB = stats.size / (1024 * 1024);\n    \n    // Bun-compiled binaries are typically 50-100MB\n    expect(sizeMB).toBeGreaterThan(30); // At least 30MB\n    expect(sizeMB).toBeLessThan(150);   // Not more than 150MB\n  });\n});\n```\n\n---\n\n## Add to Test Script\n\nIf automated test is added, update `apps/desktop/package.json`:\n\n```json\n\"scripts\": {\n  \"test:packaging\": \"bun test vault-eval-packaging.integration.test.ts\"\n}\n```\n\n---\n\n## Dependencies\n\n- **Blocked by**: \n  - scribe-9uc.6 (electron-builder config)\n  - scribe-9uc.7 (path resolution helper - for any IPC tests)\n  - scribe-9uc.8 (CI workflow - for CI verification)\n\nThis task should be done LAST, after all other tasks are complete.\n\n---\n\n## Exit Criteria\n\n- [ ] Manual verification passes on at least one platform (macOS arm64 or x64)\n- [ ] Binary exists at expected path in packaged app\n- [ ] Binary is executable\n- [ ] Binary responds to --version and --help\n- [ ] Binary can query a real vault (if available)\n- [ ] (Optional) Automated test created and passing\n\n---\n\n## Notes\n\n- This task verifies the COMPLETE integration, not individual components\n- If issues are found, they likely indicate problems in earlier tasks\n- Document any issues found and file follow-up issues\n\n---\n\n## Estimated Time\n\n1-2 hours","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-15T21:34:45.066217-06:00","updated_at":"2025-12-15T21:34:45.066217-06:00","dependencies":[{"issue_id":"scribe-9uc.9","depends_on_id":"scribe-9uc","type":"parent-child","created_at":"2025-12-15T21:34:45.066656-06:00","created_by":"daemon"},{"issue_id":"scribe-9uc.9","depends_on_id":"scribe-9uc.6","type":"blocks","created_at":"2025-12-15T21:34:51.203149-06:00","created_by":"daemon"},{"issue_id":"scribe-9uc.9","depends_on_id":"scribe-9uc.7","type":"blocks","created_at":"2025-12-15T21:34:52.04011-06:00","created_by":"daemon"},{"issue_id":"scribe-9uc.9","depends_on_id":"scribe-9uc.8","type":"blocks","created_at":"2025-12-15T21:34:52.748136-06:00","created_by":"daemon"}]}
{"id":"scribe-a0k","title":"Extract shared InlineLinkNode base class from WikiLinkNode and PersonMentionNode","description":"WikiLinkNode.ts (173 lines) and PersonMentionNode.ts (180 lines) have nearly identical DecoratorNode implementations.\n\n**Duplicated Patterns (~100 lines):**\n- Class structure extending `DecoratorNode\u003cJSX.Element\u003e`\n- Identical methods: getType(), clone(), createDOM(), updateDOM(), exportDOM(), decorate(), exportJSON(), importJSON(), isInline(), getTextContent()\n- Component click handler pattern with error handling\n\n**Solution:**\nCreate a base `InlineLinkNode` class that handles:\n- Common DOM creation\n- Serialization/deserialization\n- Click handling with navigation\n- Subclasses provide type-specific display and CSS class names\n\n**Files:**\n- apps/desktop/renderer/src/components/Editor/plugins/WikiLinkNode.ts\n- apps/desktop/renderer/src/components/Editor/plugins/PersonMentionNode.ts\n\n**Estimated savings:** ~100 lines","status":"in_progress","priority":2,"issue_type":"task","created_at":"2025-12-12T21:18:13.464049-06:00","updated_at":"2025-12-12T23:21:24.671899-06:00","dependencies":[{"issue_id":"scribe-a0k","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:20:25.190852-06:00","created_by":"daemon"},{"issue_id":"scribe-a0k","depends_on_id":"scribe-9cl","type":"related","created_at":"2025-12-12T21:42:03.6224-06:00","created_by":"daemon"}]}
{"id":"scribe-arr","title":"Decompose CommandPalette.tsx into mode-specific panel components","description":"The CommandPalette component in apps/desktop/renderer/src/components/CommandPalette/CommandPalette.tsx is ~1339 lines with 6 distinct modes mixed into one monolithic component. This makes it difficult to understand, test, and extend.\n\n## Analysis\n\nThe component manages these distinct modes with significant state and rendering logic for each:\n\n1. **Command Mode** (default): Command list with fuzzy search, keyboard navigation, 'create daily note' option\n2. **File-Browse Mode**: Note listing with recent notes, fuzzy search via Fuse.js, delete button per item\n3. **Delete-Browse Mode**: Note selection for deletion (similar to file-browse but different click behavior)\n4. **Delete-Confirm Mode**: Confirmation dialog for note deletion\n5. **Person-Browse Mode**: People listing with fuzzy search\n6. **Prompt-Input Mode**: Text input modal for creating entities\n\n### State Complexity (~25 useState calls)\n- query, selectedIndex, searchResults (command mode)\n- allNotes, isLoadingNotes, selectedNoteIndex, displayedNotes (file-browse)\n- allPeople, isLoadingPeople, selectedPersonIndex, fuzzyPeopleResults (person-browse)\n- pendingDeleteNote, returnMode, isDeleting (delete modes)\n- promptInputValue (prompt mode)\n- showCreateDailyOption, createDailyIsoDate (date search feature)\n\n### Duplicated Patterns\n- renderFileBrowseResults() and renderDeleteBrowseResults() are 90% identical\n- Keyboard handlers for file-browse and delete-browse are nearly identical\n- Fuse.js index setup is duplicated for notes and people\n\n## Proposed Solution\n\nExtract mode-specific logic into dedicated components:\n\n### 1. CommandModePanel.tsx\n- Command rendering and selection\n- Search results rendering\n- 'Create daily note' option\n- State: query, selectedIndex, searchResults, showCreateDailyOption\n\n### 2. FileBrowsePanel.tsx\n- Recent notes display\n- Fuzzy search with Fuse.js\n- Note item rendering with delete button\n- State: allNotes, selectedNoteIndex, fuzzySearchResults\n\n### 3. DeleteBrowsePanel.tsx (or reuse FileBrowsePanel with mode prop)\n- Can share FileBrowsePanel with an onSelect callback difference\n\n### 4. DeleteConfirmDialog.tsx\n- Confirmation UI\n- State: pendingDeleteNote, isDeleting\n\n### 5. PersonBrowsePanel.tsx\n- People listing and fuzzy search\n- State: allPeople, selectedPersonIndex, fuzzyPeopleResults\n\n### 6. PromptInputPanel.tsx\n- Text input modal\n- State: promptInputValue\n\n### 7. Shared hook: useFuzzySearch.ts\n- Extract Fuse.js index creation and search logic\n- Reusable for notes, people, and future searchable lists\n\n### CommandPalette.tsx (refactored)\n- Mode router that renders the appropriate panel\n- Manages only: isOpen, mode, onClose\n- Passes callbacks to child panels\n\nExpected result: CommandPalette.tsx reduced to ~150-200 lines, with each panel being ~100-200 lines.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:00:08.135479-06:00","updated_at":"2025-12-12T22:12:03.310454-06:00","closed_at":"2025-12-12T22:12:03.310454-06:00","dependencies":[{"issue_id":"scribe-arr","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:00:11.564444-06:00","created_by":"daemon"},{"issue_id":"scribe-arr","depends_on_id":"scribe-1sh","type":"related","created_at":"2025-12-12T21:42:09.6592-06:00","created_by":"daemon"}]}
{"id":"scribe-arx","title":"Remove unused taskNavigation utility","description":"The taskNavigation utility (156 lines + tests) is never imported. Investigation needed before removal.\n\n**Action Required:**\n1. Check git history for why this was created\n2. Search for related features or tickets\n3. If orphaned: delete. If intended: integrate or document.\n\n**Files:**\n- apps/desktop/renderer/src/utils/taskNavigation.ts\n- apps/desktop/renderer/src/utils/taskNavigation.test.ts","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:19:31.497154-06:00","updated_at":"2025-12-13T01:15:55.451085-06:00","closed_at":"2025-12-13T01:15:55.451085-06:00","dependencies":[{"issue_id":"scribe-arx","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:20:26.730305-06:00","created_by":"daemon"},{"issue_id":"scribe-arx","depends_on_id":"scribe-oua","type":"related","created_at":"2025-12-12T21:43:51.027975-06:00","created_by":"daemon"}]}
{"id":"scribe-b7l","title":"Add special character handling tests for SearchEngine","description":"Add tests for special character handling in search-engine.test.ts:\n- Search queries with special chars: @, #, *, ?, [, ], (, ), etc.\n- Note content with special chars (emojis, unicode, code blocks)\n- Tags with special chars (#c++, #c#, #node.js)\n- Title with special chars (e.g., 'Q\u0026A', 'TODO: Fix bug')\n- FlexSearch tokenization edge cases\n- SQL-like injection strings (shouldn't break search)\n- Regex metacharacters in search query\n\nCurrent tests use only alphanumeric content.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:01:25.516765-06:00","updated_at":"2025-12-13T00:43:32.3826-06:00","closed_at":"2025-12-13T00:43:32.3826-06:00","dependencies":[{"issue_id":"scribe-b7l","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:01:28.73017-06:00","created_by":"daemon"}]}
{"id":"scribe-baj","title":"Add tests for node.ts utility module","description":"packages/engine-core/src/node.ts has NO tests.\n\n**Functions needing tests:**\n- Node traversal utilities\n- Node type checking functions\n- Helper functions for working with Lexical nodes\n\n**Files:**\n- packages/engine-core/src/node.ts","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:26:09.730906-06:00","updated_at":"2025-12-13T01:16:59.835016-06:00","closed_at":"2025-12-13T01:16:59.835016-06:00","dependencies":[{"issue_id":"scribe-baj","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:26:45.212157-06:00","created_by":"daemon"}]}
{"id":"scribe-bi0","title":"Make text-extraction helpers internal (not exported)","description":"The functions `extractTextWithContext` and `generateSnippet` are exported from engine-search but only used internally.\n\n**Evidence:**\n- Exported from packages/engine-search/src/index.ts\n- Only used within search-engine.ts\n- No external imports found\n\n**Action:**\nRemove from public exports and keep as internal implementation details.\n\n**Files:**\n- packages/engine-search/src/index.ts\n- packages/engine-search/src/text-extraction.ts","status":"closed","priority":4,"issue_type":"task","created_at":"2025-12-12T21:19:43.986997-06:00","updated_at":"2025-12-13T01:16:21.716675-06:00","closed_at":"2025-12-13T01:16:21.716675-06:00","dependencies":[{"issue_id":"scribe-bi0","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:20:28.038905-06:00","created_by":"daemon"}]}
{"id":"scribe-bk5","title":"Refactor FileSystemVault: Extract NoteMigrator for legacy upgrades","description":"FileSystemVault.migrateNote() (lines 413-439) handles legacy note format upgrades mixed with storage logic.\n\n**Extract: NoteMigrator**\n- Move migrateNote() method\n- Define migration versioning scheme\n- Support chained migrations (v1→v2→v3)\n- Track which notes have been migrated\n\n**Interface:**\n```typescript\ninterface NoteMigrator {\n  needsMigration(note: unknown): boolean\n  migrate(note: unknown): Note\n  getVersion(note: Note): number\n}\n```\n\n**Current migrations embedded:**\n- Add explicit title (from metadata.title or 'Untitled')\n- Add explicit type (from metadata.type or content.type)\n- Initialize tags as empty array\n- Preserve daily/meeting fields\n\n**Benefits:**\n- New migrations don't require touching FileSystemVault\n- Migration logic testable with sample legacy data\n- Could add dry-run mode to preview migrations\n- Version tracking enables incremental upgrades","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:01:16.325127-06:00","updated_at":"2025-12-12T23:18:49.884965-06:00","closed_at":"2025-12-12T23:18:49.884965-06:00","dependencies":[{"issue_id":"scribe-bk5","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:01:19.352888-06:00","created_by":"daemon"},{"issue_id":"scribe-bk5","depends_on_id":"scribe-1rf","type":"related","created_at":"2025-12-12T21:41:57.783221-06:00","created_by":"daemon"}]}
{"id":"scribe-bq3","title":"Extract shared AutocompleteList component from WikiLinkAutocomplete and PersonMentionAutocomplete","description":"WikiLinkAutocomplete.tsx and PersonMentionAutocomplete.tsx share common patterns:\n\n**Duplicated Patterns (~50 lines):**\n1. Scroll into view logic:\n```typescript\nuseEffect(() =\u003e {\n  if (selectedRef.current) {\n    selectedRef.current.scrollIntoView({ block: 'nearest' });\n  }\n}, [selectedIndex]);\n```\n2. Result list rendering with selectedRef assignment\n3. Loading/empty state rendering\n\n**Solution:**\nCreate a shared `AutocompleteList` component:\n```typescript\ninterface AutocompleteListProps\u003cT\u003e {\n  items: T[];\n  selectedIndex: number;\n  onSelect: (item: T) =\u003e void;\n  renderItem: (item: T, isSelected: boolean) =\u003e ReactNode;\n  emptyMessage: string;\n  loadingMessage?: string;\n  isLoading?: boolean;\n}\n```\n\n**Files:**\n- apps/desktop/renderer/src/components/Editor/plugins/WikiLinkAutocomplete.tsx\n- apps/desktop/renderer/src/components/Editor/plugins/PersonMentionAutocomplete.tsx\n\n**Estimated savings:** ~50 lines","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:18:38.548033-06:00","updated_at":"2025-12-13T01:35:08.696471-06:00","closed_at":"2025-12-13T01:35:08.696471-06:00","dependencies":[{"issue_id":"scribe-bq3","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:20:27.048914-06:00","created_by":"daemon"},{"issue_id":"scribe-bq3","depends_on_id":"scribe-9cl","type":"blocks","created_at":"2025-12-12T21:42:03.579038-06:00","created_by":"daemon"}]}
{"id":"scribe-bxq","title":"Remove 'not yet implemented' console.log placeholders","description":"Several features have placeholder console.log statements indicating incomplete functionality:\n\n**SlashMenu commands.ts:**\n- Line 148: 'AI Continue: Not yet implemented'\n- Line 159: 'AI Summarize: Not yet implemented'\n\n**SelectionToolbarPlugin.tsx:**\n- Line 276: 'Link formatting not yet implemented'\n- Line 320: 'Ask AI clicked - not yet implemented'\n\n**Options:**\n1. **Implement the features** - if they're planned soon\n2. **Remove the menu items** - if features are not planned\n3. **Disable with visual indicator** - show as grayed out with 'Coming Soon' tooltip\n\n**Recommendation:** Remove the menu items until features are implemented to avoid confusing users.\n\n**Files:**\n- apps/desktop/renderer/src/components/Editor/SlashMenu/commands.ts\n- apps/desktop/renderer/src/components/Editor/SelectionToolbar/SelectionToolbarPlugin.tsx","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:25:54.42246-06:00","updated_at":"2025-12-13T00:37:40.535466-06:00","closed_at":"2025-12-13T00:37:40.535466-06:00","dependencies":[{"issue_id":"scribe-bxq","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:26:45.062745-06:00","created_by":"daemon"}]}
{"id":"scribe-csc","title":"Create generic createLinkContext factory for WikiLinkContext and PersonMentionContext","description":"WikiLinkContext.tsx and PersonMentionContext.tsx are nearly identical (39 lines each).\n\n**Duplicated Pattern:**\n```typescript\ninterface ContextValue {\n  currentNoteId: NoteId | null;\n  onClick: (...) =\u003e Promise\u003cvoid\u003e;\n  onError: (message: string) =\u003e void;\n}\nconst Context = createContext\u003cContextValue | null\u003e(null);\nexport function Provider({ children, ...props }) { ... }\nexport function useContext() { ... }\n```\n\n**Solution:**\nCreate a generic `createLinkContext\u003cT\u003e()` factory function that generates context/provider/hook for any link-type node.\n\n**Files:**\n- apps/desktop/renderer/src/components/Editor/plugins/WikiLinkContext.tsx\n- apps/desktop/renderer/src/components/Editor/plugins/PersonMentionContext.tsx\n\n**Estimated savings:** ~40 lines","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:18:18.411037-06:00","updated_at":"2025-12-13T01:25:28.398265-06:00","closed_at":"2025-12-13T01:25:28.398265-06:00","dependencies":[{"issue_id":"scribe-csc","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:20:27.155602-06:00","created_by":"daemon"}]}
{"id":"scribe-ct6","title":"Refactor TaskIndex: Extract TaskReconciler for note sync logic","description":"TaskIndex mixes reconciliation with storage. The indexNote() method (lines 162-258) is 96 lines of complex matching logic.\n\n**Extract: TaskReconciler**\n- Move indexNote() core logic\n- Move reconcileTask() private method (lines 496-551)\n- Move createTask() private method (lines 468-489)\n- Move getMaxPriority() helper\n\n**Interface:**\n```typescript\ninterface TaskReconciler {\n  reconcile(\n    note: Note,\n    existingTasks: Map\u003cstring, Task\u003e,\n    now: number\n  ): {\n    toAdd: Task[]\n    toUpdate: Task[]\n    toRemove: string[]\n  }\n}\n```\n\n**Reconciliation rules (currently embedded):**\n1. Match by nodeKey first\n2. Fallback to textHash\n3. Preserve priority/createdAt on match\n4. Set completedAt on state transitions\n5. Generate stable task IDs\n\n**Benefits:**\n- Reconciliation logic testable in isolation\n- Clear separation of 'what changed' from 'apply changes'\n- Easier to reason about matching rules","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:00:33.559119-06:00","updated_at":"2025-12-12T22:45:44.872789-06:00","closed_at":"2025-12-12T22:45:44.872789-06:00","dependencies":[{"issue_id":"scribe-ct6","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:00:36.813071-06:00","created_by":"daemon"},{"issue_id":"scribe-ct6","depends_on_id":"scribe-l59","type":"blocks","created_at":"2025-12-12T21:41:54.748217-06:00","created_by":"daemon"}]}
{"id":"scribe-dvf","title":"Add tests for ContextPanel and widget components","description":"ContextPanel (216 lines) and several widget components have NO or minimal tests.\n\n**Files needing tests:**\n- apps/desktop/renderer/src/components/ContextPanel/ContextPanel.tsx (216 lines)\n- apps/desktop/renderer/src/components/ContextPanel/CalendarWidget.tsx\n- apps/desktop/renderer/src/components/ContextPanel/LinkedMentions.tsx (202 lines)\n- apps/desktop/renderer/src/components/ContextPanel/AttendeesWidget.tsx (237 lines)\n\n**Test scenarios:**\n- Panel open/close toggle\n- Widget visibility based on note type\n- Calendar widget date display\n- Backlinks/references fetching and display\n- Attendees CRUD operations\n- Empty states for each widget\n\n**Note:** TasksWidget.test.tsx and ReferencesWidget.test.tsx already exist.\n\n**Files:**\n- apps/desktop/renderer/src/components/ContextPanel/*","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:27:29.395019-06:00","updated_at":"2025-12-12T23:52:20.940177-06:00","closed_at":"2025-12-12T23:52:20.940177-06:00","dependencies":[{"issue_id":"scribe-dvf","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:27:33.32444-06:00","created_by":"daemon"}]}
{"id":"scribe-e6b","title":"Reduce IPC handler boilerplate in main.ts with withEngines() wrapper","description":"main.ts has ~15 IPC handlers that repeat the same initialization check pattern:\n\n```typescript\nipcMain.handle('notes:save', async (_event, note: Note) =\u003e {\n  if (!vault) {\n    throw new Error('Vault not initialized');\n  }\n  if (!graphEngine) {\n    throw new Error('Graph engine not initialized');\n  }\n  if (!searchEngine) {\n    throw new Error('Search engine not initialized');\n  }\n  if (!taskIndex) {\n    throw new Error('Task index not initialized');\n  }\n  // ... actual logic\n});\n```\n\nThis boilerplate appears in handlers for:\n- notes:save, notes:delete, notes:read\n- graph:forNote, graph:backlinks, graph:notesWithTag\n- people:list, people:create, people:search  \n- tasks:toggle, tasks:list, tasks:get, tasks:reorder\n- daily:getOrCreate, daily:find\n- meeting:create, meeting:addAttendee, meeting:removeAttendee\n\n**Suggested fix**: Create a withEngines() higher-order function:\n\n```typescript\ntype Engines = {\n  vault: FileSystemVault;\n  graphEngine: GraphEngine;\n  searchEngine: SearchEngine;\n  taskIndex: TaskIndex;\n};\n\nfunction withEngines\u003cT extends unknown[], R\u003e(\n  handler: (engines: Engines, ...args: T) =\u003e Promise\u003cR\u003e\n): (...args: T) =\u003e Promise\u003cR\u003e {\n  return async (...args: T) =\u003e {\n    if (!vault || !graphEngine || !searchEngine || !taskIndex) {\n      throw new Error('Engines not initialized');\n    }\n    return handler({ vault, graphEngine, searchEngine, taskIndex }, ...args);\n  };\n}\n\n// Usage:\nipcMain.handle('notes:save', withEngines(async ({ vault, graphEngine, searchEngine, taskIndex }, _event, note) =\u003e {\n  await vault.save(note);\n  graphEngine.addNote(note);\n  // ...\n}));\n```\n\nAlternative: Use decorator pattern with metadata if TypeScript decorators are enabled.\n\nEstimate: ~1.5 hours","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:00:53.718032-06:00","updated_at":"2025-12-13T01:35:50.113451-06:00","closed_at":"2025-12-13T01:35:50.113451-06:00","dependencies":[{"issue_id":"scribe-e6b","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:00:56.918282-06:00","created_by":"daemon"}]}
{"id":"scribe-e8a","title":"loadConfig() swallows all errors including JSON parse failures","description":"In apps/desktop/electron/main/src/main.ts lines 41-44, loadConfig() catches all errors and returns empty config. This hides JSON parsing errors (corrupt config) and permission errors. Should distinguish between ENOENT (acceptable) and other errors (should log/alert).","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-12T20:59:55.124091-06:00","updated_at":"2025-12-12T22:12:00.872349-06:00","closed_at":"2025-12-12T22:12:00.872349-06:00","dependencies":[{"issue_id":"scribe-e8a","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:00:09.982165-06:00","created_by":"daemon"}]}
{"id":"scribe-etk","title":"Add tests for auto-updater.ts","description":"apps/desktop/electron/main/src/auto-updater.ts has NO tests despite containing critical auto-update functionality.\n\n**Functions needing tests:**\n- setupAutoUpdater() - initializes auto-updater and periodic checks\n- checkForUpdate() - manual update check\n- downloadUpdate() - download handler\n- installUpdate() - quit and install\n- Event handlers for update-available, update-downloaded, error\n\n**Test scenarios:**\n- Successful update check flow\n- Update available → download → install\n- Network errors during check\n- Download failures\n- User cancellation\n- Multiple setupAutoUpdater() calls (related to scribe-3r5 memory leak)\n\n**Note:** This is related to scribe-3r5 (memory leak in setInterval) - tests should verify cleanup.\n\n**Files:**\n- apps/desktop/electron/main/src/auto-updater.ts","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:26:00.207189-06:00","updated_at":"2025-12-12T23:46:27.183853-06:00","closed_at":"2025-12-12T23:46:27.183853-06:00","dependencies":[{"issue_id":"scribe-etk","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:26:45.112925-06:00","created_by":"daemon"},{"issue_id":"scribe-etk","depends_on_id":"scribe-3r5","type":"blocks","created_at":"2025-12-12T21:41:49.543142-06:00","created_by":"daemon"}]}
{"id":"scribe-eyg","title":"Add tests for vault.ts initialization utilities","description":"packages/storage-fs/src/vault.ts (105 lines) has NO tests.\n\n**Functions needing tests:**\n- initializeVault(vaultPath) - creates vault directory structure\n- isValidVault(vaultPath) - validates vault structure\n- Path utilities for vault subdirectories\n\n**Test scenarios:**\n- Creating new vault in empty directory\n- Validating existing vault structure\n- Handling missing subdirectories\n- Permission errors\n- Cross-platform path handling\n\n**Files:**\n- packages/storage-fs/src/vault.ts","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:19:15.827269-06:00","updated_at":"2025-12-12T23:36:30.63515-06:00","closed_at":"2025-12-12T23:36:30.63515-06:00","dependencies":[{"issue_id":"scribe-eyg","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:20:24.965877-06:00","created_by":"daemon"}]}
{"id":"scribe-f47","title":"Race condition in FileSystemStorage.save() allows concurrent overwrites","description":"## Location\n`packages/storage-fs/src/storage.ts` lines 210-254\n\n## Problem\nThe `save()` method has a race condition between reading existing note state and writing the updated note. The sequence is:\n\n1. Read existing note from in-memory map (line 213)\n2. Merge fields and prepare updated note (lines 215-238)\n3. Atomic write to disk (line 242)\n4. Update in-memory map (line 245)\n\nIf two concurrent saves occur for the same note:\n- Save A reads state at T1\n- Save B reads state at T1 (same state)\n- Save A writes at T2\n- Save B writes at T3, overwriting Save A's changes\n\nThe `atomicWrite()` only prevents partial writes (crash safety), NOT concurrent access.\n\n## Impact\n- **Data loss**: User edits can be silently overwritten\n- **State inconsistency**: In-memory map can diverge from disk if operations interleave\n\n## Suggested Solutions\n\n### Option 1: Per-note mutex (Recommended)\n```typescript\nprivate saveLocks = new Map\u003cNoteId, Promise\u003cvoid\u003e\u003e();\n\nasync save(note: Note): Promise\u003cvoid\u003e {\n  const lock = this.saveLocks.get(note.id) ?? Promise.resolve();\n  const newLock = lock.then(() =\u003e this.doSave(note));\n  this.saveLocks.set(note.id, newLock);\n  return newLock;\n}\n```\n\n### Option 2: Write queue with debouncing\nUseful if saves are frequent (e.g., autosave on keystroke).\n\n### Option 3: Optimistic locking with version field\nAdd `version: number` to Note, reject saves where version doesn't match.\n\n## Acceptance Criteria\n- [ ] Concurrent saves to the same note are serialized\n- [ ] No data loss under concurrent operations\n- [ ] Add unit tests for concurrent save scenarios","acceptance_criteria":"- Concurrent saves to the same note are serialized via per-note mutex\n- No data loss under concurrent operations (verified by test)\n- Unit tests cover: concurrent saves, save during save, state consistency\n- Implementation uses promise-chaining pattern from suggested solution","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-12T20:59:45.395722-06:00","updated_at":"2025-12-12T21:52:31.541446-06:00","closed_at":"2025-12-12T21:52:31.541446-06:00","dependencies":[{"issue_id":"scribe-f47","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:00:06.093729-06:00","created_by":"daemon"}]}
{"id":"scribe-gyb","title":"Remove deprecated extractTitle function from engine-core","description":"The `extractTitle` function is marked as deprecated but still exported.\n\n**Evidence:**\n- packages/engine-core/src/metadata.ts (lines 30-35)\n- Marked with `@deprecated` - 'Title is now stored explicitly on Note.title'\n- Exported from packages/engine-core/src/index.ts\n- Only used in its own test file (metadata.test.ts)\n\n**Actions:**\n1. Remove `extractTitle` from exports in index.ts\n2. Delete the function from metadata.ts\n3. Update/remove related tests\n\n**Files:**\n- packages/engine-core/src/metadata.ts\n- packages/engine-core/src/index.ts\n- packages/engine-core/src/metadata.test.ts","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:19:35.892137-06:00","updated_at":"2025-12-13T00:32:47.492907-06:00","closed_at":"2025-12-13T00:32:47.492907-06:00","dependencies":[{"issue_id":"scribe-gyb","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:20:26.674977-06:00","created_by":"daemon"}]}
{"id":"scribe-js3","title":"Add persistence failure recovery tests for TaskIndex","description":"Add tests for persistence error handling in task-index.test.ts:\n- persist() when fs.writeFile fails (disk full, permission denied)\n- persist() when fs.rename fails (atomic write failure)\n- persist() when fs.mkdir fails\n- load() with corrupted JSONL file (partial lines, invalid JSON)\n- Recovery behavior after persist failure (dirty flag state, retry)\n- schedulePersist() error callback handling\n\nCurrent tests mock fs to always succeed. Need failure path coverage.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:00:58.673043-06:00","updated_at":"2025-12-13T00:41:42.149682-06:00","closed_at":"2025-12-13T00:41:42.149682-06:00","dependencies":[{"issue_id":"scribe-js3","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:01:01.742492-06:00","created_by":"daemon"}]}
{"id":"scribe-k5r","title":"Race condition in FileSystemStorage.delete() causes state inconsistency","description":"## Location\n`packages/storage-fs/src/storage.ts` lines 262-273\n\n## Problem\nThe `delete()` method has a race condition between disk deletion and in-memory map update:\n\n```typescript\nasync delete(id: NoteId): Promise\u003cvoid\u003e {\n  const notePath = getNoteFilePath(this.vaultPath, id);\n  try {\n    await fs.unlink(notePath);  // Step 1: Delete from disk\n    this.notes.delete(id);       // Step 2: Delete from memory\n  } catch (error) { ... }\n}\n```\n\n### Race Scenarios\n\n**Scenario 1: Delete + Save race**\n- Delete starts, removes file from disk\n- Save starts for same note, reads from in-memory map (still exists!)\n- Save writes new file to disk\n- Delete removes from in-memory map\n- Result: File exists on disk, not in memory\n\n**Scenario 2: Delete + Delete race**\n- Delete A removes file, about to update map\n- Delete B tries to unlink, gets ENOENT\n- Inconsistent error handling\n\n**Scenario 3: Delete + Read race**\n- Delete removes file from disk\n- Read checks in-memory map, finds note\n- Returns stale data that no longer exists on disk\n\n## Impact\n- **Ghost files**: Files on disk not tracked in memory\n- **Phantom notes**: In-memory notes with no backing file\n- **Stale reads**: Returning deleted note data\n\n## Suggested Solutions\n\n### Option 1: Per-note mutex (Recommended)\nShare the same lock mechanism with `save()`:\n```typescript\nasync delete(id: NoteId): Promise\u003cvoid\u003e {\n  return this.withNoteLock(id, async () =\u003e {\n    const notePath = getNoteFilePath(this.vaultPath, id);\n    this.notes.delete(id);      // Remove from memory first\n    await fs.unlink(notePath);  // Then remove from disk\n  });\n}\n```\n\n### Option 2: Memory-first deletion\nDelete from memory before disk to prevent stale reads:\n```typescript\nasync delete(id: NoteId): Promise\u003cvoid\u003e {\n  const note = this.notes.get(id);\n  this.notes.delete(id);  // Immediate memory removal\n  try {\n    await fs.unlink(notePath);\n  } catch (error) {\n    if (note) this.notes.set(id, note);  // Rollback on failure\n    throw error;\n  }\n}\n```\n\n## Acceptance Criteria\n- [ ] Delete and save operations on same note are serialized\n- [ ] No ghost files or phantom notes after concurrent operations\n- [ ] Add unit tests for delete + save race scenarios","acceptance_criteria":"- Delete and save operations on same note are serialized (reuse mutex from scribe-f47)\n- No ghost files or phantom notes after concurrent operations\n- Memory-first deletion order (remove from map before disk)\n- Unit tests cover: delete+save race, delete+delete race, delete+read race","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-12T21:00:01.817352-06:00","updated_at":"2025-12-12T21:52:33.121387-06:00","closed_at":"2025-12-12T21:52:33.121387-06:00","dependencies":[{"issue_id":"scribe-k5r","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:00:06.694348-06:00","created_by":"daemon"},{"issue_id":"scribe-k5r","depends_on_id":"scribe-f47","type":"related","created_at":"2025-12-12T21:41:47.696064-06:00","created_by":"daemon"}]}
{"id":"scribe-l59","title":"Refactor TaskIndex: Extract TaskPersistence for JSONL I/O","description":"TaskIndex (588 lines) violates SRP by mixing storage, persistence, reconciliation, and query logic.\n\n**Extract: TaskPersistence**\n- Move load() and persist() methods\n- Move schedulePersist(), flush() debounce logic\n- Move persistPath, dirty flag, persistTimeout, debounceMs state\n- Owns atomic temp+rename write pattern (lines 96-115)\n- Owns JSONL parse/serialize (lines 62-89, 101-104)\n\n**Interface:**\n```typescript\ninterface TaskPersistence {\n  load(): Promise\u003cMap\u003cstring, Task\u003e\u003e\n  persist(tasks: Map\u003cstring, Task\u003e): Promise\u003cvoid\u003e\n  schedulePersist(tasks: Map\u003cstring, Task\u003e): void\n  flush(tasks: Map\u003cstring, Task\u003e): Promise\u003cvoid\u003e\n}\n```\n\n**Benefits:**\n- TaskIndex focuses on indexing logic\n- Persistence strategy becomes swappable (JSONL, SQLite, etc.)\n- Easier to test persistence in isolation","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:00:23.962989-06:00","updated_at":"2025-12-12T22:40:05.10641-06:00","closed_at":"2025-12-12T22:40:05.10641-06:00","dependencies":[{"issue_id":"scribe-l59","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:00:27.558572-06:00","created_by":"daemon"}]}
{"id":"scribe-lgy","title":"Add tests for text-extraction.ts","description":"packages/engine-search/src/text-extraction.ts has NO unit tests despite being used by SearchEngine.\n\n**Functions needing tests:**\n- extractText(lexicalState) - main text extraction from Lexical state\n- Helper functions for node traversal\n- Whitespace normalization\n- Special node handling (links, mentions, etc.)\n\n**Test scenarios:**\n- Plain text extraction\n- Nested node structures\n- WikiLink text extraction\n- Person mention text extraction  \n- Table text extraction\n- Empty/null content handling\n- Malformed Lexical state\n- Very large documents\n\n**Files:**\n- packages/engine-search/src/text-extraction.ts","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:26:04.348742-06:00","updated_at":"2025-12-12T21:26:53.921809-06:00","closed_at":"2025-12-12T21:26:53.921809-06:00","dependencies":[{"issue_id":"scribe-lgy","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:26:45.162906-06:00","created_by":"daemon"}]}
{"id":"scribe-mii","title":"Add tests for SelectionToolbar components","description":"SelectionToolbar has NO tests despite being 332+ lines of complex formatting logic:\n\n**Files needing tests:**\n- apps/desktop/renderer/src/components/Editor/SelectionToolbar/SelectionToolbarPlugin.tsx (332 lines)\n- apps/desktop/renderer/src/components/Editor/SelectionToolbar/SelectionToolbar.tsx (175 lines)\n\n**Test scenarios:**\n- Toolbar visibility on text selection\n- Toolbar positioning (above/below selection)\n- Format toggling (bold, italic, underline, strikethrough, code)\n- Active state detection for each format\n- Toolbar hiding on selection clear\n- Keyboard shortcuts for formatting\n\n**Files:**\n- apps/desktop/renderer/src/components/Editor/SelectionToolbar/*","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:27:05.642211-06:00","updated_at":"2025-12-12T23:59:43.378638-06:00","closed_at":"2025-12-12T23:59:43.378638-06:00","dependencies":[{"issue_id":"scribe-mii","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:27:10.335696-06:00","created_by":"daemon"}]}
{"id":"scribe-ms1","title":"Add very long content tests for SearchEngine","description":"Add tests for large content handling in search-engine.test.ts:\n- Note with content \u003e 1000 chars (current indexing limit)\n- Note with content \u003e 5000 chars (context extraction limit)\n- Snippet generation for match beyond indexed content\n- Search performance with many large notes\n- Memory behavior (ensure large notes don't bloat index)\n- fullText storage vs indexed content truncation\n- Match found in truncated portion (should still return note?)\n\nCurrent tests use short content strings only.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:01:34.727792-06:00","updated_at":"2025-12-13T00:40:56.291368-06:00","closed_at":"2025-12-13T00:40:56.291368-06:00","dependencies":[{"issue_id":"scribe-ms1","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:01:37.574198-06:00","created_by":"daemon"}]}
{"id":"scribe-ncq","title":"Use discriminated unions for Note type-specific data","description":"**Problem**: The `Note` interface (types.ts:186-202) uses optional fields that allow invalid state:\n```typescript\ndaily?: { date: string };\nmeeting?: { date: string; dailyNoteId: NoteId; attendees: NoteId[] };\n```\n\nThis allows:\n- `type: 'daily'` with `meeting` data present (invalid)\n- `type: 'meeting'` with `daily` data present (invalid)\n- `type: undefined` with `daily` or `meeting` data (invalid)\n- `type: 'daily'` with no `daily` data (invalid)\n\n**Solution**: Use discriminated unions to make invalid states unrepresentable:\n```typescript\ntype Note = BaseNote \u0026 (\n  | { type?: undefined }\n  | { type: 'person' }\n  | { type: 'project' }\n  | { type: 'template' }\n  | { type: 'daily'; daily: { date: string } }\n  | { type: 'meeting'; meeting: { date: string; dailyNoteId: NoteId; attendees: NoteId[] } }\n);\n```\n\n**Files**: packages/shared/src/types.ts\n**Impact**: Compiler prevents impossible states, simplifies validation","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:00:54.961156-06:00","updated_at":"2025-12-12T23:14:11.77357-06:00","closed_at":"2025-12-12T23:14:11.77357-06:00","dependencies":[{"issue_id":"scribe-ncq","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:00:58.145392-06:00","created_by":"daemon"},{"issue_id":"scribe-ncq","depends_on_id":"scribe-9st","type":"related","created_at":"2025-12-12T21:42:15.653838-06:00","created_by":"daemon"}]}
{"id":"scribe-njf","title":"Create useErrorHandler.ts hook file","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:54:34.83668-06:00","updated_at":"2025-12-12T21:55:58.815284-06:00","closed_at":"2025-12-12T21:55:58.815284-06:00","dependencies":[{"issue_id":"scribe-njf","depends_on_id":"scribe-5es","type":"discovered-from","created_at":"2025-12-12T21:54:34.837184-06:00","created_by":"daemon"}]}
{"id":"scribe-nwu","title":"Add unit tests for text-extraction.ts","description":"Create text-extraction.test.ts with tests for:\n- extractTextForSearch(): empty content, nested nodes, various node types\n- extractTextWithContext(): maxLength parameter, truncation behavior\n- generateSnippet(): edge cases (match at start/end, ellipsis handling)\n- traverseNodes(): deep nesting, empty children arrays\n\nCurrent state: No dedicated test file exists. Functions are only indirectly tested via search-engine.test.ts.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:00:39.960087-06:00","updated_at":"2025-12-12T21:43:17.427752-06:00","closed_at":"2025-12-12T21:43:17.427752-06:00","dependencies":[{"issue_id":"scribe-nwu","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:00:43.641246-06:00","created_by":"daemon"},{"issue_id":"scribe-nwu","depends_on_id":"scribe-lgy","type":"related","created_at":"2025-12-12T21:42:24.564078-06:00","created_by":"daemon"}]}
{"id":"scribe-o3s","title":"Add accessibility attributes to Input, ListItem, and Button primitives","description":"Several design system primitives are missing accessibility attributes:\n\n## Input (packages/design-system/src/primitives/Input/Input.tsx)\n- Missing `aria-invalid={error}` binding to the error prop\n- No built-in label association (consider `aria-label` or `id` prop pattern)\n- Should pass `aria-describedby` for error message association\n\n## ListItem (packages/design-system/src/primitives/List/ListItem.tsx)\n- Missing `tabIndex={disabled ? -1 : 0}` for keyboard focus\n- No keyboard navigation handlers (Enter/Space to select)\n- Note: Already has `role=\"option\"`, `aria-selected`, `aria-disabled` - good!\n\n## Button (packages/design-system/src/primitives/Button/Button.tsx)\n- Missing `aria-disabled` when disabled (native disabled works but aria helps AT)\n- No loading state support (`aria-busy`, spinner, disabled interaction)\n- Consider `aria-pressed` for toggle buttons\n\n**Implementation notes:**\n- Input: Add `aria-invalid={error}` to the input element (line 28-32)\n- ListItem: Add `tabIndex` and `onKeyDown` handler for Enter/Space\n- Button: Add optional `loading` prop with `aria-busy` and visual indicator\n\n**Files:**\n- packages/design-system/src/primitives/Input/Input.tsx\n- packages/design-system/src/primitives/List/ListItem.tsx\n- packages/design-system/src/primitives/Button/Button.tsx","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:00:22.7241-06:00","updated_at":"2025-12-12T22:40:06.301667-06:00","closed_at":"2025-12-12T22:40:06.301667-06:00","dependencies":[{"issue_id":"scribe-o3s","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:00:27.614497-06:00","created_by":"daemon"}]}
{"id":"scribe-oua","title":"Remove unused useTaskSubscription hook","description":"The useTaskSubscription hook is exported but never imported or used anywhere in the codebase.\n\n**Evidence:**\n- Defined in apps/desktop/renderer/src/hooks/useTaskSubscription.ts (120 lines)\n- Exported from the hooks directory\n- Zero imports found in any other file\n\n**Options:**\n1. Delete the hook if no longer needed\n2. Integrate it where it was intended to be used\n3. Document why it exists for future use\n\n**Files:**\n- apps/desktop/renderer/src/hooks/useTaskSubscription.ts","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:19:27.905213-06:00","updated_at":"2025-12-13T00:40:11.142697-06:00","closed_at":"2025-12-13T00:40:11.142697-06:00","dependencies":[{"issue_id":"scribe-oua","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:20:26.782396-06:00","created_by":"daemon"}]}
{"id":"scribe-rmk","title":"Add tests for TableUIPlugin","description":"TableUIPlugin.tsx (416 lines) has NO dedicated tests despite complex table UI logic.\n\n**Functions needing tests:**\n- Table hover detection\n- Row/column controls rendering\n- Row/column add/delete operations\n- Context menu handling\n- Drag-to-resize functionality (if present)\n\n**Note:** Some table tests exist in TablePlugin.test.tsx and TableKeyboardPlugin.test.tsx, but TableUIPlugin-specific functionality is not tested.\n\n**Files:**\n- apps/desktop/renderer/src/components/Editor/plugins/TableUIPlugin.tsx","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:27:17.191509-06:00","updated_at":"2025-12-12T23:59:44.708453-06:00","closed_at":"2025-12-12T23:59:44.708453-06:00","dependencies":[{"issue_id":"scribe-rmk","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:27:20.931744-06:00","created_by":"daemon"}]}
{"id":"scribe-rwj","title":"Extract FloatingMenu primitive to design system from autocomplete CSS","description":"Three autocomplete-style components have nearly identical CSS (~150 lines duplicated):\n\n**Duplicated Files:**\n- WikiLinkAutocomplete.css.ts\n- PersonMentionAutocomplete.css.ts\n- SlashMenu.css.ts\n\n**Duplicated Styles:**\n1. Container/dropdown: position, zIndex, minWidth, maxWidth, maxHeight, overflow, backgroundColor, borderRadius, boxShadow, border, animation\n2. Item styles: display: flex, alignItems, gap, padding, cursor, transition, hover state\n3. itemSelected/itemIcon/itemText patterns\n\n**Solution:**\nExtract to design system:\n```typescript\n// packages/design-system/src/primitives/FloatingMenu/\nexport const floatingMenuContainer = style({ ... });\nexport const floatingMenuItem = style({ ... });\nexport const floatingMenuItemSelected = style({ ... });\n```\n\n**Estimated savings:** ~150 lines","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:18:27.199004-06:00","updated_at":"2025-12-12T23:25:36.22515-06:00","closed_at":"2025-12-12T23:25:36.22515-06:00","dependencies":[{"issue_id":"scribe-rwj","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:20:25.135171-06:00","created_by":"daemon"},{"issue_id":"scribe-rwj","depends_on_id":"scribe-69x","type":"related","created_at":"2025-12-12T21:42:11.499173-06:00","created_by":"daemon"}]}
{"id":"scribe-rzh","title":"Add JSDoc documentation to packages/shared/src/types.ts","description":"types.ts (442 lines) is the foundational types file but lacks comprehensive documentation.\n\n**Needs documentation:**\n\n**Core Types:**\n- NoteId, VaultPath - branded type aliases with no explanation\n- LexicalState (lines 44-58) - inner `root` object properties minimally documented\n- LexicalNode (lines 63-67) - generic catch-all with `[key: string]: unknown`\n\n**Data Types:**\n- GraphNode (lines 207-218) - when `title` can be null, what `tags` contains\n- GraphEdge (lines 223-227) - edge semantics, what 'tag' edge means\n- SearchResult (lines 232-241) - snippet length, score range, positions meaning\n\n**Utility Functions:**\n- serializeTaskId, parseTaskId, isSystemNoteId - no JSDoc\n\n**Impact:** This is the foundation for all other packages. Well-documented types prevent bugs.\n\n**Files:**\n- packages/shared/src/types.ts","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:19:55.168311-06:00","updated_at":"2025-12-12T23:36:31.425405-06:00","closed_at":"2025-12-12T23:36:31.425405-06:00","dependencies":[{"issue_id":"scribe-rzh","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:20:24.913483-06:00","created_by":"daemon"}]}
{"id":"scribe-s0u","title":"Add ARIA dialog attributes to Overlay component","description":"The Overlay component (packages/design-system/src/primitives/Overlay/Overlay.tsx) is missing critical accessibility attributes for modal dialogs:\n\n**Missing attributes:**\n- `role=\"dialog\"` on the content container\n- `aria-modal=\"true\"` to indicate modal behavior\n- `aria-labelledby` prop to reference dialog title\n- `aria-describedby` prop to reference dialog description\n\n**Implementation notes:**\n- Add optional `ariaLabelledby` and `ariaDescribedby` props to OverlayProps\n- Apply `role=\"dialog\"` and `aria-modal=\"true\"` to the content div (line 83)\n- Consider adding focus trap functionality as a follow-up\n- The component already handles Escape key and scroll lock correctly\n\n**Files:** packages/design-system/src/primitives/Overlay/Overlay.tsx","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:00:13.7379-06:00","updated_at":"2025-12-12T21:59:16.181013-06:00","closed_at":"2025-12-12T21:59:16.181013-06:00","dependencies":[{"issue_id":"scribe-s0u","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:00:27.018143-06:00","created_by":"daemon"}]}
{"id":"scribe-u9y","title":"Add tests for useNoteState hook","description":"apps/desktop/renderer/src/hooks/useNoteState.ts (337 lines) has NO tests despite being a critical hook.\n\n**What needs testing:**\n- Note CRUD operations (create, read, update, delete)\n- Optimistic updates and rollback on error\n- State transitions (loading, error states)\n- Concurrent operation handling\n- Edge cases (deleting current note, creating duplicate titles)\n\n**Complexity Factors:**\n- Manages IPC communication with main process\n- Has optimistic update patterns\n- Handles error recovery\n- Coordinates with navigation history\n\n**Files:**\n- apps/desktop/renderer/src/hooks/useNoteState.ts","status":"in_progress","priority":2,"issue_type":"task","created_at":"2025-12-12T21:19:06.849933-06:00","updated_at":"2025-12-12T23:15:50.099574-06:00","dependencies":[{"issue_id":"scribe-u9y","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:20:25.079742-06:00","created_by":"daemon"}]}
{"id":"scribe-ugi","title":"Fix any type usage in design system primitives","description":"The design system primitives use 'any' type assertions for ref forwarding:\n\n**Files:**\n- packages/design-system/src/primitives/Text/Text.tsx:51 - `ref={ref as any}`\n- packages/design-system/src/primitives/Surface/Surface.tsx:52 - `ref={ref as any}`\n\n**Both have eslint-disable comments:**\n```typescript\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nref={ref as any}\n```\n\n**Root Cause:**\nThe polymorphic component pattern (using `as` prop) makes TypeScript's ref typing complex.\n\n**Solution:**\n1. Use proper generic typing for polymorphic refs\n2. Or use a type-safe ref forwarding pattern like:\n```typescript\ntype PolymorphicRef\u003cC extends ElementType\u003e = \n  ComponentPropsWithRef\u003cC\u003e['ref'];\n```\n\n**Impact:** Improves type safety in design system, removes eslint-disable comments","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:26:16.593092-06:00","updated_at":"2025-12-12T23:46:28.179566-06:00","closed_at":"2025-12-12T23:46:28.179566-06:00","dependencies":[{"issue_id":"scribe-ugi","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:26:45.262895-06:00","created_by":"daemon"}]}
{"id":"scribe-uqw","title":"Document SearchEngine configuration and query syntax","description":"SearchEngine lacks documentation for its configuration and query capabilities.\n\n**Needs documentation:**\n\n**Constructor (lines 31-54):**\n- FlexSearch configuration options are unexplained:\n  - Why `tokenize: 'forward'`?\n  - What do `resolution: 9` and `depth: 2` mean?\n  - Why is `bidirectional: true`?\n\n**search method (lines 126-182):**\n- Query syntax (what operators are supported?)\n- Empty result behavior\n- Performance characteristics\n\n**getFieldWeight (lines 220-227):**\n- Magic numbers (10, 5, 1) are undocumented\n- Scoring algorithm explanation\n\n**Result merging (lines 140-175):**\n- How FlexSearch returns grouped results\n- Why merging is necessary\n- Score calculation algorithm\n\n**Files:**\n- packages/engine-search/src/search-engine.ts","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:20:12.998052-06:00","updated_at":"2025-12-13T00:41:18.82629-06:00","closed_at":"2025-12-13T00:41:18.82629-06:00","dependencies":[{"issue_id":"scribe-uqw","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:20:26.514857-06:00","created_by":"daemon"}]}
{"id":"scribe-use","title":"Vault-Eval: CLI Tooling for LLM-Friendly Vault Queries","description":"## Overview\n\nVault-eval provides a CLI layer that transforms Scribe's Lexical JSON notes into structured, machine-readable output optimized for LLM consumption. It builds on existing engine packages (`engine-core`, `engine-search`, `engine-graph`) while exposing deterministic, narrow subcommands with `--json` output.\n\n**Core principle**: Markdown/Lexical is messy; LLMs reason better with structured slices than raw files.\n\n---\n\n## Strategic Context: Why This Matters\n\n### The Problem\n\nScribe stores notes in Lexical JSON format, which is great for rich text editing but challenging for LLM consumption:\n- Lexical AST is nested and verbose\n- Relationships (links, backlinks, mentions) are implicit and scattered\n- Task extraction requires AST traversal\n- No simple way to query \"relevant notes for topic X\"\n\n### The Solution\n\nvault-eval provides a **read-only query layer** that:\n1. Presents vault data as clean JSON structures\n2. Enables hybrid scoring (keywords + recency + link centrality)\n3. Builds token-budgeted context bundles for LLM consumption\n4. Validates vault integrity for trustworthy answers\n\n### Integration Vision\n\n```\nUser Query → LLM → vault-eval → Scribe Vault\n                 ↓\n    \"Search for auth architecture notes\"\n                 ↓\n    vault-eval search -q \"auth architecture\" --json\n                 ↓\n    JSON response with ranked, excerpted notes\n                 ↓\n    LLM incorporates context into response\n```\n\nFuture: MCP server wrapper for direct LLM tool-calling without shell execution.\n\n---\n\n## Goals\n\n1. **Retrieval**: Surface relevant notes for a given query/topic\n2. **Structure**: Expose note relationships (links, backlinks, tags, mentions)\n3. **Recency**: Track what changed for ongoing work awareness\n4. **Quality**: Validate data integrity for trustworthy answers\n5. **Integration**: JSON output compatible with Copilot/MCP tool-calling\n\n## Non-Goals\n\n- Replace the existing Electron IPC API\n- Provide a GUI or interactive mode\n- Full-text Markdown rendering (notes are Lexical JSON)\n- Real-time watch mode (batch operations only)\n- Write operations (vault-eval is read-only; edits happen in Scribe desktop)\n- Template note rendering\n\n---\n\n## Architecture\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                         vault-eval CLI                          │\n├─────────────────────────────────────────────────────────────────┤\n│  Commands: info | read | search | retrieve | context | outline  │\n│            backlinks | graph | recent | tasks | lint | linkcheck│\n├─────────────────────────────────────────────────────────────────┤\n│                      Query Coordinator                          │\n│  - Loads engines lazily (sync constructor, no async init)       │\n│  - Manages index lifecycle                                      │\n│  - Formats output (JSON/text)                                   │\n├─────────────────────────────────────────────────────────────────┤\n│  @scribe/engine-search  │  @scribe/engine-graph  │  TaskIndex   │\n│  (FlexSearch)           │  (in-memory graph)     │  (JSONL)     │\n├─────────────────────────────────────────────────────────────────┤\n│                    @scribe/storage-fs                           │\n│  FileSystemVault | NoteValidator | QuarantineManager            │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## Complete Bead List (25 active tasks)\n\n### Phase 0: Foundation (CRITICAL PATH - Serial)\n| ID | Title | Priority | Blocks |\n|----|-------|----------|--------|\n| **scribe-use.1** | Package scaffolding | P0 | ALL other tasks |\n\n### Phase 1: Foundation (8 PARALLEL tracks after .1)\n| ID | Title | Priority | Notes |\n|----|-------|----------|-------|\n| **scribe-use.2** | CLI argument parser | P0 | Enables all commands |\n| **scribe-use.3** | EngineLoader | P0 | Lazy engine init |\n| **scribe-use.4** | JSON/text formatters | P1 | Output layer |\n| **scribe-use.18** | extractHeadings utility | P1 | AST traversal |\n| **scribe-use.19** | extractLinkContext utility | P1 | Link context extraction |\n| **scribe-use.20** | depthLimitedTraversal utility | P1 | Graph BFS |\n| **scribe-use.22** | hybridScore utility | P1 | Multi-signal scoring |\n| **scribe-use.23** | Test fixture vault | P1 | Integration testing |\n\n### Phase 2: Basic Commands (5 PARALLEL after .2, .3, .4)\n| ID | Title | Priority | Notes |\n|----|-------|----------|-------|\n| **scribe-use.5** | `vault info` | P1 | Vault overview |\n| **scribe-use.6** | `vault read` | P1 | Single note retrieval |\n| **scribe-use.7** | `vault search` | P1 | FlexSearch wrapper |\n| **scribe-use.8** | `vault recent` | P1 | Recently modified |\n| **scribe-use.14** | `vault tasks` | P1 | Task queries |\n\n### Phase 2.5: Utility Chain\n| ID | Title | Priority | Notes |\n|----|-------|----------|-------|\n| **scribe-use.21** | extractRelevantExcerpt | P1 | Needs .18 first |\n\n### Phase 3: Advanced Commands\n| ID | Title | Priority | Notes |\n|----|-------|----------|-------|\n| **scribe-use.9** | `vault retrieve` | P1 | Hybrid scoring (needs .7, .22) |\n| **scribe-use.10** | `vault context` | P1 | LLM context bundle (needs .9, .18, .21) |\n| **scribe-use.11** | `vault outline` | P1 | Note structure (needs .6, .18) |\n| **scribe-use.12** | `vault backlinks` | P1 | Backlink analysis (needs .3, .19) |\n| **scribe-use.13** | `vault graph` | P1 | Graph export (needs .3, .20) |\n\n### Phase 4: Quality \u0026 Polish\n| ID | Title | Priority | Notes |\n|----|-------|----------|-------|\n| **scribe-use.26** | `vault lint` | P2 | Data validation |\n| **scribe-use.27** | `vault linkcheck` | P2 | Broken links (needs .19) |\n| **scribe-use.28** | Configuration file | P2 | Config precedence |\n| **scribe-use.29** | Integration tests | P2 | Needs all commands + .23 |\n| **scribe-use.30** | Binary build pipeline | P2 | Cross-platform builds |\n\n---\n\n## Optimal Parallelization Strategy\n\n```\nPhase 0 (Serial): scribe-use.1 (scaffolding) - MUST complete first\n                  │\n                  ▼\nPhase 1 (Foundation) - 8 PARALLEL TRACKS:\n├── Track A: scribe-use.2 (CLI parser)\n├── Track B: scribe-use.3 (EngineLoader) \n├── Track C: scribe-use.4 (formatters)\n├── Track D: scribe-use.18 (extractHeadings) → scribe-use.21 (excerpts)\n├── Track E: scribe-use.19 (extractLinkContext)\n├── Track F: scribe-use.20 (depthLimitedTraversal)\n├── Track G: scribe-use.22 (hybridScore)\n└── Track H: scribe-use.23 (test fixtures)\n                  │\n                  ▼\nPhase 2 (Commands) - After tracks A+B+C complete:\n├── scribe-use.5 (info)     ─┐\n├── scribe-use.6 (read)     ─┤ 5 PARALLEL\n├── scribe-use.7 (search)   ─┤\n├── scribe-use.8 (recent)   ─┤\n└── scribe-use.14 (tasks)   ─┘\n                  │\n                  ▼\nPhase 3 (Advanced) - After Phase 2 + utilities:\n├── scribe-use.9 (retrieve) ← needs .7 + .22\n├── scribe-use.11 (outline) ← needs .6 + .18\n├── scribe-use.12 (backlinks) ← needs .19\n└── scribe-use.13 (graph) ← needs .20\n                  │\n                  ▼\nPhase 3.5 (Context - Highest Complexity):\n└── scribe-use.10 (context) ← needs .9, .18, .21\n                  │\n                  ▼\nPhase 4 (Quality \u0026 Polish):\n├── scribe-use.26 (lint)        ─┐\n├── scribe-use.27 (linkcheck)   ─┤ 3 PARALLEL\n└── scribe-use.28 (config)      ─┘\n                  │\n                  ▼\n├── scribe-use.29 (integration tests) ← needs all commands + .23\n└── scribe-use.30 (binary builds) ← needs .29\n```\n\n**Critical path**: .1 → .2+.3+.4 → .7 → .9 → .10\n\n---\n\n## Key Technical Notes\n\n### Existing Infrastructure to USE\n- `@scribe/shared`: `traverseNodes`, `extractTextFromNode`, `findNodeByKey`\n- `@scribe/engine-core`: `extractTasksFromNote`, `computeTextHash`\n- `@scribe/engine-search`: `SearchEngine`\n- `@scribe/engine-graph`: `GraphEngine`\n- `@scribe/storage-fs`: `FileSystemVault`\n\n### TaskIndex Import Pattern\nTaskIndex MUST be imported from internal path (not barrel export):\n```typescript\nconst { TaskIndex } = await import('@scribe/engine-core/src/task-index.js');\nconst { JsonlTaskPersistence } = await import('@scribe/engine-core/src/task-persistence.js');\n```\n\n### Wiki-Link Node Structure (VERIFIED)\n```typescript\ninterface WikiLinkNode {\n  type: 'wiki-link';\n  targetId: string | null;  // Use THIS for matching\n  noteTitle: string;\n  displayText: string;\n  version: number;\n}\n```\n\n---\n\n## Success Metrics\n\n1. **Query latency**: \u003c500ms for search/retrieve on 500-note vault\n2. **Context quality**: LLM answers reference correct notes 90%+ of the time\n3. **Coverage**: All note types and link formats handled\n4. **Reliability**: Zero data loss, graceful error handling\n\n---\n\n## Estimated Total Time\n\n- Phase 0+1 (Foundation): 12-16 hours\n- Phase 2 (Basic Commands): 10-12 hours\n- Phase 3 (Advanced): 12-16 hours\n- Phase 4 (Quality): 12-16 hours\n\n**Total**: 45-60 hours (1-2 weeks with parallelization)\n\n---\n\n## Reference Documentation\n\nSee `features/vault-eval/spec.md` for complete technical specification including:\n- Detailed command specifications with JSON output schemas\n- Error handling and exit codes\n- Scoring algorithm details\n- Excerpt extraction strategies\n- Build and distribution details","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-14T00:21:34.169743-06:00","updated_at":"2025-12-15T21:23:56.507311-06:00","closed_at":"2025-12-15T21:23:56.507311-06:00"}
{"id":"scribe-use.1","title":"Set up vault-eval package scaffolding","description":"## Overview\n\nCreate the basic package structure for vault-eval CLI under `packages/vault-eval/`.\n\n---\n\n## Why This Task is Critical\n\nThis task is the **CRITICAL PATH BLOCKER** for the entire vault-eval epic. All 24 other tasks depend on this scaffolding being in place first. The package structure establishes:\n\n1. **Build system integration**: Package.json, tsconfig, vitest config\n2. **Directory conventions**: Where commands, utilities, formatters, and tests live\n3. **Dependency declarations**: Workspace dependencies on existing @scribe/* packages\n4. **Stub files**: Empty exports that prevent import errors during parallel development\n\nWithout this, no other task can begin because there's nowhere to put the code.\n\n---\n\n## Prerequisites\n\nBefore starting, familiarize yourself with existing packages:\n- `@scribe/shared` - Types, utilities, error classes\n- `@scribe/engine-core` - Metadata extraction, task extraction\n- `@scribe/engine-search` - FlexSearch wrapper\n- `@scribe/engine-graph` - In-memory link graph\n- `@scribe/storage-fs` - FileSystemVault, note validation\n\n---\n\n## Tasks\n\n### 1. Create package.json\n```json\n{\n  \"name\": \"@scribe/vault-eval\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"type\": \"module\",\n  \"bin\": { \"vault-eval\": \"./src/cli.ts\" },\n  \"scripts\": {\n    \"dev\": \"bun run src/cli.ts\",\n    \"build\": \"bun build src/cli.ts --compile --minify --target=bun-darwin-arm64 --outfile dist/vault-eval-darwin-arm64\",\n    \"build:all\": \"bun run build:darwin-arm64 \u0026\u0026 bun run build:darwin-x64 \u0026\u0026 bun run build:linux-x64 \u0026\u0026 bun run build:windows-x64\",\n    \"build:darwin-arm64\": \"bun build src/cli.ts --compile --minify --target=bun-darwin-arm64 --outfile dist/vault-eval-darwin-arm64\",\n    \"build:darwin-x64\": \"bun build src/cli.ts --compile --minify --target=bun-darwin-x64 --outfile dist/vault-eval-darwin-x64\",\n    \"build:linux-x64\": \"bun build src/cli.ts --compile --minify --target=bun-linux-x64 --outfile dist/vault-eval-linux-x64\",\n    \"build:windows-x64\": \"bun build src/cli.ts --compile --minify --target=bun-windows-x64 --outfile dist/vault-eval-windows-x64.exe\",\n    \"test\": \"vitest run\",\n    \"lint\": \"eslint .\"\n  },\n  \"dependencies\": {\n    \"@scribe/shared\": \"workspace:*\",\n    \"@scribe/engine-core\": \"workspace:*\",\n    \"@scribe/engine-search\": \"workspace:*\",\n    \"@scribe/engine-graph\": \"workspace:*\",\n    \"@scribe/storage-fs\": \"workspace:*\"\n  },\n  \"devDependencies\": {\n    \"@scribe/eslint-config\": \"workspace:*\",\n    \"@scribe/tsconfig\": \"workspace:*\",\n    \"vitest\": \"^2.1.0\"\n  }\n}\n```\n\n### 2. Create directory structure\n```\npackages/vault-eval/\n  src/\n    cli.ts              # Entry point, command router\n    args.ts             # Argument parser (no framework)\n    types.ts            # CLI-specific types\n    index.ts            # Barrel export\n    commands/           # Command implementations\n      index.ts          # Re-exports all commands\n      info.ts\n      read.ts\n      search.ts\n      recent.ts\n      retrieve.ts\n      context.ts\n      outline.ts\n      backlinks.ts\n      graph.ts\n      tasks.ts\n      lint.ts\n      linkcheck.ts\n    scoring/            # Multi-signal scoring\n      index.ts\n      hybrid.ts\n      recency.ts\n    formatters/         # JSON/text output\n      index.ts\n      json.ts\n      text.ts\n    utils/              # Shared utilities\n      index.ts\n      headings.ts       # extractHeadings\n      excerpts.ts       # extractRelevantExcerpt, extractLinkContext\n      traversal.ts      # depthLimitedTraversal\n      tokens.ts         # estimateTokens\n    index/              # Engine loader\n      loader.ts\n  tests/\n    fixtures/           # Test vault (see scribe-use.23)\n    unit/               # Unit tests\n    integration/        # Integration tests\n  eslint.config.js\n  package.json\n  tsconfig.json\n  vitest.config.ts\n```\n\n### 3. Create tsconfig.json\nExtend from `config/tsconfig/node.json`:\n```json\n{\n  \"extends\": \"@scribe/tsconfig/node.json\",\n  \"compilerOptions\": {\n    \"rootDir\": \"./src\",\n    \"outDir\": \"./dist\"\n  },\n  \"include\": [\"src/**/*.ts\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n```\n\n### 4. Create vitest.config.ts\n```typescript\nimport { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    environment: 'node',\n    include: ['src/**/*.test.ts', 'tests/**/*.test.ts'],\n    coverage: {\n      reporter: ['text', 'json', 'html'],\n    },\n  },\n});\n```\n\n### 5. Create eslint.config.js\n```javascript\nimport baseConfig from '@scribe/eslint-config';\nexport default [...baseConfig];\n```\n\n### 6. Update root turbo.json\nAdd vault-eval to build pipeline if not auto-detected.\n\n### 7. Create minimal stub files\nEach directory needs an `index.ts` with placeholder exports:\n```typescript\n// commands/index.ts\nexport * from './info.js';\nexport * from './read.js';\n// ... etc (can be empty initially)\n```\n\n### 8. Create minimal cli.ts stub\n```typescript\n#!/usr/bin/env bun\nconsole.log('vault-eval CLI - version 0.1.0');\nconsole.log('Usage: vault-eval \u003ccommand\u003e [options]');\nconsole.log('Run vault-eval --help for available commands.');\nprocess.exit(0);\n```\n\n---\n\n## Exit Criteria\n\n- [ ] `bun run src/cli.ts --help` runs without errors (stub output)\n- [ ] `bun install` from workspace root succeeds\n- [ ] `bun run lint` passes (may have no files to lint yet)\n- [ ] `bun run test` runs (even with 0 tests)\n- [ ] Package appears in `turbo.json` pipelines\n- [ ] All directory index.ts files exist (can be empty exports)\n\n---\n\n## Design Decisions \u0026 Rationale\n\n### No CLI Framework\nWe intentionally avoid CLI frameworks like Commander.js or Yargs to:\n- Keep the compiled binary small (~50-70MB with Bun runtime)\n- Avoid framework compatibility issues with Bun compilation\n- Have full control over help text and error messages\n\n### Bun.argv-based Parsing\nHand-rolled argument parser because:\n- Simple flag parsing is sufficient\n- No complex subcommand nesting needed\n- Full control over behavior\n\n### Directory Structure\nOrganized by function:\n- `commands/` - One file per CLI command\n- `utils/` - Reusable utilities shared across commands\n- `scoring/` - Hybrid scoring algorithm components\n- `formatters/` - Output formatting (JSON, text)\n- `index/` - Engine loading/caching\n\n---\n\n## Parallelization\n\nThis task is **NOT parallelizable**. It must complete before ANY other vault-eval task begins.\n\nAfter completion, 8 tasks can start in parallel:\n- scribe-use.2 (CLI parser)\n- scribe-use.3 (EngineLoader)\n- scribe-use.4 (formatters)\n- scribe-use.18-23 (utilities and fixtures)\n\n---\n\n## Estimated Time\n\n1-2 hours\n\n---\n\n## Reference\n\nSee `features/vault-eval/spec.md` sections:\n- CLI Framework\n- Package Structure\n- Appendix B: Build \u0026 Distribution","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-14T00:21:46.648431-06:00","updated_at":"2025-12-15T20:43:54.104041-06:00","closed_at":"2025-12-15T20:43:54.104041-06:00","dependencies":[{"issue_id":"scribe-use.1","depends_on_id":"scribe-use","type":"parent-child","created_at":"2025-12-14T00:21:46.648796-06:00","created_by":"daemon"}]}
{"id":"scribe-use.10","title":"Implement `vault context` command for LLM context assembly","description":"## Overview\n\nImplement the `vault context` command that creates a prioritized excerpt bundle optimized for LLM context windows.\n\n## Command Specification\n\n```bash\nvault context --query \"API error handling\" --max-tokens 6000 --json\nvault context -q \"user permissions\" --include-backlinks --json\n```\n\n### Options\n| Flag | Type | Default | Description |\n|------|------|---------|-------------|\n| `--query, -q` | string | required | Topic query |\n| `--max-tokens` | number | 4000 | Token budget (~4 chars/token) |\n| `--max-notes` | number | 10 | Max notes to include |\n| `--include-backlinks` | boolean | false | Include backlink context |\n| `--include-tasks` | boolean | false | Include related tasks |\n| `--depth` | number | 1 | Link traversal depth |\n| `--json` | boolean | false | JSON output |\n\n### JSON Output\n```json\n{\n  \"query\": \"API error handling\",\n  \"tokenBudget\": 6000,\n  \"tokensUsed\": 5432,\n  \"notes\": [\n    {\n      \"id\": \"ghi789\",\n      \"title\": \"Error Handling Strategy\",\n      \"relevance\": 0.92,\n      \"excerpt\": \"## Error Codes\\n\\nWe use a hierarchical error code system...\",\n      \"excerptTokens\": 850,\n      \"fullPath\": \"notes/ghi789.json\",\n      \"tags\": [\"api\", \"errors\", \"architecture\"]\n    }\n  ],\n  \"relatedBacklinks\": [\n    {\n      \"id\": \"jkl012\",\n      \"title\": \"API Gateway Design\",\n      \"linkContext\": \"...delegates to the [[Error Handling Strategy]] for...\"\n    }\n  ],\n  \"summary\": {\n    \"primaryNotes\": 5,\n    \"backlinkNotes\": 3,\n    \"totalExcerpts\": 8\n  }\n}\n```\n\n## Excerpt Extraction Strategy\n\n### Strategy Options\n| Strategy | Description | Use Case |\n|----------|-------------|----------|\n| `full` | Include entire note content | Small notes, high relevance |\n| `heading-bounded` | Extract sections containing query terms | Structured notes with clear headings |\n| `sentence-window` | Extract sentences around query matches | Dense prose without clear structure |\n| `summary` | First paragraph + query-matching sections | Long notes with token budget constraints |\n\n### Algorithm\n1. Retrieve candidates with hybrid scoring (2x max_notes)\n2. For each candidate, extract relevant excerpt based on strategy\n3. Greedy selection within token budget (highest relevance first)\n4. Re-sort by document order for coherent reading\n5. If --include-backlinks, add backlink context\n\n## Implementation Details\n\n- Use extractRelevantExcerpt() utility\n- Use extractHeadings() for section boundaries\n- Use estimateTokens() for budget tracking\n- Use extractLinkContext() for backlink excerpts\n\n## Exit Criteria\n\n- Returns context bundle within token budget\n- Excerpts are relevant to query\n- Token estimation is reasonably accurate\n- Backlink context is included when requested\n- Works with unstructured notes (fallback strategy)\n\n## Dependencies\n\n- Requires: scribe-use.1-4, scribe-use.9 (retrieve)\n- Requires: extractHeadings, extractRelevantExcerpt, estimateTokens utilities\n\n## Phase\n\nPhase 2 - Retrieval \u0026 Context\n\n## Risk\n\nMedium-High: Excerpt extraction strategy requires tuning","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-14T00:24:01.991789-06:00","updated_at":"2025-12-15T21:08:59.505468-06:00","closed_at":"2025-12-15T21:08:59.505468-06:00","dependencies":[{"issue_id":"scribe-use.10","depends_on_id":"scribe-use","type":"parent-child","created_at":"2025-12-14T00:24:01.992172-06:00","created_by":"daemon"},{"issue_id":"scribe-use.10","depends_on_id":"scribe-use.9","type":"blocks","created_at":"2025-12-14T00:34:13.759044-06:00","created_by":"daemon"},{"issue_id":"scribe-use.10","depends_on_id":"scribe-use.18","type":"blocks","created_at":"2025-12-14T00:34:13.810895-06:00","created_by":"daemon"},{"issue_id":"scribe-use.10","depends_on_id":"scribe-use.21","type":"blocks","created_at":"2025-12-14T00:34:13.861351-06:00","created_by":"daemon"}]}
{"id":"scribe-use.11","title":"Implement `vault outline` command","description":"## Overview\n\nImplement the `vault outline` command that extracts heading tree and structural anchors from a note.\n\n## Command Specification\n\n```bash\nvault outline notes/abc123.json --json\nvault outline --id abc123 --include-tasks --json\n```\n\n### Options\n| Flag | Type | Default | Description |\n|------|------|---------|-------------|\n| `--id` | string | - | Note ID |\n| `\u003cpath\u003e` | string | - | Note file path |\n| `--include-tasks` | boolean | false | Include task items |\n| `--include-links` | boolean | false | Include outgoing links |\n| `--json` | boolean | false | JSON output |\n\n### JSON Output\n```json\n{\n  \"id\": \"abc123\",\n  \"title\": \"Project Alpha Kickoff\",\n  \"type\": \"meeting\",\n  \"headings\": [\n    {\n      \"level\": 1,\n      \"text\": \"Agenda\",\n      \"anchor\": \"agenda\",\n      \"children\": [\n        { \"level\": 2, \"text\": \"Goals\", \"anchor\": \"goals\", \"children\": [] },\n        { \"level\": 2, \"text\": \"Timeline\", \"anchor\": \"timeline\", \"children\": [] }\n      ]\n    },\n    {\n      \"level\": 1,\n      \"text\": \"Action Items\",\n      \"anchor\": \"action-items\",\n      \"children\": []\n    }\n  ],\n  \"tasks\": [\n    { \"id\": \"abc123:node_5x7y:f1e2d3c4b5a6\", \"text\": \"Draft project charter\", \"completed\": false, \"priority\": 0 }\n  ],\n  \"outgoingLinks\": [\n    { \"targetId\": \"def456\", \"targetTitle\": \"Project Alpha\", \"context\": \"...\" }\n  ],\n  \"wordCount\": 1250,\n  \"lastUpdated\": \"2025-01-15T10:30:00Z\"\n}\n```\n\n## Heading Extraction Implementation\n\nLexical heading nodes use a `tag` property to indicate level:\n\n```typescript\ninterface HeadingNode extends EditorNode {\n  type: 'heading';\n  tag: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';\n  children: EditorNode[];  // Text nodes\n}\n\ninterface Heading {\n  level: number;      // 1-6\n  text: string;       // Heading text content\n  anchor: string;     // URL-safe slug\n  children: Heading[];\n}\n\nfunction extractHeadings(content: EditorContent): Heading[] {\n  // Traverse for type: 'heading' nodes\n  // Build tree structure based on heading levels\n  // Generate slugified anchors\n}\n```\n\n## Exit Criteria\n\n- Heading tree is correctly nested\n- Anchors are URL-safe slugs\n- Tasks are extracted when --include-tasks\n- Links include context when --include-links\n- Works with empty notes (no headings)\n\n## Dependencies\n\n- Requires: scribe-use.1-4\n- Requires: extractHeadings utility\n\n## Phase\n\nPhase 2 - Retrieval \u0026 Context","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-14T00:24:16.056565-06:00","updated_at":"2025-12-15T21:02:48.858844-06:00","closed_at":"2025-12-15T21:02:48.858844-06:00","dependencies":[{"issue_id":"scribe-use.11","depends_on_id":"scribe-use","type":"parent-child","created_at":"2025-12-14T00:24:16.056944-06:00","created_by":"daemon"},{"issue_id":"scribe-use.11","depends_on_id":"scribe-use.6","type":"blocks","created_at":"2025-12-14T00:34:17.681466-06:00","created_by":"daemon"},{"issue_id":"scribe-use.11","depends_on_id":"scribe-use.18","type":"blocks","created_at":"2025-12-14T00:34:17.731615-06:00","created_by":"daemon"}]}
{"id":"scribe-use.12","title":"Implement `vault backlinks` command","description":"## Overview\n\nImplement the `vault backlinks` command that shows all notes linking to a target with surrounding context.\n\n## Command Specification\n\n```bash\nvault backlinks --id abc123 --json\nvault backlinks --id abc123 --context-chars 200 --json\n```\n\n### Options\n| Flag | Type | Default | Description |\n|------|------|---------|-------------|\n| `--id` | string | required | Target note ID |\n| `--context-chars` | number | 100 | Characters around link |\n| `--group-by` | string | - | Group by: tag, type, date |\n| `--json` | boolean | false | JSON output |\n\n### JSON Output\n```json\n{\n  \"targetId\": \"abc123\",\n  \"targetTitle\": \"Error Handling Strategy\",\n  \"backlinkCount\": 5,\n  \"backlinks\": [\n    {\n      \"sourceId\": \"mno345\",\n      \"sourceTitle\": \"API Gateway Design\",\n      \"sourceType\": \"regular\",\n      \"linkContext\": \"...the gateway delegates error formatting to [[Error Handling Strategy]] before returning...\",\n      \"linkPosition\": { \"paragraph\": 3 },\n      \"sourceUpdatedAt\": \"2025-01-14T09:00:00Z\"\n    }\n  ],\n  \"groupedBy\": null\n}\n```\n\n## Implementation Details\n\n1. Parse required `--id` flag\n2. Get backlinks from `graphEngine.backlinks(noteId)`\n3. For each backlink source note:\n   - Load note content\n   - Use extractLinkContext() to get surrounding text\n   - Include source metadata\n4. Optionally group by tag/type/date\n\n### extractLinkContext Implementation\n```typescript\nfunction extractLinkContext(\n  content: EditorContent,\n  targetNoteId: NoteId,\n  contextChars: number = 100\n): string | null {\n  // Find wiki-link nodes pointing to target\n  // Extract paragraph text around the link\n  // Add ellipsis if truncated\n}\n```\n\n## Exit Criteria\n\n- Returns all backlinks with context\n- Context extraction works for wiki-links\n- Grouping by tag/type/date works\n- Empty result for notes with no backlinks\n\n## Dependencies\n\n- Requires: scribe-use.1-4\n- Requires: extractLinkContext utility\n\n## Phase\n\nPhase 2 - Retrieval \u0026 Context","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-14T00:24:27.866453-06:00","updated_at":"2025-12-15T21:01:31.830195-06:00","closed_at":"2025-12-15T21:01:31.830195-06:00","dependencies":[{"issue_id":"scribe-use.12","depends_on_id":"scribe-use","type":"parent-child","created_at":"2025-12-14T00:24:27.866853-06:00","created_by":"daemon"},{"issue_id":"scribe-use.12","depends_on_id":"scribe-use.3","type":"blocks","created_at":"2025-12-14T00:34:21.343231-06:00","created_by":"daemon"},{"issue_id":"scribe-use.12","depends_on_id":"scribe-use.19","type":"blocks","created_at":"2025-12-14T00:34:21.394993-06:00","created_by":"daemon"}]}
{"id":"scribe-use.13","title":"Implement `vault graph` command","description":"## Overview\n\nImplement the `vault graph` command that exports a subgraph for visualization or analysis.\n\n## Command Specification\n\n```bash\nvault graph --from abc123 --depth 2 --json\nvault graph --tag architecture --depth 1 --json\nvault graph --query \"auth\" --depth 2 --format dot\n```\n\n### Options\n| Flag | Type | Default | Description |\n|------|------|---------|-------------|\n| `--from` | string | - | Starting note ID |\n| `--tag` | string | - | Starting from tag |\n| `--query` | string | - | Starting from search |\n| `--depth` | number | 2 | Traversal depth |\n| `--direction` | string | both | outgoing, incoming, both |\n| `--format` | string | json | json, dot, mermaid |\n| `--json` | boolean | false | JSON output |\n\n### JSON Output\n```json\n{\n  \"root\": \"abc123\",\n  \"depth\": 2,\n  \"nodes\": [\n    {\n      \"id\": \"abc123\",\n      \"title\": \"Auth Architecture\",\n      \"type\": \"regular\",\n      \"tags\": [\"architecture\", \"auth\"],\n      \"depth\": 0\n    },\n    {\n      \"id\": \"def456\",\n      \"title\": \"OAuth Implementation\",\n      \"type\": \"regular\",\n      \"tags\": [\"auth\", \"oauth\"],\n      \"depth\": 1\n    }\n  ],\n  \"edges\": [\n    { \"source\": \"abc123\", \"target\": \"def456\", \"type\": \"link\" },\n    { \"source\": \"def456\", \"target\": \"abc123\", \"type\": \"backlink\" }\n  ],\n  \"stats\": {\n    \"nodeCount\": 15,\n    \"edgeCount\": 23,\n    \"maxDepthReached\": 2\n  }\n}\n```\n\n## Depth-Limited Traversal Implementation\n\n```typescript\ninterface TraversalResult {\n  nodes: Map\u003cNoteId, { node: GraphNode; depth: number }\u003e;\n  edges: Array\u003c{ source: NoteId; target: NoteId; type: 'link' | 'backlink' }\u003e;\n}\n\nfunction depthLimitedTraversal(\n  graph: GraphEngine,\n  rootId: NoteId,\n  maxDepth: number,\n  direction: 'outgoing' | 'incoming' | 'both' = 'both'\n): TraversalResult {\n  // BFS with direction control\n  // Track visited nodes and edges\n  // Compute outgoing links from neighbors minus backlinks\n}\n```\n\n## Output Formats\n\n- **JSON**: Default structured output\n- **DOT**: GraphViz DOT format for visualization\n- **Mermaid**: Mermaid flowchart syntax\n\n## Exit Criteria\n\n- Traversal respects depth limit\n- Direction filter works (outgoing/incoming/both)\n- All three output formats work\n- Starting from tag/query works\n- Cycles handled correctly (no infinite loops)\n\n## Dependencies\n\n- Requires: scribe-use.1-4\n- Requires: depthLimitedTraversal utility\n\n## Phase\n\nPhase 3 - Graph \u0026 Tasks","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-14T00:24:41.822456-06:00","updated_at":"2025-12-15T21:02:25.485367-06:00","closed_at":"2025-12-15T21:02:25.485367-06:00","dependencies":[{"issue_id":"scribe-use.13","depends_on_id":"scribe-use","type":"parent-child","created_at":"2025-12-14T00:24:41.822844-06:00","created_by":"daemon"},{"issue_id":"scribe-use.13","depends_on_id":"scribe-use.3","type":"blocks","created_at":"2025-12-14T00:34:25.024006-06:00","created_by":"daemon"},{"issue_id":"scribe-use.13","depends_on_id":"scribe-use.20","type":"blocks","created_at":"2025-12-14T00:34:25.072662-06:00","created_by":"daemon"},{"issue_id":"scribe-use.13","depends_on_id":"scribe-use.2","type":"blocks","created_at":"2025-12-14T08:55:35.158925-06:00","created_by":"daemon"}]}
{"id":"scribe-use.14","title":"Implement `vault tasks` command","description":"## Overview\n\nImplement the `vault tasks` command that queries tasks across the vault with filters.\n\n## Command Specification\n\n```bash\nvault tasks --status open --json\nvault tasks --status open --sort priority --limit 20 --json\nvault tasks --completed-after 2025-01-10 --json\nvault tasks --priority-max 1 --json  # High priority only (0 and 1)\n```\n\n### Options\n| Flag | Type | Default | Description |\n|------|------|---------|-------------|\n| `--status` | string | all | open, completed, all |\n| `--note` | string | - | Filter by note ID |\n| `--priority-min` | number | - | Min priority (0=highest). Post-filter |\n| `--priority-max` | number | - | Max priority. Post-filter |\n| `--created-after` | string | - | ISO date |\n| `--completed-after` | string | - | ISO date |\n| `--sort` | string | createdAt | priority, createdAt |\n| `--order` | string | desc | asc, desc |\n| `--limit` | number | 50 | Max results |\n| `--cursor` | string | - | Pagination cursor |\n| `--json` | boolean | false | JSON output |\n\n### JSON Output\n```json\n{\n  \"filter\": { \"status\": \"open\", \"sort\": \"priority\", \"order\": \"asc\" },\n  \"count\": 15,\n  \"nextCursor\": \"eyJvZmZzZXQiOjUwfQ==\",\n  \"tasks\": [\n    {\n      \"id\": \"abc123:node_1a2b:a1b2c3d4e5f6a7b8\",\n      \"text\": \"Review authentication flow\",\n      \"completed\": false,\n      \"priority\": 0,\n      \"noteId\": \"abc123\",\n      \"noteTitle\": \"Auth Architecture\",\n      \"nodeKey\": \"node_1a2b\",\n      \"lineIndex\": 3,\n      \"textHash\": \"a1b2c3d4e5f6a7b8\",\n      \"createdAt\": \"2025-01-14T10:00:00Z\",\n      \"updatedAt\": \"2025-01-14T10:00:00Z\",\n      \"completedAt\": null\n    }\n  ],\n  \"summary\": {\n    \"open\": 15,\n    \"completed\": 42,\n    \"byPriority\": { \"0\": 3, \"1\": 8, \"2\": 4 }\n  }\n}\n```\n\n## Implementation Notes\n\n### Task ID Format\n`{noteId}:{nodeKey}:{textHash}` - matches the actual `Task` type from `@scribe/shared`.\n\n### textHash\nDJB2 hash of task text (16 hex characters), NOT SHA-256.\n\n### Priority\n0 = highest priority (not 1-indexed). Sort order `asc` shows highest priority first.\n\n### Priority Filtering\n**Important**: Priority filtering (`--priority-min`, `--priority-max`) is implemented as POST-query filtering in vault-eval because `TaskFilter` doesn't support priority ranges natively. This means `--limit` is applied AFTER priority filtering.\n\n## Implementation Details\n\n1. Load TaskIndex via EngineLoader\n2. Build TaskFilter from flags (status, noteId, dates)\n3. Call taskIndex.list(filter)\n4. Apply priority post-filtering\n5. Apply sorting\n6. Apply pagination\n\n## Exit Criteria\n\n- Returns tasks matching all filter criteria\n- Priority filtering works correctly (post-filter)\n- Sorting by priority and createdAt works\n- Pagination with cursors works\n- Summary stats are accurate\n\n## Dependencies\n\n- Requires: scribe-use.1-4\n\n## Phase\n\nPhase 3 - Graph \u0026 Tasks","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-14T00:25:00.225646-06:00","updated_at":"2025-12-15T20:54:25.812354-06:00","closed_at":"2025-12-15T20:54:25.812354-06:00","dependencies":[{"issue_id":"scribe-use.14","depends_on_id":"scribe-use","type":"parent-child","created_at":"2025-12-14T00:25:00.22605-06:00","created_by":"daemon"},{"issue_id":"scribe-use.14","depends_on_id":"scribe-use.2","type":"blocks","created_at":"2025-12-14T00:34:02.289505-06:00","created_by":"daemon"},{"issue_id":"scribe-use.14","depends_on_id":"scribe-use.3","type":"blocks","created_at":"2025-12-14T00:34:02.340808-06:00","created_by":"daemon"},{"issue_id":"scribe-use.14","depends_on_id":"scribe-use.4","type":"blocks","created_at":"2025-12-14T00:34:02.388994-06:00","created_by":"daemon"}]}
{"id":"scribe-use.15","title":"Implement `vault lint` command","description":"## Overview\n\nImplement the `vault lint` command that validates vault data integrity and consistency.\n\n## Command Specification\n\n```bash\nvault lint --json\nvault lint --fix --json\nvault lint --checks frontmatter,links --json\nvault lint --include-quarantine --json\n```\n\n### Options\n| Flag | Type | Default | Description |\n|------|------|---------|-------------|\n| `--checks` | string | all | Comma-separated check names |\n| `--fix` | boolean | false | Auto-fix where possible |\n| `--severity` | string | all | error, warning, info |\n| `--include-quarantine` | boolean | false | List quarantined (corrupted) files |\n| `--json` | boolean | false | JSON output |\n\n### Available Checks\n- `frontmatter`: Required fields present (id, title, createdAt, updatedAt)\n- `links`: Internal links resolve to existing notes\n- `tags`: Tags follow naming conventions\n- `dates`: Timestamps are valid\n- `duplicates`: No duplicate note IDs\n- `orphans`: Notes with no links in or out\n- `schema`: Note structure matches type schema\n- `quarantine`: List files that failed to parse (via QuarantineManager)\n\n### JSON Output\n```json\n{\n  \"vaultPath\": \"/path/to/vault\",\n  \"notesScanned\": 150,\n  \"issues\": [\n    {\n      \"severity\": \"error\",\n      \"check\": \"links\",\n      \"noteId\": \"abc123\",\n      \"noteTitle\": \"Project Notes\",\n      \"message\": \"Broken link to non-existent note 'xyz999'\",\n      \"path\": \"notes/abc123.json\",\n      \"fixable\": false\n    },\n    {\n      \"severity\": \"warning\",\n      \"check\": \"orphans\",\n      \"noteId\": \"def456\",\n      \"noteTitle\": \"Random Thoughts\",\n      \"message\": \"Note has no incoming or outgoing links\",\n      \"path\": \"notes/def456.json\",\n      \"fixable\": false\n    }\n  ],\n  \"summary\": {\n    \"errors\": 2,\n    \"warnings\": 5,\n    \"info\": 3,\n    \"fixed\": 0\n  },\n  \"quarantine\": {\n    \"count\": 1,\n    \"files\": [\n      {\n        \"path\": \"notes/corrupted-abc.json\",\n        \"error\": \"Invalid JSON: Unexpected token at position 42\",\n        \"quarantinedAt\": \"2025-01-14T08:00:00Z\"\n      }\n    ]\n  }\n}\n```\n\n## Implementation Details\n\nEach check is implemented as a separate function:\n\n```typescript\ninterface LintCheck {\n  name: string;\n  run(vault: FileSystemVault, graph: GraphEngine): LintIssue[];\n}\n\nconst checks: LintCheck[] = [\n  { name: 'frontmatter', run: checkFrontmatter },\n  { name: 'links', run: checkBrokenLinks },\n  { name: 'tags', run: checkTagNaming },\n  { name: 'dates', run: checkTimestamps },\n  { name: 'duplicates', run: checkDuplicateIds },\n  { name: 'orphans', run: checkOrphanNotes },\n  { name: 'schema', run: checkNoteSchema },\n];\n```\n\n## Exit Criteria\n\n- All check types implemented\n- `--checks` filter works\n- `--severity` filter works\n- `--fix` attempts auto-fixes where possible\n- Quarantine info included when requested\n- Exit code reflects error count\n\n## Dependencies\n\n- Requires: scribe-use.1-4\n\n## Phase\n\nPhase 4 - Quality \u0026 Polish","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-14T00:25:17.128328-06:00","updated_at":"2025-12-15T06:06:00.036406-06:00","closed_at":"2025-12-15T06:06:00.036406-06:00","dependencies":[{"issue_id":"scribe-use.15","depends_on_id":"scribe-use","type":"parent-child","created_at":"2025-12-14T00:25:17.128702-06:00","created_by":"daemon"}]}
{"id":"scribe-use.16","title":"Implement `vault linkcheck` command","description":"## Overview\n\nImplement the `vault linkcheck` command for focused check of broken internal links.\n\n## Command Specification\n\n```bash\nvault linkcheck --json\nvault linkcheck --include-external --json\n```\n\n### Options\n| Flag | Type | Default | Description |\n|------|------|---------|-------------|\n| `--include-external` | boolean | false | Check external URLs |\n| `--timeout` | number | 5000 | External URL timeout (ms) |\n| `--json` | boolean | false | JSON output |\n\n### JSON Output\n```json\n{\n  \"scanned\": {\n    \"notes\": 150,\n    \"internalLinks\": 423,\n    \"externalLinks\": 87\n  },\n  \"broken\": {\n    \"internal\": [\n      {\n        \"sourceId\": \"abc123\",\n        \"sourceTitle\": \"Project Notes\",\n        \"targetId\": \"xyz999\",\n        \"linkText\": \"old design doc\",\n        \"context\": \"...see the [[old design doc]] for details...\"\n      }\n    ],\n    \"external\": []\n  },\n  \"summary\": {\n    \"brokenInternal\": 3,\n    \"brokenExternal\": 0,\n    \"healthy\": 507\n  }\n}\n```\n\n## Implementation Details\n\n1. Load vault and iterate all notes\n2. Extract all wiki-links from content\n3. Check each link target exists in vault\n4. If `--include-external`:\n   - Extract external URLs from content\n   - Make HEAD requests with timeout\n   - Report unreachable URLs\n5. Collect and format results\n\n## Exit Criteria\n\n- Detects all broken internal wiki-links\n- External URL checking works when enabled\n- Timeout prevents hanging on slow URLs\n- Context extraction shows link in context\n- Exit code reflects broken link count\n\n## Dependencies\n\n- Requires: scribe-use.1-4\n- Subset of lint functionality (scribe-use.15)\n\n## Phase\n\nPhase 4 - Quality \u0026 Polish","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-14T00:25:27.77574-06:00","updated_at":"2025-12-15T06:06:00.449629-06:00","closed_at":"2025-12-15T06:06:00.449629-06:00","dependencies":[{"issue_id":"scribe-use.16","depends_on_id":"scribe-use","type":"parent-child","created_at":"2025-12-14T00:25:27.776109-06:00","created_by":"daemon"}]}
{"id":"scribe-use.17","title":"Implement configuration file support","description":"## Overview\n\nImplement configuration file support for vault-eval defaults and scoring weights.\n\n## Configuration File Locations\n\n1. Vault-local: `.vault-eval.json` in vault root\n2. Global: `~/.config/vault-eval/config.json`\n\n### Precedence (highest to lowest)\n1. Command-line flags\n2. Vault-local config\n3. Global config\n4. Built-in defaults\n\n## Configuration Schema\n\n```json\n{\n  \"scoring\": {\n    \"weights\": {\n      \"textMatch\": 0.40,\n      \"titleMatch\": 0.25,\n      \"tagMatch\": 0.15,\n      \"recency\": 0.10,\n      \"linkCentrality\": 0.10\n    },\n    \"recencyHalfLifeDays\": 30\n  },\n  \"context\": {\n    \"defaultTokenBudget\": 4000,\n    \"defaultStrategy\": \"heading-bounded\",\n    \"minContextSentences\": 2\n  },\n  \"output\": {\n    \"defaultFormat\": \"json\",\n    \"prettyPrint\": true\n  }\n}\n```\n\n## Implementation Details\n\n```typescript\ninterface Config {\n  scoring: ScoringConfig;\n  context: ContextConfig;\n  output: OutputConfig;\n}\n\nfunction loadConfig(vaultPath: string): Config {\n  const defaults = getDefaultConfig();\n  \n  // Try global config\n  const globalPath = path.join(os.homedir(), '.config', 'vault-eval', 'config.json');\n  const globalConfig = loadConfigFile(globalPath);\n  \n  // Try vault-local config\n  const localPath = path.join(vaultPath, '.vault-eval.json');\n  const localConfig = loadConfigFile(localPath);\n  \n  // Merge with precedence\n  return deepMerge(defaults, globalConfig, localConfig);\n}\n```\n\n## Exit Criteria\n\n- Config files are loaded from both locations\n- Precedence order is correct\n- Invalid JSON in config shows helpful error\n- Missing config files are silently ignored\n- All commands respect config defaults\n\n## Dependencies\n\n- Requires: scribe-use.1-4\n- Should be done after core commands are working\n\n## Phase\n\nPhase 4 - Quality \u0026 Polish","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-14T00:25:38.8909-06:00","updated_at":"2025-12-15T06:06:01.065608-06:00","closed_at":"2025-12-15T06:06:01.065608-06:00","dependencies":[{"issue_id":"scribe-use.17","depends_on_id":"scribe-use","type":"parent-child","created_at":"2025-12-14T00:25:38.891241-06:00","created_by":"daemon"}]}
{"id":"scribe-use.18","title":"Implement extractHeadings utility for Lexical AST","description":"## Overview\n\nImplement the `extractHeadings()` utility that extracts a heading tree from Lexical AST content.\n\n---\n\n## Why This Utility?\n\nSeveral commands need to understand note structure:\n- `vault outline` - Main use case: display heading tree\n- `vault context` - Extract sections by heading boundaries\n- `scribe-use.21` (extractRelevantExcerpt) - Segment notes for excerpt selection\n\nCentralizing this avoids duplicating AST traversal logic.\n\n---\n\n## IMPORTANT: Use Existing Infrastructure\n\nThe `@scribe/shared` package already exports AST traversal utilities. **USE THEM**:\n\n```typescript\nimport { traverseNodes, extractTextFromNode } from '@scribe/shared';\n```\n\nSee `packages/shared/src/ast-utils.ts` for implementations.\n\n**DO NOT** reimplement AST traversal - that's duplicated effort and risks inconsistency.\n\n---\n\n## API\n\n```typescript\n// File: packages/vault-eval/src/utils/headings.ts\n\nimport { traverseNodes, extractTextFromNode } from '@scribe/shared';\nimport type { EditorContent, LexicalNode } from '@scribe/shared';\n\nexport interface Heading {\n  level: number;      // 1-6\n  text: string;       // Heading text content  \n  anchor: string;     // URL-safe slug for linking\n  children: Heading[];\n}\n\n/**\n * Extract headings from Lexical AST content and build a nested tree.\n * \n * @param content - Lexical editor content (note.content)\n * @returns Array of top-level headings with nested children\n */\nexport function extractHeadings(content: EditorContent): Heading[];\n\n/**\n * Convert text to URL-safe slug.\n */\nexport function slugify(text: string): string;\n```\n\n---\n\n## Lexical Heading Node Structure\n\nLexical heading nodes have this structure:\n\n```typescript\ninterface HeadingNode extends LexicalNode {\n  type: 'heading';\n  tag: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';\n  children: LexicalNode[];  // Text nodes\n}\n```\n\n---\n\n## Implementation\n\n```typescript\nexport function extractHeadings(content: EditorContent): Heading[] {\n  const headings: Heading[] = [];\n  const stack: Heading[] = [];\n  \n  traverseNodes(content.root.children, (node) =\u003e {\n    if (node.type === 'heading' \u0026\u0026 'tag' in node) {\n      const tagLevel: Record\u003cstring, number\u003e = {\n        h1: 1, h2: 2, h3: 3, h4: 4, h5: 5, h6: 6\n      };\n      const level = tagLevel[node.tag as string] ?? 6;\n      const text = extractTextFromNode(node);\n      const heading: Heading = {\n        level,\n        text,\n        anchor: slugify(text),\n        children: []\n      };\n      \n      // Build tree structure based on heading levels\n      // Pop stack until we find a parent with smaller level\n      while (stack.length \u003e 0 \u0026\u0026 stack[stack.length - 1].level \u003e= level) {\n        stack.pop();\n      }\n      \n      if (stack.length === 0) {\n        headings.push(heading);\n      } else {\n        stack[stack.length - 1].children.push(heading);\n      }\n      stack.push(heading);\n    }\n  });\n  \n  return headings;\n}\n\nexport function slugify(text: string): string {\n  return text\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, '-')\n    .replace(/^-|-$/g, '');\n}\n```\n\n---\n\n## Edge Cases to Handle\n\n1. **Empty content** → return `[]`\n2. **No headings** → return `[]`\n3. **Only H3s (no H1/H2)** → H3s become top-level\n4. **Duplicate heading text** → generate unique anchors (append -1, -2, etc.)\n5. **Heading with empty text** → skip or use placeholder like \"untitled\"\n6. **Non-sequential levels** (H1 → H4) → H4 still nests under H1\n\n---\n\n## Anchor Uniqueness\n\nWhen multiple headings have the same text, generate unique anchors:\n\n```typescript\nconst anchorCounts = new Map\u003cstring, number\u003e();\n\nfunction getUniqueAnchor(text: string): string {\n  const base = slugify(text);\n  const count = anchorCounts.get(base) ?? 0;\n  anchorCounts.set(base, count + 1);\n  return count === 0 ? base : `${base}-${count}`;\n}\n```\n\n---\n\n## Exit Criteria\n\n- [ ] Extracts all headings from Lexical content\n- [ ] Builds correct nested tree structure (H2 under H1, H3 under H2, etc.)\n- [ ] Generates URL-safe unique anchors\n- [ ] Handles empty content (returns empty array)\n- [ ] Handles content with no headings (returns empty array)\n- [ ] Uses `@scribe/shared` traverseNodes (NOT reimplementing)\n- [ ] Unit tests cover all edge cases\n\n---\n\n## Dependencies\n\n- **Blocked by**: scribe-use.1 (package must exist)\n- **Uses**: @scribe/shared (traverseNodes, extractTextFromNode)\n\n## Used By\n\n- scribe-use.10 (context command - for section extraction)\n- scribe-use.11 (outline command - main feature)\n- scribe-use.21 (extractRelevantExcerpt - for heading-bounded strategy)\n\n---\n\n## Estimated Time\n\n1-2 hours\n\n---\n\n## Reference\n\nSee `features/vault-eval/spec.md` section: Required Utilities - Heading Extraction","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-14T00:25:58.894714-06:00","updated_at":"2025-12-15T20:47:27.392182-06:00","closed_at":"2025-12-15T20:47:27.392182-06:00","dependencies":[{"issue_id":"scribe-use.18","depends_on_id":"scribe-use","type":"parent-child","created_at":"2025-12-14T00:25:58.895098-06:00","created_by":"daemon"},{"issue_id":"scribe-use.18","depends_on_id":"scribe-use.1","type":"blocks","created_at":"2025-12-14T00:33:49.725118-06:00","created_by":"daemon"}]}
{"id":"scribe-use.19","title":"Implement extractLinkContext utility","description":"## Overview\n\nImplement the `extractLinkContext()` utility that extracts text surrounding a wiki-link to a target note.\n\n---\n\n## Why This Utility?\n\nSeveral commands need to show *where* and *how* a note is referenced:\n- `vault backlinks` - Show context around each incoming link\n- `vault read --include-backlinks` - Include backlink context\n- `vault context` - Include backlink excerpts\n\nShowing \"...delegates to the [[Error Handling Strategy]] before returning...\" is much more useful than just \"linked by: API Gateway Design\".\n\n---\n\n## IMPORTANT: Use Existing Infrastructure\n\nThe `@scribe/shared` package already exports AST traversal utilities:\n\n```typescript\nimport { traverseNodes, extractTextFromNode } from '@scribe/shared';\n```\n\n---\n\n## Wiki-Link Node Structure (VERIFIED)\n\nWiki-link nodes in Scribe's Lexical implementation have this structure:\n\n```typescript\ninterface WikiLinkNode extends LexicalNode {\n  type: 'wiki-link';\n  targetId: string | null;  // Resolved target note ID, or null if unresolved\n  noteTitle: string;        // The note title used for resolution\n  displayText: string;      // What to display (alias or title)\n  version: number;\n}\n```\n\n**CRITICAL**: Use `targetId` (NOT `noteId`) to match links to target notes!\n\nThis was verified from `apps/desktop/test-helpers.ts` which creates wiki-link nodes.\n\n---\n\n## API\n\n```typescript\n// File: packages/vault-eval/src/utils/excerpts.ts\n\nimport { traverseNodes, extractTextFromNode } from '@scribe/shared';\nimport type { EditorContent, NoteId, LexicalNode } from '@scribe/shared';\n\n/**\n * Extract text surrounding a wiki-link that points to a target note.\n * \n * @param content - Lexical editor content\n * @param targetNoteId - The note ID to find links to\n * @param contextChars - Characters of context around the link (default: 100)\n * @returns Context string with ellipsis, or null if no link found\n * \n * @example\n * // Returns: '...delegates to the [[Error Handling Strategy]] before returning...'\n * extractLinkContext(note.content, 'error-handling-id', 50);\n */\nexport function extractLinkContext(\n  content: EditorContent,\n  targetNoteId: NoteId,\n  contextChars: number = 100\n): string | null;\n```\n\n---\n\n## Implementation\n\n```typescript\nexport function extractLinkContext(\n  content: EditorContent,\n  targetNoteId: NoteId,\n  contextChars: number = 100\n): string | null {\n  let result: string | null = null;\n  \n  // Track link position within paragraph text\n  traverseNodes(content.root.children, (node) =\u003e {\n    if (result) return; // Already found, short-circuit\n    \n    if (node.type === 'paragraph' \u0026\u0026 Array.isArray(node.children)) {\n      // Build text and track link position\n      let fullText = '';\n      let linkStart = -1;\n      let linkEnd = -1;\n      \n      for (const child of node.children as LexicalNode[]) {\n        // Wiki-link nodes use targetId (CORRECT property name)\n        if (child.type === 'wiki-link' \u0026\u0026 child.targetId === targetNoteId) {\n          linkStart = fullText.length;\n          const linkText = child.displayText ?? '[[link]]';\n          fullText += linkText;\n          linkEnd = fullText.length;\n        } else if (child.type === 'text' \u0026\u0026 typeof child.text === 'string') {\n          fullText += child.text;\n        }\n      }\n      \n      if (linkStart \u003e= 0) {\n        // Extract context around link\n        const halfContext = Math.floor(contextChars / 2);\n        const start = Math.max(0, linkStart - halfContext);\n        const end = Math.min(fullText.length, linkEnd + halfContext);\n        \n        let context = fullText.slice(start, end);\n        if (start \u003e 0) context = '...' + context;\n        if (end \u003c fullText.length) context = context + '...';\n        \n        result = context;\n      }\n    }\n  });\n  \n  return result;\n}\n```\n\n---\n\n## Edge Cases to Handle\n\n1. **Note has no links to target** → return null\n2. **Multiple links to same target** → return first occurrence\n3. **Link at start of paragraph** → no leading ellipsis\n4. **Link at end of paragraph** → no trailing ellipsis\n5. **Very short paragraph** → return full text, no truncation\n6. **Link inside list item** → also traverse list items\n7. **Aliased link** → use `displayText`, not `noteTitle`\n8. **Unresolved link** (`targetId: null`) → skip these\n\n---\n\n## Exit Criteria\n\n- [ ] Extracts context around wiki-links correctly\n- [ ] Uses `targetId` property (NOT `noteId`) to match links\n- [ ] Adds ellipsis markers when truncated at start/end\n- [ ] Returns null if no link to target found\n- [ ] Handles multiple links to same target (returns first)\n- [ ] Works with various paragraph structures\n- [ ] Uses `@scribe/shared` utilities\n- [ ] Unit tests cover all edge cases\n\n---\n\n## Dependencies\n\n- **Blocked by**: scribe-use.1 (package must exist)\n- **Uses**: @scribe/shared (traverseNodes)\n\n## Used By\n\n- scribe-use.6 (read command with --include-backlinks)\n- scribe-use.10 (context command for backlink context)\n- scribe-use.12 (backlinks command - main feature)\n- scribe-use.27 (linkcheck command)\n\n---\n\n## Estimated Time\n\n1-2 hours\n\n---\n\n## Reference\n\nSee `features/vault-eval/spec.md` section: Required Utilities - Link Context Extraction","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-14T00:26:11.43116-06:00","updated_at":"2025-12-15T20:49:05.689564-06:00","closed_at":"2025-12-15T20:49:05.689564-06:00","dependencies":[{"issue_id":"scribe-use.19","depends_on_id":"scribe-use","type":"parent-child","created_at":"2025-12-14T00:26:11.431513-06:00","created_by":"daemon"},{"issue_id":"scribe-use.19","depends_on_id":"scribe-use.1","type":"blocks","created_at":"2025-12-14T00:33:49.77377-06:00","created_by":"daemon"}]}
{"id":"scribe-use.2","title":"Implement CLI argument parser and router","description":"## Overview\n\nImplement a minimal hand-rolled argument parser for vault-eval (no external CLI framework to keep binary small).\n\n---\n\n## Why No External Framework?\n\nWe intentionally avoid Commander.js, Yargs, or other CLI frameworks because:\n\n1. **Binary size**: Bun-compiled binaries include all dependencies; frameworks add 5-15MB\n2. **Bun compatibility**: Some CLI frameworks have issues with Bun compilation\n3. **Simplicity**: vault-eval has flat commands (no nested subcommands), simple flag parsing suffices\n4. **Control**: Full control over help text formatting and error messages\n\n---\n\n## Implementation Details\n\n### args.ts - Flag Parser\n\n```typescript\nexport interface ParsedArgs {\n  command: string;\n  flags: Map\u003cstring, string | boolean\u003e;\n  positionals: string[];\n}\n\n/**\n * Parse command-line arguments into structured form.\n * \n * Supports:\n * - Long flags: --flag value, --flag=value\n * - Short flags: -f value, -f=value  \n * - Boolean flags: --json, --help (no value)\n * - Combined short flags: -vh (same as -v -h)\n * - Positional arguments after --\n * \n * @param args - Raw args from Bun.argv.slice(2)\n */\nexport function parseArgs(args: string[]): ParsedArgs {\n  const flags = new Map\u003cstring, string | boolean\u003e();\n  const positionals: string[] = [];\n  let command = '';\n  \n  // Implementation...\n}\n\n/**\n * Get a string flag value, with optional default.\n */\nexport function getString(\n  flags: Map\u003cstring, string | boolean\u003e, \n  key: string, \n  defaultValue?: string\n): string | undefined;\n\n/**\n * Get a number flag value, with optional default.\n */\nexport function getNumber(\n  flags: Map\u003cstring, string | boolean\u003e, \n  key: string, \n  defaultValue?: number\n): number | undefined;\n\n/**\n * Get a boolean flag value.\n */\nexport function getBoolean(\n  flags: Map\u003cstring, string | boolean\u003e, \n  key: string\n): boolean;\n\n/**\n * Get a list flag value (comma-separated).\n */\nexport function getList(\n  flags: Map\u003cstring, string | boolean\u003e,\n  key: string\n): string[];\n```\n\n### cli.ts - Command Router\n\n```typescript\n#!/usr/bin/env bun\nimport { parseArgs, getString, getBoolean } from './args.js';\nimport { formatError } from './formatters/json.js';\n\n// Command imports\nimport { infoCommand } from './commands/info.js';\nimport { readCommand } from './commands/read.js';\nimport { searchCommand } from './commands/search.js';\n// ... etc\n\nconst VERSION = '0.1.0';\n\nasync function main() {\n  const { command, flags, positionals } = parseArgs(Bun.argv.slice(2));\n  \n  // Global options (available to all commands)\n  const vaultPath = getString(flags, 'vault') ?? getString(flags, 'v') ?? process.cwd();\n  const jsonOutput = getBoolean(flags, 'json');\n  \n  try {\n    switch (command) {\n      case 'info':\n        return await infoCommand({ vaultPath, jsonOutput, flags, positionals });\n      case 'read':\n        return await readCommand({ vaultPath, jsonOutput, flags, positionals });\n      // ... all commands\n      case '--version':\n      case '-V':\n        console.log(VERSION);\n        return 0;\n      case '--help':\n      case '-h':\n      case '':\n        return helpCommand();\n      default:\n        console.error(`Unknown command: ${command}`);\n        return helpCommand();\n    }\n  } catch (error) {\n    console.error(formatError('INTERNAL_ERROR', error instanceof Error ? error.message : 'Unknown error'));\n    return 3;\n  }\n}\n\nmain().then(code =\u003e process.exit(code ?? 0));\n```\n\n### Global Options\n\n| Flag | Short | Type | Default | Description |\n|------|-------|------|---------|-------------|\n| `--vault` | `-v` | string | cwd | Vault directory path |\n| `--json` | - | boolean | false | Output as JSON (some commands default to JSON) |\n| `--help` | `-h` | boolean | false | Show help |\n| `--version` | `-V` | boolean | false | Show version |\n\n### Help Output Format\n\n```\nvault-eval v0.1.0 - LLM-friendly vault query CLI\n\nUSAGE:\n  vault-eval \u003ccommand\u003e [options]\n\nCOMMANDS:\n  info        Show vault statistics and metadata\n  read        Get full content of a note by ID\n  search      Search notes by text query\n  retrieve    Multi-signal ranked search\n  context     Build LLM context bundle\n  outline     Extract heading tree from a note\n  backlinks   Show notes linking to a target\n  graph       Export subgraph for visualization\n  recent      List recently modified notes\n  tasks       Query tasks across the vault\n  lint        Validate vault data integrity\n  linkcheck   Check for broken internal links\n\nGLOBAL OPTIONS:\n  -v, --vault \u003cpath\u003e  Vault directory (default: current directory)\n  --json              Output as JSON\n  -h, --help          Show this help\n  -V, --version       Show version\n\nRun 'vault-eval \u003ccommand\u003e --help' for command-specific options.\n```\n\n---\n\n## CommandContext Type\n\nDefine a shared context type for all commands:\n\n```typescript\n// types.ts\nexport interface CommandContext {\n  vaultPath: string;\n  jsonOutput: boolean;\n  flags: Map\u003cstring, string | boolean\u003e;\n  positionals: string[];\n}\n\nexport type CommandHandler = (ctx: CommandContext) =\u003e Promise\u003cnumber\u003e;\n```\n\n---\n\n## Exit Criteria\n\n- [ ] `vault-eval --help` shows command list\n- [ ] `vault-eval --version` shows version\n- [ ] `vault-eval info --help` shows command-specific help\n- [ ] Unknown commands show help + exit code 1\n- [ ] Flag parsing handles: `--flag value`, `--flag=value`, `-f value`, boolean flags\n- [ ] Global `--vault` flag works for all commands\n- [ ] Combined short flags work: `-vh` = `-v -h`\n- [ ] Unit tests for parseArgs() with various input patterns\n\n---\n\n## Edge Cases to Handle\n\n1. `--flag=` (empty value) → treat as empty string\n2. `-abc` (combined) → three boolean flags: -a, -b, -c\n3. `--` (bare) → all following args are positionals\n4. Unknown flags → pass through to command (command validates)\n5. First non-flag arg → command name\n\n---\n\n## Dependencies\n\n- **Blocked by**: scribe-use.1 (package scaffolding must exist first)\n\n## Parallelization\n\nCan be developed in parallel with scribe-use.3 (EngineLoader) and scribe-use.4 (formatters) once scaffolding is done. These are independent.\n\nAfter this completes, all command tasks can begin: .5-.14, .26-.27\n\n---\n\n## Estimated Time\n\n2-3 hours\n\n---\n\n## Reference\n\nSee `features/vault-eval/spec.md` sections:\n- CLI Framework\n- Help Output","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-14T00:21:58.74385-06:00","updated_at":"2025-12-15T20:49:39.793216-06:00","closed_at":"2025-12-15T20:49:39.793218-06:00","dependencies":[{"issue_id":"scribe-use.2","depends_on_id":"scribe-use","type":"parent-child","created_at":"2025-12-14T00:21:58.744226-06:00","created_by":"daemon"},{"issue_id":"scribe-use.2","depends_on_id":"scribe-use.1","type":"blocks","created_at":"2025-12-14T00:33:44.525521-06:00","created_by":"daemon"}]}
{"id":"scribe-use.20","title":"Implement depthLimitedTraversal utility","description":"## Overview\n\nImplement the `depthLimitedTraversal()` utility for BFS graph exploration with direction control.\n\n---\n\n## Why This Utility?\n\nThe GraphEngine only provides immediate neighbors:\n- `backlinks(noteId)` - Notes linking TO this note\n- `neighbors(noteId)` - ALL connected notes (in + out)\n\nBut `vault graph` needs to traverse multiple hops and export the subgraph. This utility provides:\n- Depth-limited BFS (don't traverse forever)\n- Direction control (outgoing, incoming, or both)\n- Edge type tracking (for visualization)\n\n---\n\n## API\n\n```typescript\n// File: packages/vault-eval/src/utils/traversal.ts\n\nimport type { GraphEngine } from '@scribe/engine-graph';\nimport type { NoteId, GraphNode } from '@scribe/shared';\n\nexport interface TraversalResult {\n  nodes: Map\u003cNoteId, { node: GraphNode; depth: number }\u003e;\n  edges: Array\u003c{ source: NoteId; target: NoteId; type: 'link' | 'backlink' }\u003e;\n}\n\nexport type TraversalDirection = 'outgoing' | 'incoming' | 'both';\n\n/**\n * Perform depth-limited BFS traversal from a root node.\n * \n * @param graph - GraphEngine instance\n * @param rootId - Starting note ID\n * @param maxDepth - Maximum traversal depth (0 = only root)\n * @param direction - Which edges to follow\n * @returns Visited nodes with depths and edges traversed\n */\nexport function depthLimitedTraversal(\n  graph: GraphEngine,\n  rootId: NoteId,\n  maxDepth: number,\n  direction: TraversalDirection = 'both'\n): TraversalResult;\n```\n\n---\n\n## Edge Direction Semantics\n\n| Direction | Meaning | GraphEngine API |\n|-----------|---------|-----------------:|\n| `outgoing` | Links FROM this note | `neighbors()` minus `backlinks()` |\n| `incoming` | Links TO this note | `backlinks()` |\n| `both` | All connections | `neighbors()` (includes both) |\n\nThe GraphEngine doesn't directly provide \"outgoing links\" - we compute them by subtracting backlinks from neighbors.\n\n---\n\n## Implementation\n\n```typescript\nexport function depthLimitedTraversal(\n  graph: GraphEngine,\n  rootId: NoteId,\n  maxDepth: number,\n  direction: TraversalDirection = 'both'\n): TraversalResult {\n  const visited = new Map\u003cNoteId, { node: GraphNode; depth: number }\u003e();\n  const edges: TraversalResult['edges'] = [];\n  \n  // BFS queue: [nodeId, depth]\n  const queue: Array\u003c{ id: NoteId; depth: number }\u003e = [{ id: rootId, depth: 0 }];\n  \n  while (queue.length \u003e 0) {\n    const { id, depth } = queue.shift()!;\n    \n    if (visited.has(id) || depth \u003e maxDepth) continue;\n    \n    // Get node data from graph\n    const backlinks = graph.backlinks(id);\n    const allNeighbors = graph.neighbors(id);\n    \n    // Compute outgoing links (neighbors that aren't backlinks)\n    const backlinkIds = new Set(backlinks.map(n =\u003e n.id));\n    const outgoingNodes = allNeighbors.filter(n =\u003e !backlinkIds.has(n.id));\n    \n    // Find this node's data\n    const nodeData: GraphNode = allNeighbors.find(n =\u003e n.id === id) \n      ?? backlinks.find(n =\u003e n.id === id)\n      ?? { id, title: null, tags: [], type: undefined };\n    \n    visited.set(id, { node: nodeData, depth });\n    \n    // Skip edge traversal if at max depth\n    if (depth \u003e= maxDepth) continue;\n    \n    // Collect neighbors based on direction\n    const toVisit: Array\u003c{ neighbor: GraphNode; edgeType: 'link' | 'backlink' }\u003e = [];\n    \n    if (direction === 'outgoing' || direction === 'both') {\n      outgoingNodes.forEach(n =\u003e toVisit.push({ neighbor: n, edgeType: 'link' }));\n    }\n    if (direction === 'incoming' || direction === 'both') {\n      backlinks.forEach(n =\u003e toVisit.push({ neighbor: n, edgeType: 'backlink' }));\n    }\n    \n    for (const { neighbor, edgeType } of toVisit) {\n      if (!visited.has(neighbor.id)) {\n        queue.push({ id: neighbor.id, depth: depth + 1 });\n        \n        // Record edge with correct source/target based on type\n        edges.push({ \n          source: edgeType === 'link' ? id : neighbor.id, \n          target: edgeType === 'link' ? neighbor.id : id, \n          type: edgeType \n        });\n      }\n    }\n  }\n  \n  return { nodes: visited, edges };\n}\n```\n\n---\n\n## Edge Cases to Handle\n\n1. **Root node doesn't exist** → return empty result (empty map, empty edges)\n2. **Depth 0** → return only root node, no edges\n3. **Cycles in graph** → visited set prevents infinite loop\n4. **Disconnected node** → return only that node\n5. **Very large graph** → BFS naturally handles (breadth-first won't explode stack)\n\n---\n\n## Exit Criteria\n\n- [ ] BFS traversal respects maxDepth exactly\n- [ ] Direction filtering works correctly for all three modes\n- [ ] Handles cycles without infinite loops\n- [ ] Correctly identifies edge types (link vs backlink)\n- [ ] Works with disconnected/orphan nodes\n- [ ] Unit tests cover depth limits, directions, and cycles\n\n---\n\n## Dependencies\n\n- **Blocked by**: scribe-use.1 (package must exist)\n- **Uses**: @scribe/engine-graph (GraphEngine)\n\n## Used By\n\n- scribe-use.13 (graph command - main feature)\n- scribe-use.10 (context command with --depth option)\n\n---\n\n## Estimated Time\n\n1-2 hours\n\n---\n\n## Reference\n\nSee `features/vault-eval/spec.md` section: Required Utilities - Depth-Limited Graph Traversal","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-14T00:26:27.424134-06:00","updated_at":"2025-12-15T20:49:13.339669-06:00","closed_at":"2025-12-15T20:49:13.339669-06:00","dependencies":[{"issue_id":"scribe-use.20","depends_on_id":"scribe-use","type":"parent-child","created_at":"2025-12-14T00:26:27.424503-06:00","created_by":"daemon"},{"issue_id":"scribe-use.20","depends_on_id":"scribe-use.1","type":"blocks","created_at":"2025-12-14T00:33:49.822301-06:00","created_by":"daemon"}]}
{"id":"scribe-use.21","title":"Implement extractRelevantExcerpt utility","description":"## Overview\n\nImplement the `extractRelevantExcerpt()` utility for query-aware excerpt extraction with multiple strategies.\n\n---\n\n## Why This Utility?\n\nThe `vault context` command needs to fit multiple notes into a token budget. Simply truncating notes would lose relevant content. This utility:\n- Extracts the most query-relevant sections\n- Respects token budgets\n- Uses multiple strategies based on note structure\n- Produces coherent excerpts with ellipsis markers\n\nThis is the most complex utility because it needs to balance relevance vs. coherence vs. budget.\n\n---\n\n## IMPORTANT: Use Existing Infrastructure\n\nUses `@scribe/shared` for AST traversal and the local `extractHeadings()` utility:\n\n```typescript\nimport { extractTextFromNodes } from '@scribe/shared';\nimport { extractHeadings } from './headings.js';\n```\n\n---\n\n## API\n\n```typescript\n// File: packages/vault-eval/src/utils/excerpts.ts\n\nimport type { Note } from '@scribe/shared';\nimport type { Heading } from './headings.js';\n\nexport type ExcerptStrategy = 'full' | 'heading-bounded' | 'sentence-window' | 'summary';\n\nexport interface ExcerptConfig {\n  strategy: ExcerptStrategy;\n  tokenBudget: number;\n  minContextSentences: number;  // Sentences before/after match (default: 2)\n}\n\nexport interface ExcerptResult {\n  excerpt: string;\n  tokens: number;\n}\n\n/**\n * Extract relevant portions of a note based on query terms.\n * \n * Strategy selection:\n * - 'full': Return entire note (if fits in budget)\n * - 'heading-bounded': Extract sections containing query terms\n * - 'sentence-window': Extract sentences around matches\n * - 'summary': First paragraph + query-matching sections\n */\nexport function extractRelevantExcerpt(\n  note: Note,\n  query: string,\n  config: ExcerptConfig\n): ExcerptResult;\n\n/**\n * Estimate token count for text (~4 chars per token).\n */\nexport function estimateTokens(text: string): number {\n  return Math.ceil(text.length / 4);\n}\n```\n\n---\n\n## Strategy Options\n\n| Strategy | Description | Use Case |\n|----------|-------------|----------|\n| `full` | Include entire note content | Small notes, high relevance |\n| `heading-bounded` | Extract sections containing query terms | Structured notes with clear headings |\n| `sentence-window` | Extract sentences around query matches | Dense prose without structure |\n| `summary` | First paragraph + query-matching sections | Long notes with budget constraints |\n\n---\n\n## Default Algorithm: Heading-Bounded with Fallback\n\n```typescript\nexport function extractRelevantExcerpt(\n  note: Note,\n  query: string,\n  config: ExcerptConfig\n): ExcerptResult {\n  const fullText = extractTextFromNodes(note.content.root.children);\n  const fullTokens = estimateTokens(fullText);\n  \n  // If note fits in budget, return full content\n  if (fullTokens \u003c= config.tokenBudget || config.strategy === 'full') {\n    return { excerpt: fullText, tokens: fullTokens };\n  }\n  \n  // Extract headings to find section boundaries\n  const headings = extractHeadings(note.content);\n  const queryTerms = tokenizeQuery(query);\n  \n  if (headings.length === 0) {\n    // Fallback to sentence-window for unstructured content\n    return extractSentenceWindow(fullText, queryTerms, config);\n  }\n  \n  // Score each section by query term density\n  const sections = segmentByHeadings(note.content, headings);\n  const scoredSections = sections.map(section =\u003e ({\n    ...section,\n    score: computeTermDensity(section.text, queryTerms),\n    tokens: estimateTokens(section.text)\n  }));\n  \n  // Greedy selection: highest scoring sections within budget\n  scoredSections.sort((a, b) =\u003e b.score - a.score);\n  \n  const selected: typeof scoredSections = [];\n  let usedTokens = 0;\n  \n  for (const section of scoredSections) {\n    if (usedTokens + section.tokens \u003c= config.tokenBudget) {\n      selected.push(section);\n      usedTokens += section.tokens;\n    }\n  }\n  \n  // Re-sort by document order for coherent reading\n  selected.sort((a, b) =\u003e a.startOffset - b.startOffset);\n  \n  // Join with ellipsis markers between non-adjacent sections\n  const excerpt = selected\n    .map((s, i) =\u003e {\n      const prev = selected[i - 1];\n      const needsEllipsis = prev \u0026\u0026 s.startOffset \u003e prev.endOffset + 1;\n      return (needsEllipsis ? '\\n...\\n\\n' : '') + s.text;\n    })\n    .join('');\n  \n  return { excerpt, tokens: usedTokens };\n}\n```\n\n---\n\n## Helper Functions Needed\n\n```typescript\nfunction tokenizeQuery(query: string): string[];\nfunction segmentByHeadings(content: EditorContent, headings: Heading[]): Section[];\nfunction computeTermDensity(text: string, queryTerms: string[]): number;\nfunction extractSentenceWindow(text: string, queryTerms: string[], config: ExcerptConfig): ExcerptResult;\n```\n\n---\n\n## Fallback Chain\n\n1. Try heading-bounded strategy\n2. Fall back to sentence-window if no headings found\n3. Fall back to first N tokens if no query matches\n\nThis ensures we always return something useful.\n\n---\n\n## Exit Criteria\n\n- [ ] All 4 strategies implemented\n- [ ] Fallback chain works correctly\n- [ ] Respects token budget exactly\n- [ ] Re-orders excerpts by document position\n- [ ] Adds ellipsis markers between non-adjacent sections\n- [ ] Unit tests cover each strategy and edge cases\n\n---\n\n## Dependencies\n\n- **Blocked by**: scribe-use.1, scribe-use.18 (extractHeadings)\n- **Uses**: @scribe/shared (extractTextFromNodes)\n\n## Used By\n\n- scribe-use.10 (context command - main excerpt extraction)\n\n---\n\n## Risk\n\n**Medium-High**: Strategy tuning may require iteration based on LLM output quality.\n\n---\n\n## Estimated Time\n\n3-4 hours\n\n---\n\n## Reference\n\nSee `features/vault-eval/spec.md` section: Excerpt Extraction Strategy","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-14T00:26:48.498714-06:00","updated_at":"2025-12-15T20:55:54.310525-06:00","closed_at":"2025-12-15T20:55:54.310525-06:00","dependencies":[{"issue_id":"scribe-use.21","depends_on_id":"scribe-use","type":"parent-child","created_at":"2025-12-14T00:26:48.499132-06:00","created_by":"daemon"},{"issue_id":"scribe-use.21","depends_on_id":"scribe-use.1","type":"blocks","created_at":"2025-12-14T00:33:49.870258-06:00","created_by":"daemon"},{"issue_id":"scribe-use.21","depends_on_id":"scribe-use.18","type":"blocks","created_at":"2025-12-14T00:34:09.679233-06:00","created_by":"daemon"}]}
{"id":"scribe-use.22","title":"Implement hybrid scoring module","description":"## Overview\n\nImplement the hybrid scoring module for multi-signal retrieval ranking.\n\n---\n\n## Why Hybrid Scoring?\n\nSimple keyword search isn't enough for LLM context gathering:\n- **\"authentication\"** might match 50 notes - which are most relevant?\n- Recent notes about auth are probably more useful than 2-year-old ones\n- Notes linked by many others are probably authoritative\n- Title matches are stronger signals than content matches\n\nHybrid scoring combines multiple signals:\n1. Text match score (FlexSearch)\n2. Title match score\n3. Tag match score\n4. Recency decay\n5. Link centrality\n\n---\n\n## API\n\n```typescript\n// File: packages/vault-eval/src/scoring/hybrid.ts\n\nimport type { Note, GraphNode, NoteId } from '@scribe/shared';\nimport type { GraphEngine } from '@scribe/engine-graph';\n\nexport interface ScoringWeights {\n  textMatch: number;      // Default: 0.40 - FlexSearch score\n  titleMatch: number;     // Default: 0.25 - Title contains query terms\n  tagMatch: number;       // Default: 0.15 - Tags match query terms\n  recency: number;        // Default: 0.10 - Time decay\n  linkCentrality: number; // Default: 0.10 - Backlink count\n}\n\nexport interface ScoringBoosts {\n  recent?: { days: number; multiplier: number };\n  linked?: { threshold: number; multiplier: number };\n  tagged?: { tags: string[]; multiplier: number };\n}\n\nexport interface ScoringConfig {\n  weights: ScoringWeights;\n  boosts?: ScoringBoosts;\n  recencyHalfLifeDays?: number; // Default: 30\n}\n\nexport interface ScoreBreakdown {\n  textMatch: number;\n  titleMatch: number;\n  tagMatch: number;\n  recency: number;\n  linkCentrality: number;\n  boostApplied?: string;\n}\n\nexport interface ScoringResult {\n  score: number;          // 0-1 normalized\n  breakdown: ScoreBreakdown;\n}\n\nexport const DEFAULT_WEIGHTS: ScoringWeights = {\n  textMatch: 0.40,\n  titleMatch: 0.25,\n  tagMatch: 0.15,\n  recency: 0.10,\n  linkCentrality: 0.10\n};\n\n/**\n * Calculate hybrid score for a note based on multiple signals.\n */\nexport function calculateHybridScore(\n  note: Note,\n  query: string,\n  searchScore: number,  // Normalized 0-1 from FlexSearch\n  graph: GraphEngine,\n  config: ScoringConfig = { weights: DEFAULT_WEIGHTS }\n): ScoringResult;\n```\n\n---\n\n## Score Components\n\n### 1. Text Match Score (weight: 0.40)\n\nUse normalized FlexSearch score from search results.\n\n```typescript\nfunction normalizeSearchScore(rawScore: number, maxScore: number): number {\n  return maxScore \u003e 0 ? rawScore / maxScore : 0;\n}\n```\n\n### 2. Title Match Score (weight: 0.25)\n\n```typescript\nfunction titleMatchScore(title: string, query: string): number {\n  const queryTerms = tokenizeQuery(query);\n  const titleLower = title.toLowerCase();\n  \n  let matches = 0;\n  for (const term of queryTerms) {\n    if (titleLower.includes(term.toLowerCase())) {\n      matches++;\n    }\n  }\n  \n  return queryTerms.length \u003e 0 ? matches / queryTerms.length : 0;\n}\n```\n\n### 3. Tag Match Score (weight: 0.15)\n\n```typescript\nfunction tagMatchScore(tags: string[], query: string): number {\n  const queryTerms = tokenizeQuery(query);\n  const tagSet = new Set(tags.map(t =\u003e t.toLowerCase()));\n  \n  let matches = 0;\n  for (const term of queryTerms) {\n    if (tagSet.has(term.toLowerCase())) {\n      matches++;\n    }\n  }\n  \n  return queryTerms.length \u003e 0 ? matches / queryTerms.length : 0;\n}\n```\n\n### 4. Recency Score (weight: 0.10)\n\n```typescript\nfunction recencyDecay(updatedAt: number, halfLifeDays: number = 30): number {\n  const now = Date.now();\n  const ageMs = now - updatedAt;\n  const ageDays = ageMs / (1000 * 60 * 60 * 24);\n  \n  // Exponential decay with configurable half-life\n  return Math.pow(0.5, ageDays / halfLifeDays);\n}\n```\n\n### 5. Link Centrality Score (weight: 0.10)\n\n```typescript\nfunction linkCentralityScore(noteId: NoteId, graph: GraphEngine): number {\n  const backlinks = graph.backlinks(noteId);\n  // Normalize by log scale to prevent outliers dominating\n  // log(100) ≈ 4.6, so 100+ backlinks = score 1.0\n  return Math.min(1, Math.log(1 + backlinks.length) / Math.log(100));\n}\n```\n\n---\n\n## Score Breakdown for Debugging\n\nThe `breakdown` field lets users see why a note scored high/low:\n\n```json\n{\n  \"score\": 0.87,\n  \"breakdown\": {\n    \"textMatch\": 0.32,\n    \"titleMatch\": 0.25,\n    \"tagMatch\": 0.15,\n    \"recency\": 0.08,\n    \"linkCentrality\": 0.07\n  }\n}\n```\n\n---\n\n## Exit Criteria\n\n- [ ] All 5 scoring components implemented\n- [ ] Score breakdown returned for transparency/debugging\n- [ ] Boosts modify final score correctly when configured\n- [ ] Works with notes missing some signals (tags, etc.)\n- [ ] Total score capped at 1.0\n- [ ] Unit tests verify each component independently\n\n---\n\n## Dependencies\n\n- **Blocked by**: scribe-use.1 (package must exist)\n- **Uses**: @scribe/engine-graph (GraphEngine)\n\n## Used By\n\n- scribe-use.9 (retrieve command - main scoring)\n- scribe-use.10 (context command - relevance ranking)\n\n---\n\n## Estimated Time\n\n2-3 hours\n\n---\n\n## Reference\n\nSee `features/vault-eval/spec.md` section: Hybrid Scoring Algorithm","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-14T00:27:03.08472-06:00","updated_at":"2025-12-15T20:48:57.250825-06:00","closed_at":"2025-12-15T20:48:57.250825-06:00","dependencies":[{"issue_id":"scribe-use.22","depends_on_id":"scribe-use","type":"parent-child","created_at":"2025-12-14T00:27:03.08509-06:00","created_by":"daemon"},{"issue_id":"scribe-use.22","depends_on_id":"scribe-use.1","type":"blocks","created_at":"2025-12-14T00:33:49.917472-06:00","created_by":"daemon"}]}
{"id":"scribe-use.23","title":"Create test fixture vault for vault-eval","description":"## Overview\n\nCreate a test fixture vault with known content for integration testing all vault-eval commands.\n\n---\n\n## Why Test Fixtures?\n\nIntegration tests need:\n- Predictable note content for assertions\n- Known link graph structure\n- Pre-populated task data\n- Various note types (daily, meeting, person, etc.)\n- Edge cases (orphan notes, corrupted files)\n\nWithout fixtures, tests would need to mock everything or use unpredictable user data.\n\n---\n\n## Fixture Location\n\n`packages/vault-eval/tests/fixtures/vault/`\n\n---\n\n## Required Test Notes\n\n### 1. regular-note.json\n- **ID**: `note-regular-001`\n- Basic note with headings (H1, H2, H3), paragraphs, and wiki-links\n- Contains wiki-links to: `meeting-kickoff`, `person-alice`\n- Has inline tags: `#project`, `#architecture`\n- ~500 words\n\n### 2. daily-2025-01-15.json\n- **ID**: `daily-2025-01-15`\n- **Type**: `daily`\n- Daily note with date: 2025-01-15\n- Links to meeting notes (`meeting-kickoff`)\n- ~200 words\n\n### 3. meeting-kickoff.json\n- **ID**: `meeting-kickoff`\n- **Type**: `meeting`\n- Meeting note with attendees: [`person-alice`, `person-bob`]\n- Links to daily note and project notes\n- Contains 5+ tasks (mix of open/completed)\n- ~400 words\n\n### 4. person-alice.json\n- **ID**: `person-alice`\n- **Type**: `person`\n- Person note with bio\n- Mentioned in other notes via @mentions\n- ~100 words\n\n### 5. person-bob.json\n- **ID**: `person-bob`\n- **Type**: `person`\n- Another person note\n- ~100 words\n\n### 6. orphan-note.json\n- **ID**: `note-orphan-001`\n- Note with NO incoming or outgoing links\n- For testing orphan detection in lint command\n- ~150 words\n\n### 7. task-heavy.json\n- **ID**: `note-tasks-001`\n- Note with 15+ checklist items\n- Various priority levels (0, 1, 2)\n- Mix: 8 open, 7 completed\n- ~300 words\n\n### 8. long-structured-note.json\n- **ID**: `note-long-001`\n- Note with many headings (h1-h6)\n- Multiple sections for excerpt testing\n- ~2000 words\n- Good for testing token budget and heading-bounded extraction\n\n### 9. unstructured-note.json\n- **ID**: `note-unstructured-001`\n- Note with NO headings\n- Dense prose paragraphs\n- For testing fallback excerpt strategies\n- ~800 words\n\n### 10. project-alpha.json\n- **ID**: `project-alpha`\n- **Type**: `project`\n- Project note with multiple links\n- Referenced by several other notes\n- ~400 words\n\n---\n\n## Directory Structure\n\n```\npackages/vault-eval/tests/fixtures/\n  vault/\n    notes/\n      regular-note.json\n      daily-2025-01-15.json\n      meeting-kickoff.json\n      person-alice.json\n      person-bob.json\n      orphan-note.json\n      task-heavy.json\n      long-structured-note.json\n      unstructured-note.json\n      project-alpha.json\n    .scribe/\n      tasks.jsonl           # Pre-populated with tasks from notes\n      quarantine/\n        corrupted-note.json # Intentionally invalid JSON for quarantine testing\n```\n\n---\n\n## Content Requirements\n\n1. **Valid Lexical JSON**: All fixture notes must be valid Lexical editor JSON\n2. **Realistic content**: Use meaningful text, NOT lorem ipsum\n3. **Interesting link graph**:\n   - Regular note → meeting, person-alice\n   - Daily → meeting\n   - Meeting → daily, project, person-alice, person-bob\n   - Project → regular note, meeting\n   - Orphan → nothing\n4. **Pre-populated tasks.jsonl**: Extract tasks from fixture notes\n5. **Corrupted file**: One intentionally invalid JSON for quarantine testing\n\n---\n\n## Minimal Valid Note Structure\n\n```json\n{\n  \"id\": \"note-id\",\n  \"title\": \"Note Title\",\n  \"type\": \"regular\",\n  \"createdAt\": 1705300800000,\n  \"updatedAt\": 1705300800000,\n  \"tags\": [\"tag1\", \"tag2\"],\n  \"content\": {\n    \"root\": {\n      \"children\": [\n        {\n          \"type\": \"heading\",\n          \"tag\": \"h1\",\n          \"children\": [{ \"type\": \"text\", \"text\": \"Heading\" }]\n        },\n        {\n          \"type\": \"paragraph\",\n          \"children\": [{ \"type\": \"text\", \"text\": \"Content...\" }]\n        }\n      ],\n      \"direction\": \"ltr\",\n      \"format\": \"\",\n      \"indent\": 0,\n      \"type\": \"root\",\n      \"version\": 1\n    }\n  }\n}\n```\n\n---\n\n## Wiki-Link Node Structure\n\n```json\n{\n  \"type\": \"wiki-link\",\n  \"targetId\": \"meeting-kickoff\",\n  \"noteTitle\": \"Project Kickoff Meeting\",\n  \"displayText\": \"Project Kickoff Meeting\",\n  \"version\": 1\n}\n```\n\n---\n\n## Exit Criteria\n\n- [ ] All 10 fixture notes are valid Lexical JSON\n- [ ] Notes load successfully with FileSystemVault\n- [ ] Link graph has expected structure (verify with GraphEngine)\n- [ ] Tasks.jsonl pre-populated with tasks from fixture notes\n- [ ] One intentionally corrupted file in quarantine directory\n- [ ] README.md documenting the fixture structure (optional)\n\n---\n\n## Dependencies\n\n- **Blocked by**: scribe-use.1 (package must exist)\n\n## Used By\n\n- scribe-use.29 (integration tests - requires these fixtures)\n- Manual testing during development\n\n---\n\n## Estimated Time\n\n3-4 hours (includes crafting realistic content)\n\n---\n\n## Reference\n\nSee `features/vault-eval/spec.md` section: Test Fixture Vault","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-14T00:27:15.829435-06:00","updated_at":"2025-12-15T20:48:31.271923-06:00","closed_at":"2025-12-15T20:48:31.271923-06:00","dependencies":[{"issue_id":"scribe-use.23","depends_on_id":"scribe-use","type":"parent-child","created_at":"2025-12-14T00:27:15.829793-06:00","created_by":"daemon"},{"issue_id":"scribe-use.23","depends_on_id":"scribe-use.1","type":"blocks","created_at":"2025-12-14T00:33:49.963954-06:00","created_by":"daemon"}]}
{"id":"scribe-use.24","title":"Write integration tests for all vault-eval commands","description":"## Overview\n\nWrite integration tests for all vault-eval commands using the fixture vault.\n\n## Test Files\n\n```\ntests/\n  info.integration.test.ts\n  read.integration.test.ts\n  search.integration.test.ts\n  recent.integration.test.ts\n  retrieve.integration.test.ts\n  context.integration.test.ts\n  outline.integration.test.ts\n  backlinks.integration.test.ts\n  graph.integration.test.ts\n  tasks.integration.test.ts\n  lint.integration.test.ts\n  linkcheck.integration.test.ts\n```\n\n## Test Categories\n\n### Basic Command Tests\n- Command runs without errors\n- JSON output is valid\n- Required fields are present\n\n### Option Tests\n- All flags work as documented\n- Default values are correct\n- Invalid flags show errors\n\n### Edge Cases\n- Empty vault\n- Missing note IDs\n- Empty search queries\n- Zero results\n- Very large results\n\n### Error Handling\n- Vault not found\n- Invalid JSON in notes\n- Permission errors\n\n## Test Pattern\n\n```typescript\ndescribe('vault info', () =\u003e {\n  const fixtureVault = path.join(__dirname, 'fixtures/vault');\n  \n  it('returns vault statistics', async () =\u003e {\n    const result = await runCommand(['info', '--vault', fixtureVault, '--json']);\n    expect(result.exitCode).toBe(0);\n    \n    const output = JSON.parse(result.stdout);\n    expect(output.stats.totalNotes).toBe(8);\n    expect(output.tags.total).toBeGreaterThan(0);\n  });\n  \n  it('includes quarantine info when requested', async () =\u003e {\n    const result = await runCommand(['info', '--vault', fixtureVault, '--include-quarantine', '--json']);\n    const output = JSON.parse(result.stdout);\n    expect(output.quarantine.count).toBe(1);\n  });\n});\n```\n\n## Exit Criteria\n\n- All commands have at least 5 test cases\n- Edge cases covered\n- Error scenarios tested\n- CI passes\n\n## Dependencies\n\n- Requires: scribe-use.23 (fixture vault)\n- Requires: All command implementations\n\n## Phase\n\nShould run in parallel with Phase 4","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-14T00:27:28.215438-06:00","updated_at":"2025-12-15T06:06:01.690357-06:00","closed_at":"2025-12-15T06:06:01.690357-06:00","dependencies":[{"issue_id":"scribe-use.24","depends_on_id":"scribe-use","type":"parent-child","created_at":"2025-12-14T00:27:28.215803-06:00","created_by":"daemon"}]}
{"id":"scribe-use.25","title":"Set up cross-platform binary builds for vault-eval","description":"## Overview\n\nSet up Bun binary compilation for cross-platform distribution.\n\n## Build Targets\n\n- macOS arm64: `bun-darwin-arm64`\n- macOS x64: `bun-darwin-x64`\n- Linux x64: `bun-linux-x64`\n- Windows x64: `bun-windows-x64`\n\n## Build Commands\n\n```bash\n# Development\nbun run src/cli.ts -- info --vault /path/to/vault\n\n# Production builds\nbun build src/cli.ts --compile --target=bun-darwin-arm64 --outfile dist/vault-eval-darwin-arm64\nbun build src/cli.ts --compile --target=bun-darwin-x64 --outfile dist/vault-eval-darwin-x64\nbun build src/cli.ts --compile --target=bun-linux-x64 --outfile dist/vault-eval-linux-x64\nbun build src/cli.ts --compile --target=bun-windows-x64 --outfile dist/vault-eval-windows-x64.exe\n\n# Optimized build\nbun build src/cli.ts --compile --minify --target=bun-darwin-arm64 --outfile dist/vault-eval-darwin-arm64\n```\n\n## Package.json Scripts\n\n```json\n{\n  \"scripts\": {\n    \"dev\": \"bun run src/cli.ts\",\n    \"build\": \"bun run build:darwin-arm64\",\n    \"build:all\": \"bun run build:darwin-arm64 \u0026\u0026 bun run build:darwin-x64 \u0026\u0026 bun run build:linux-x64 \u0026\u0026 bun run build:windows-x64\",\n    \"build:darwin-arm64\": \"bun build src/cli.ts --compile --minify --target=bun-darwin-arm64 --outfile dist/vault-eval-darwin-arm64\",\n    \"build:darwin-x64\": \"bun build src/cli.ts --compile --minify --target=bun-darwin-x64 --outfile dist/vault-eval-darwin-x64\",\n    \"build:linux-x64\": \"bun build src/cli.ts --compile --minify --target=bun-linux-x64 --outfile dist/vault-eval-linux-x64\",\n    \"build:windows-x64\": \"bun build src/cli.ts --compile --minify --target=bun-windows-x64 --outfile dist/vault-eval-windows-x64.exe\"\n  }\n}\n```\n\n## CI/CD Integration\n\nAdd to `.github/workflows/release.yml`:\n- Build all targets\n- Attach to GitHub releases\n- Bundle in Electron app resources\n\n## Installation Location\n\n```\nvault/\n├── .scribe/\n│   └── bin/\n│       └── vault-eval          # Platform-specific binary\n```\n\n## Exit Criteria\n\n- All 4 platform builds complete successfully\n- Binaries are ~50-70 MB\n- Binaries run without runtime dependencies\n- CI workflow builds and uploads binaries\n\n## Dependencies\n\n- Requires: All features complete\n- Should be done after Phase 4\n\n## Distribution Notes\n\n- Zero runtime dependencies required\n- Self-contained Bun binary\n- Scribe Desktop can install from app resources","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-14T00:27:41.928354-06:00","updated_at":"2025-12-15T06:06:02.239134-06:00","closed_at":"2025-12-15T06:06:02.239134-06:00","dependencies":[{"issue_id":"scribe-use.25","depends_on_id":"scribe-use","type":"parent-child","created_at":"2025-12-14T00:27:41.928765-06:00","created_by":"daemon"}]}
{"id":"scribe-use.26","title":"Implement `vault lint` command","description":"## Overview\n\nImplement the `vault lint` command that validates vault data integrity and consistency.\n\n## Command Specification\n\n```bash\nvault lint --json\nvault lint --fix --json\nvault lint --checks frontmatter,links --json\nvault lint --include-quarantine --json\n```\n\n### Options\n| Flag | Type | Default | Description |\n|------|------|---------|-------------|\n| `--checks` | string | all | Comma-separated check names |\n| `--fix` | boolean | false | Auto-fix where possible |\n| `--severity` | string | all | error, warning, info |\n| `--include-quarantine` | boolean | false | List quarantined (corrupted) files |\n| `--json` | boolean | false | JSON output |\n\n### Available Checks\n- `frontmatter`: Required fields present (id, title, createdAt, updatedAt)\n- `links`: Internal links resolve to existing notes\n- `tags`: Tags follow naming conventions\n- `dates`: Timestamps are valid\n- `duplicates`: No duplicate note IDs\n- `orphans`: Notes with no links in or out\n- `schema`: Note structure matches type schema\n- `quarantine`: List files that failed to parse (via QuarantineManager)\n\n### JSON Output\n```json\n{\n  \"vaultPath\": \"/path/to/vault\",\n  \"notesScanned\": 150,\n  \"issues\": [\n    {\n      \"severity\": \"error\",\n      \"check\": \"links\",\n      \"noteId\": \"abc123\",\n      \"noteTitle\": \"Project Notes\",\n      \"message\": \"Broken link to non-existent note 'xyz999'\",\n      \"path\": \"notes/abc123.json\",\n      \"fixable\": false\n    }\n  ],\n  \"summary\": {\n    \"errors\": 2,\n    \"warnings\": 5,\n    \"info\": 3,\n    \"fixed\": 0\n  },\n  \"quarantine\": {\n    \"count\": 1,\n    \"files\": [\n      {\n        \"path\": \"notes/corrupted-abc.json\",\n        \"error\": \"Invalid JSON: Unexpected token at position 42\",\n        \"quarantinedAt\": \"2025-01-14T08:00:00Z\"\n      }\n    ]\n  }\n}\n```\n\n## Implementation Notes\n\n1. Load vault via EngineLoader\n2. For each check enabled:\n   - Run validation logic\n   - Collect issues with severity/check/noteId/message\n3. If `--fix` and issue is fixable, apply fix\n4. If `--include-quarantine`, list quarantined files via `vault.getQuarantineManager()`\n5. Format output based on `--json` flag\n\n### Existing Infrastructure\n- `FileSystemVault.getQuarantineManager()` for quarantine info\n- `noteValidator.validate()` for schema validation\n- `GraphEngine` for orphan detection\n\n## Exit Criteria\n\n- All 8 checks implemented\n- `--fix` auto-fixes where possible\n- `--severity` filters output correctly\n- `--include-quarantine` shows quarantined files\n- Exit code reflects severity (0=pass, 1=warnings, 2=errors)\n\n## Dependencies\n\n- **Blocked by**: scribe-use.2, scribe-use.3, scribe-use.4\n- **Uses**: @scribe/storage-fs (QuarantineManager)\n\n## Phase\n\nPhase 4 - Quality \u0026 Polish\n\n## Estimated Time\n\n3-4 hours","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-15T05:56:30.385617-06:00","updated_at":"2025-12-15T21:15:15.796723-06:00","closed_at":"2025-12-15T21:15:15.796723-06:00","dependencies":[{"issue_id":"scribe-use.26","depends_on_id":"scribe-use","type":"parent-child","created_at":"2025-12-15T05:56:30.385974-06:00","created_by":"daemon"},{"issue_id":"scribe-use.26","depends_on_id":"scribe-use.2","type":"blocks","created_at":"2025-12-15T06:06:50.63139-06:00","created_by":"daemon"},{"issue_id":"scribe-use.26","depends_on_id":"scribe-use.3","type":"blocks","created_at":"2025-12-15T06:06:50.682675-06:00","created_by":"daemon"},{"issue_id":"scribe-use.26","depends_on_id":"scribe-use.4","type":"blocks","created_at":"2025-12-15T06:06:50.729227-06:00","created_by":"daemon"}]}
{"id":"scribe-use.27","title":"Implement `vault linkcheck` command","description":"## Overview\n\nImplement the `vault linkcheck` command for focused broken link detection.\n\n## Command Specification\n\n```bash\nvault linkcheck --json\nvault linkcheck --include-external --json\n```\n\n### Options\n| Flag | Type | Default | Description |\n|------|------|---------|-------------|\n| `--include-external` | boolean | false | Check external URLs |\n| `--timeout` | number | 5000 | External URL timeout (ms) |\n| `--json` | boolean | false | JSON output |\n\n### JSON Output\n```json\n{\n  \"scanned\": {\n    \"notes\": 150,\n    \"internalLinks\": 423,\n    \"externalLinks\": 87\n  },\n  \"broken\": {\n    \"internal\": [\n      {\n        \"sourceId\": \"abc123\",\n        \"sourceTitle\": \"Project Notes\",\n        \"targetId\": \"xyz999\",\n        \"linkText\": \"old design doc\",\n        \"context\": \"...see the [[old design doc]] for details...\"\n      }\n    ],\n    \"external\": []\n  },\n  \"summary\": {\n    \"brokenInternal\": 3,\n    \"brokenExternal\": 0,\n    \"healthy\": 507\n  }\n}\n```\n\n## Implementation Notes\n\n1. Load vault and build note ID set\n2. For each note:\n   - Extract wiki-links from `metadata.links`\n   - Check each targetId exists in note ID set\n   - If `--include-external`, extract URLs and check HTTP status\n3. Use `extractLinkContext()` for broken link context\n4. Format output\n\n### External Link Checking (Optional)\n- Use `fetch()` with timeout\n- Consider rate limiting for many external links\n- Cache results within session\n\n## Exit Criteria\n\n- Detects all broken internal links\n- External checking works when enabled\n- Context extraction shows broken link in context\n- Exit code 0 if all healthy, 1 if broken links found\n\n## Dependencies\n\n- **Blocked by**: scribe-use.2, scribe-use.3, scribe-use.4, scribe-use.19 (extractLinkContext)\n\n## Phase\n\nPhase 4 - Quality \u0026 Polish\n\n## Estimated Time\n\n2-3 hours","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-15T05:56:38.704893-06:00","updated_at":"2025-12-15T21:15:17.852698-06:00","closed_at":"2025-12-15T21:15:17.852698-06:00","dependencies":[{"issue_id":"scribe-use.27","depends_on_id":"scribe-use","type":"parent-child","created_at":"2025-12-15T05:56:38.705239-06:00","created_by":"daemon"},{"issue_id":"scribe-use.27","depends_on_id":"scribe-use.19","type":"blocks","created_at":"2025-12-15T06:06:50.775609-06:00","created_by":"daemon"},{"issue_id":"scribe-use.27","depends_on_id":"scribe-use.2","type":"blocks","created_at":"2025-12-15T06:06:50.822168-06:00","created_by":"daemon"},{"issue_id":"scribe-use.27","depends_on_id":"scribe-use.3","type":"blocks","created_at":"2025-12-15T06:06:50.868439-06:00","created_by":"daemon"},{"issue_id":"scribe-use.27","depends_on_id":"scribe-use.4","type":"blocks","created_at":"2025-12-15T06:06:50.916379-06:00","created_by":"daemon"}]}
{"id":"scribe-use.28","title":"Implement configuration file support","description":"## Overview\n\nImplement configuration file loading for vault-eval to customize scoring weights, context defaults, and output preferences.\n\n## Configuration Locations (precedence order)\n\n1. Command-line flags (highest)\n2. Vault-local `.vault-eval.json`\n3. Global `~/.config/vault-eval/config.json`\n4. Built-in defaults (lowest)\n\n## Configuration Schema\n\n```json\n{\n  \"scoring\": {\n    \"weights\": {\n      \"textMatch\": 0.40,\n      \"titleMatch\": 0.25,\n      \"tagMatch\": 0.15,\n      \"recency\": 0.10,\n      \"linkCentrality\": 0.10\n    },\n    \"recencyHalfLifeDays\": 30\n  },\n  \"context\": {\n    \"defaultTokenBudget\": 4000,\n    \"defaultStrategy\": \"heading-bounded\",\n    \"minContextSentences\": 2\n  },\n  \"output\": {\n    \"defaultFormat\": \"json\",\n    \"prettyPrint\": true\n  }\n}\n```\n\n## Implementation\n\n### src/config.ts\n\n```typescript\ninterface VaultEvalConfig {\n  scoring: ScoringConfig;\n  context: ContextConfig;\n  output: OutputConfig;\n}\n\nconst DEFAULT_CONFIG: VaultEvalConfig = {\n  scoring: {\n    weights: {\n      textMatch: 0.40,\n      titleMatch: 0.25,\n      tagMatch: 0.15,\n      recency: 0.10,\n      linkCentrality: 0.10\n    },\n    recencyHalfLifeDays: 30\n  },\n  context: {\n    defaultTokenBudget: 4000,\n    defaultStrategy: 'heading-bounded',\n    minContextSentences: 2\n  },\n  output: {\n    defaultFormat: 'json',\n    prettyPrint: true\n  }\n};\n\n/**\n * Load configuration with precedence merging.\n */\nexport async function loadConfig(vaultPath: string): Promise\u003cVaultEvalConfig\u003e;\n\n/**\n * Get effective value for a config key, considering CLI override.\n */\nexport function getConfigValue\u003cT\u003e(config: VaultEvalConfig, path: string, cliOverride?: T): T;\n```\n\n## Exit Criteria\n\n- Loads config from both locations\n- Merges with correct precedence (CLI \u003e vault \u003e global \u003e default)\n- Deep merges nested objects (partial overrides work)\n- Invalid config files show helpful error messages\n- `vault-eval config show --json` dumps effective config\n\n## Dependencies\n\n- **Blocked by**: scribe-use.1 (package must exist)\n\n## Used By\n\n- scribe-use.9 (retrieve - scoring weights)\n- scribe-use.10 (context - token budget, strategy)\n- scribe-use.22 (hybrid scoring - weights)\n\n## Phase\n\nPhase 4 - Quality \u0026 Polish\n\n## Estimated Time\n\n2-3 hours","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T05:56:49.388423-06:00","updated_at":"2025-12-15T21:15:32.390649-06:00","closed_at":"2025-12-15T21:15:32.390649-06:00","dependencies":[{"issue_id":"scribe-use.28","depends_on_id":"scribe-use","type":"parent-child","created_at":"2025-12-15T05:56:49.388765-06:00","created_by":"daemon"},{"issue_id":"scribe-use.28","depends_on_id":"scribe-use.2","type":"blocks","created_at":"2025-12-15T06:06:50.963757-06:00","created_by":"daemon"},{"issue_id":"scribe-use.28","depends_on_id":"scribe-use.3","type":"blocks","created_at":"2025-12-15T06:06:51.011336-06:00","created_by":"daemon"},{"issue_id":"scribe-use.28","depends_on_id":"scribe-use.4","type":"blocks","created_at":"2025-12-15T06:06:51.059134-06:00","created_by":"daemon"}]}
{"id":"scribe-use.29","title":"Write integration tests for all commands","description":"## Overview\n\nWrite comprehensive integration tests for all vault-eval commands using the test fixture vault.\n\n## Test File Structure\n\n```\npackages/vault-eval/tests/\n  integration/\n    info.test.ts\n    read.test.ts\n    search.test.ts\n    recent.test.ts\n    retrieve.test.ts\n    context.test.ts\n    outline.test.ts\n    backlinks.test.ts\n    graph.test.ts\n    tasks.test.ts\n    lint.test.ts\n    linkcheck.test.ts\n  unit/\n    args.test.ts\n    formatters.test.ts\n    headings.test.ts\n    excerpts.test.ts\n    traversal.test.ts\n    hybrid.test.ts\n```\n\n## Test Categories per Command\n\n### Basic Commands (info, read, search, recent)\n- Valid input produces expected JSON structure\n- Missing/invalid vault path returns error\n- `--json` flag produces valid JSON\n- Empty results handled gracefully\n\n### Complex Commands (retrieve, context, outline, backlinks)\n- Scoring/ranking produces expected order\n- Token budget respected\n- Excerpt extraction works\n- Backlink context extracted correctly\n\n### Graph Command\n- Depth limiting works correctly\n- Direction filtering works\n- All output formats (json, dot, mermaid) valid\n- Cycles don't cause infinite loops\n\n### Tasks Command\n- Status filtering works\n- Priority post-filtering works\n- Pagination with cursors works\n- Sort order correct\n\n### Quality Commands (lint, linkcheck)\n- All checks run and report issues\n- `--fix` applies fixes correctly\n- Exit codes reflect severity\n- Quarantine files listed\n\n## Test Utilities\n\n```typescript\n// test-utils.ts\nexport const FIXTURE_VAULT_PATH = 'tests/fixtures/vault';\n\nexport async function runCommand(args: string[]): Promise\u003c{\n  stdout: string;\n  stderr: string;\n  exitCode: number;\n}\u003e;\n\nexport function parseJsonOutput\u003cT\u003e(stdout: string): T;\n\nexport function assertJsonSchema\u003cT\u003e(data: unknown, schema: ZodSchema\u003cT\u003e): asserts data is T;\n```\n\n## Coverage Requirements\n\n- Each command has at least 5 test cases\n- Error paths tested (invalid input, missing files)\n- All JSON output fields validated\n- Exit codes verified\n\n## Exit Criteria\n\n- All 12 commands have integration tests\n- Tests pass with fixture vault\n- Tests run in \u003c 30 seconds total\n- CI integration via `turbo run test`\n\n## Dependencies\n\n- **Blocked by**: scribe-use.23 (test fixtures), all command implementations\n\n## Phase\n\nPhase 4 - Quality \u0026 Polish\n\n## Estimated Time\n\n6-8 hours","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T05:57:00.1305-06:00","updated_at":"2025-12-15T21:23:26.404013-06:00","closed_at":"2025-12-15T21:23:26.404013-06:00","dependencies":[{"issue_id":"scribe-use.29","depends_on_id":"scribe-use","type":"parent-child","created_at":"2025-12-15T05:57:00.130838-06:00","created_by":"daemon"},{"issue_id":"scribe-use.29","depends_on_id":"scribe-use.23","type":"blocks","created_at":"2025-12-15T06:06:53.73397-06:00","created_by":"daemon"},{"issue_id":"scribe-use.29","depends_on_id":"scribe-use.5","type":"blocks","created_at":"2025-12-15T06:06:53.784903-06:00","created_by":"daemon"},{"issue_id":"scribe-use.29","depends_on_id":"scribe-use.6","type":"blocks","created_at":"2025-12-15T06:06:53.832719-06:00","created_by":"daemon"},{"issue_id":"scribe-use.29","depends_on_id":"scribe-use.7","type":"blocks","created_at":"2025-12-15T06:06:53.878922-06:00","created_by":"daemon"},{"issue_id":"scribe-use.29","depends_on_id":"scribe-use.8","type":"blocks","created_at":"2025-12-15T06:06:53.926908-06:00","created_by":"daemon"},{"issue_id":"scribe-use.29","depends_on_id":"scribe-use.9","type":"blocks","created_at":"2025-12-15T06:06:53.976717-06:00","created_by":"daemon"},{"issue_id":"scribe-use.29","depends_on_id":"scribe-use.10","type":"blocks","created_at":"2025-12-15T06:06:54.025408-06:00","created_by":"daemon"},{"issue_id":"scribe-use.29","depends_on_id":"scribe-use.11","type":"blocks","created_at":"2025-12-15T06:06:54.073867-06:00","created_by":"daemon"},{"issue_id":"scribe-use.29","depends_on_id":"scribe-use.12","type":"blocks","created_at":"2025-12-15T06:06:54.120623-06:00","created_by":"daemon"},{"issue_id":"scribe-use.29","depends_on_id":"scribe-use.13","type":"blocks","created_at":"2025-12-15T06:06:54.166698-06:00","created_by":"daemon"},{"issue_id":"scribe-use.29","depends_on_id":"scribe-use.14","type":"blocks","created_at":"2025-12-15T06:06:54.212432-06:00","created_by":"daemon"},{"issue_id":"scribe-use.29","depends_on_id":"scribe-use.26","type":"blocks","created_at":"2025-12-15T06:06:54.260172-06:00","created_by":"daemon"},{"issue_id":"scribe-use.29","depends_on_id":"scribe-use.27","type":"blocks","created_at":"2025-12-15T06:06:54.308305-06:00","created_by":"daemon"}]}
{"id":"scribe-use.3","title":"Implement EngineLoader for lazy engine initialization","description":"## Overview\n\nCreate the EngineLoader class that manages lazy initialization of FileSystemVault, SearchEngine, GraphEngine, and TaskIndex.\n\n---\n\n## Why Lazy Loading?\n\nvault-eval commands have different engine requirements:\n- `vault info` needs all engines for stats\n- `vault search` only needs SearchEngine\n- `vault recent` only needs FileSystemVault\n- `vault tasks` needs TaskIndex\n\nLoading all engines upfront would:\n- Waste time for simple commands\n- Consume unnecessary memory\n- Slow down startup for large vaults\n\nLazy loading means each engine initializes on first access and caches for the session.\n\n---\n\n## Existing Code Reference\n\nCheck how the desktop app initializes these in `apps/desktop/electron/main/src/main.ts` (lines 66-103). The pattern there should be replicated.\n\n---\n\n## Implementation Details\n\n### index/loader.ts\n\n```typescript\nimport { FileSystemVault } from '@scribe/storage-fs';\nimport { SearchEngine } from '@scribe/engine-search';\nimport { GraphEngine } from '@scribe/engine-graph';\nimport type { Note } from '@scribe/shared';\nimport * as path from 'path';\n\n/**\n * Lazy loader for Scribe engines.\n * \n * Engines are initialized on first access and cached for the session.\n * Only FileSystemVault.load() is async - all engine constructors are sync.\n */\nexport class EngineLoader {\n  private searchEngine?: SearchEngine;\n  private graphEngine?: GraphEngine;\n  private vault?: FileSystemVault;\n  private taskIndex?: TaskIndex;\n  private loaded = false;\n\n  constructor(private vaultPath: string) {}\n\n  /**\n   * Ensure vault is loaded. Safe to call multiple times.\n   */\n  async ensureLoaded(): Promise\u003cvoid\u003e {\n    if (this.loaded) return;\n    \n    this.vault = new FileSystemVault(this.vaultPath);\n    await this.vault.load();  // Only async operation - reads files from disk\n    this.loaded = true;\n  }\n\n  /**\n   * Get the FileSystemVault instance.\n   */\n  async getVault(): Promise\u003cFileSystemVault\u003e {\n    await this.ensureLoaded();\n    return this.vault!;\n  }\n\n  /**\n   * Get SearchEngine, indexing all notes on first call.\n   */\n  async getSearchEngine(): Promise\u003cSearchEngine\u003e {\n    await this.ensureLoaded();\n    \n    if (!this.searchEngine) {\n      this.searchEngine = new SearchEngine();  // Sync constructor\n      const notes = this.vault!.list();\n      for (const note of notes) {\n        this.searchEngine.indexNote(note);\n      }\n    }\n    return this.searchEngine;\n  }\n  \n  /**\n   * Get GraphEngine, indexing all notes on first call.\n   */\n  async getGraphEngine(): Promise\u003cGraphEngine\u003e {\n    await this.ensureLoaded();\n    \n    if (!this.graphEngine) {\n      this.graphEngine = new GraphEngine();  // Sync constructor\n      const notes = this.vault!.list();\n      for (const note of notes) {\n        this.graphEngine.addNote(note);\n      }\n    }\n    return this.graphEngine;\n  }\n\n  /**\n   * Get TaskIndex, loading persisted tasks and indexing notes.\n   * \n   * NOTE: TaskIndex must be imported directly from internal path \n   * to avoid pulling Node.js deps into browser bundles. This is \n   * documented in @scribe/engine-core/src/index.ts.\n   */\n  async getTaskIndex(): Promise\u003cTaskIndex\u003e {\n    await this.ensureLoaded();\n    \n    if (!this.taskIndex) {\n      // Direct import required for Node.js/Bun contexts\n      const { TaskIndex } = await import('@scribe/engine-core/src/task-index.js');\n      const { JsonlTaskPersistence } = await import('@scribe/engine-core/src/task-persistence.js');\n      \n      const persistPath = path.join(this.vaultPath, '.scribe', 'tasks.jsonl');\n      const persistence = new JsonlTaskPersistence(persistPath);\n      this.taskIndex = new TaskIndex(persistence);\n      await this.taskIndex.load();\n      \n      // Index all notes to sync tasks\n      const notes = this.vault!.list();\n      for (const note of notes) {\n        this.taskIndex.indexNote(note);\n      }\n    }\n    return this.taskIndex;\n  }\n\n  /**\n   * Get all notes from the vault.\n   */\n  async getNotes(): Promise\u003cNote[]\u003e {\n    const vault = await this.getVault();\n    return vault.list();\n  }\n\n  /**\n   * Read a single note by ID.\n   */\n  async readNote(id: string): Promise\u003cNote | null\u003e {\n    const vault = await this.getVault();\n    try {\n      return await vault.read(id);\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Check if vault path exists and is a valid Scribe vault.\n   */\n  async validateVault(): Promise\u003c{ valid: boolean; error?: string }\u003e {\n    try {\n      const fs = await import('fs/promises');\n      const stat = await fs.stat(this.vaultPath);\n      if (!stat.isDirectory()) {\n        return { valid: false, error: 'Path is not a directory' };\n      }\n      \n      const notesDir = path.join(this.vaultPath, 'notes');\n      const notesStat = await fs.stat(notesDir).catch(() =\u003e null);\n      if (!notesStat?.isDirectory()) {\n        return { valid: false, error: 'Not a valid Scribe vault (missing notes/ directory)' };\n      }\n      \n      return { valid: true };\n    } catch (err) {\n      return { valid: false, error: 'Vault path does not exist' };\n    }\n  }\n}\n```\n\n---\n\n## Key Design Decisions\n\n1. **Lazy initialization**: Only load engines when first requested\n2. **Sync constructors**: SearchEngine and GraphEngine have sync constructors, only FileSystemVault.load() is async\n3. **TaskIndex direct import**: Must import from internal path to avoid browser bundle issues (see engine-core/src/index.ts note)\n4. **Caching**: Once an engine is loaded, it's cached for the session\n5. **Vault validation**: Helper method to check vault exists before loading\n\n---\n\n## TaskIndex Import Pattern\n\n**CRITICAL**: TaskIndex is NOT exported from `@scribe/engine-core`'s barrel file to avoid pulling Node.js dependencies into browser bundles. For vault-eval (CLI-only, Bun runtime), we import directly:\n\n```typescript\nconst { TaskIndex } = await import('@scribe/engine-core/src/task-index.js');\nconst { JsonlTaskPersistence } = await import('@scribe/engine-core/src/task-persistence.js');\n```\n\nThis is safe because vault-eval will never run in a browser.\n\n---\n\n## Exit Criteria\n\n- [ ] EngineLoader can load vault and list notes\n- [ ] Each engine getter only initializes on first call (verify with console.log timing)\n- [ ] TaskIndex imports from internal path without errors\n- [ ] validateVault() correctly detects invalid vaults\n- [ ] Unit tests verify:\n  - Lazy loading behavior (second call returns cached)\n  - Error handling for invalid vault paths\n  - All four engines load correctly\n\n---\n\n## Dependencies\n\n- **Blocked by**: scribe-use.1 (package scaffolding)\n\n## Parallelization\n\nCan be developed in parallel with:\n- scribe-use.2 (CLI parser)\n- scribe-use.4 (formatters)\n\nAll command implementations depend on this.\n\n---\n\n## Estimated Time\n\n2-3 hours\n\n---\n\n## Reference\n\nSee `features/vault-eval/spec.md` sections:\n- Engine API Reference\n- Engine Initialization","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-14T00:22:12.892855-06:00","updated_at":"2025-12-15T20:49:31.97389-06:00","closed_at":"2025-12-15T20:49:31.97389-06:00","dependencies":[{"issue_id":"scribe-use.3","depends_on_id":"scribe-use","type":"parent-child","created_at":"2025-12-14T00:22:12.893215-06:00","created_by":"daemon"},{"issue_id":"scribe-use.3","depends_on_id":"scribe-use.1","type":"blocks","created_at":"2025-12-14T00:33:49.622859-06:00","created_by":"daemon"}]}
{"id":"scribe-use.30","title":"Set up binary build pipeline","description":"## Overview\n\nConfigure Bun's binary compilation and integrate with CI/release workflow.\n\n## Build Targets\n\n| Target | Output | Platform |\n|--------|--------|----------|\n| `bun-darwin-arm64` | `vault-eval-darwin-arm64` | macOS Apple Silicon |\n| `bun-darwin-x64` | `vault-eval-darwin-x64` | macOS Intel |\n| `bun-linux-x64` | `vault-eval-linux-x64` | Linux x64 |\n| `bun-windows-x64` | `vault-eval-windows-x64.exe` | Windows x64 |\n\n## Package.json Scripts\n\n```json\n{\n  \"scripts\": {\n    \"build\": \"bun build src/cli.ts --compile --minify --target=bun-darwin-arm64 --outfile dist/vault-eval-darwin-arm64\",\n    \"build:all\": \"bun run build:darwin-arm64 \u0026\u0026 bun run build:darwin-x64 \u0026\u0026 bun run build:linux-x64 \u0026\u0026 bun run build:windows-x64\",\n    \"build:darwin-arm64\": \"bun build src/cli.ts --compile --minify --target=bun-darwin-arm64 --outfile dist/vault-eval-darwin-arm64\",\n    \"build:darwin-x64\": \"bun build src/cli.ts --compile --minify --target=bun-darwin-x64 --outfile dist/vault-eval-darwin-x64\",\n    \"build:linux-x64\": \"bun build src/cli.ts --compile --minify --target=bun-linux-x64 --outfile dist/vault-eval-linux-x64\",\n    \"build:windows-x64\": \"bun build src/cli.ts --compile --minify --target=bun-windows-x64 --outfile dist/vault-eval-windows-x64.exe\"\n  }\n}\n```\n\n## CI Integration\n\n### .github/workflows/ci-pr.yml additions\n\n```yaml\n- name: Build vault-eval binaries\n  run: |\n    cd packages/vault-eval\n    bun run build:all\n    \n- name: Verify binary works\n  run: |\n    ./packages/vault-eval/dist/vault-eval-darwin-arm64 --version\n```\n\n### Release workflow additions\n\n```yaml\n- name: Upload vault-eval binaries\n  uses: actions/upload-artifact@v4\n  with:\n    name: vault-eval-binaries\n    path: packages/vault-eval/dist/*\n```\n\n## .gitignore Updates\n\n```\npackages/vault-eval/dist/\n```\n\n## Turbo Configuration\n\nAdd to `turbo.json`:\n```json\n{\n  \"pipeline\": {\n    \"build:binary\": {\n      \"dependsOn\": [\"build\"],\n      \"outputs\": [\"dist/**\"]\n    }\n  }\n}\n```\n\n## Exit Criteria\n\n- All 4 platform binaries compile successfully\n- Binaries are self-contained (no runtime deps)\n- CI builds and verifies binaries\n- Release workflow uploads binaries as artifacts\n- Binary size \u003c 80MB per platform\n\n## Dependencies\n\n- **Blocked by**: All command implementations complete\n\n## Phase\n\nPhase 4 - Quality \u0026 Polish\n\n## Estimated Time\n\n2-3 hours","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T05:57:10.011839-06:00","updated_at":"2025-12-15T21:20:58.741405-06:00","closed_at":"2025-12-15T21:20:58.741405-06:00","dependencies":[{"issue_id":"scribe-use.30","depends_on_id":"scribe-use","type":"parent-child","created_at":"2025-12-15T05:57:10.012202-06:00","created_by":"daemon"},{"issue_id":"scribe-use.30","depends_on_id":"scribe-use.29","type":"blocks","created_at":"2025-12-15T06:06:54.423426-06:00","created_by":"daemon"}]}
{"id":"scribe-use.4","title":"Implement JSON and text output formatters","description":"## Overview\n\nCreate consistent output formatters for JSON and human-readable text output.\n\n---\n\n## Why Consistent Formatters?\n\nAll vault-eval commands need to:\n1. Output JSON for programmatic consumption (LLM tool-calling)\n2. Optionally output human-readable text for debugging\n3. Format errors consistently across commands\n4. Use consistent exit codes\n\nCentralizing this in formatters ensures:\n- Consistent JSON schema across commands\n- Consistent error format for error handling\n- Single place to add features like pretty-printing\n\n---\n\n## Implementation Details\n\n### formatters/json.ts\n\n```typescript\ninterface OutputOptions {\n  prettyPrint?: boolean;\n}\n\n/**\n * Format data as JSON string.\n */\nexport function formatJson(data: unknown, options?: OutputOptions): string {\n  return JSON.stringify(data, null, options?.prettyPrint ? 2 : undefined);\n}\n\n/**\n * Standard error output schema for all commands.\n */\nexport interface ErrorOutput {\n  error: true;\n  code: ErrorCode;\n  message: string;\n  details?: Record\u003cstring, unknown\u003e;\n}\n\nexport type ErrorCode = \n  | 'VAULT_NOT_FOUND'      // Vault directory doesn't exist\n  | 'VAULT_INVALID'        // Directory exists but isn't a valid vault\n  | 'NOTE_NOT_FOUND'       // Specified note ID doesn't exist\n  | 'INVALID_QUERY'        // Query syntax error\n  | 'INVALID_ARGUMENT'     // Invalid command-line argument\n  | 'INDEX_ERROR'          // Search/graph index corruption\n  | 'IO_ERROR'             // File system read/write error\n  | 'INTERNAL_ERROR';      // Unexpected exception\n\n/**\n * Format an error for JSON output.\n */\nexport function formatError(\n  code: ErrorCode, \n  message: string, \n  details?: Record\u003cstring, unknown\u003e\n): string {\n  return formatJson({ error: true, code, message, details });\n}\n\n/**\n * Write JSON output to stdout.\n */\nexport function writeJson(data: unknown, options?: OutputOptions): void {\n  console.log(formatJson(data, options));\n}\n\n/**\n * Write JSON error to stderr.\n */\nexport function writeError(code: ErrorCode, message: string, details?: Record\u003cstring, unknown\u003e): void {\n  console.error(formatError(code, message, details));\n}\n```\n\n### formatters/text.ts\n\n```typescript\nimport type { Note, Task } from '@scribe/shared';\nimport { extractTextFromNodes } from '@scribe/shared';\n\ninterface VaultStats {\n  path: string;\n  totalNotes: number;\n  byType: Record\u003cstring, number\u003e;\n  openTasks: number;\n  completedTasks: number;\n  graphNodes: number;\n  graphEdges: number;\n}\n\n/**\n * Format vault stats for human-readable output.\n */\nexport function formatVaultStats(stats: VaultStats): string {\n  const lines = [\n    `Vault: ${stats.path}`,\n    `Notes: ${stats.totalNotes} (${Object.entries(stats.byType).map(([t, c]) =\u003e `${t}: ${c}`).join(', ')})`,\n    `Tasks: ${stats.openTasks} open, ${stats.completedTasks} completed`,\n    `Graph: ${stats.graphNodes} nodes, ${stats.graphEdges} edges`,\n  ];\n  return lines.join('\\n');\n}\n\n/**\n * Format note for text output.\n */\nexport function formatNote(note: Note): string {\n  const lines = [\n    `# ${note.title ?? 'Untitled'}`,\n    '',\n    `ID: ${note.id}`,\n    `Type: ${note.type ?? 'regular'}`,\n    `Updated: ${new Date(note.updatedAt).toISOString()}`,\n    note.tags?.length ? `Tags: ${note.tags.join(', ')}` : null,\n    '',\n    extractTextFromNodes(note.content.root.children),\n  ].filter(Boolean);\n  return lines.join('\\n');\n}\n\n/**\n * Format search results as a list.\n */\nexport function formatSearchResults(results: SearchResultOutput[]): string {\n  if (results.length === 0) {\n    return 'No results found.';\n  }\n  \n  return results.map((r, i) =\u003e \n    `${i + 1}. ${r.title} (score: ${r.score.toFixed(2)})\\n   ${r.snippet}`\n  ).join('\\n\\n');\n}\n\n/**\n * Format task list.\n */\nexport function formatTasks(tasks: TaskOutput[]): string {\n  if (tasks.length === 0) {\n    return 'No tasks found.';\n  }\n  \n  return tasks.map(t =\u003e \n    `[${t.completed ? 'x' : ' '}] ${t.text} (P${t.priority})`\n  ).join('\\n');\n}\n```\n\n---\n\n## Exit Codes\n\n| Code | Meaning | Used When |\n|------|---------|-----------|\n| `0` | Success | Command completed successfully |\n| `1` | Command error | Invalid args, note not found, invalid query |\n| `2` | Vault error | Vault not initialized, corrupted, permission denied |\n| `3` | Internal error | Unexpected exception, bug |\n\n---\n\n## Error Output Examples\n\n### JSON Error (--json)\n```json\n{\n  \"error\": true,\n  \"code\": \"NOTE_NOT_FOUND\",\n  \"message\": \"Note 'abc123' not found in vault\",\n  \"details\": {\n    \"noteId\": \"abc123\",\n    \"vaultPath\": \"/path/to/vault\"\n  }\n}\n```\n\n### Text Error\n```\nError: Note 'abc123' not found in vault\n```\n\n---\n\n## Exit Criteria\n\n- [ ] JSON output is consistent across all commands\n- [ ] Error format matches spec exactly with correct error codes\n- [ ] Text output is readable and informative\n- [ ] formatError() produces valid JSON\n- [ ] Exit codes are used correctly throughout CLI\n- [ ] Unit tests verify JSON schema compliance\n- [ ] Pretty-print option works for debugging\n\n---\n\n## Dependencies\n\n- **Blocked by**: scribe-use.1 (package scaffolding)\n- **Used by**: All command implementations\n\n## Parallelization\n\nCan be developed in parallel with:\n- scribe-use.2 (CLI parser)\n- scribe-use.3 (EngineLoader)\n\n---\n\n## Estimated Time\n\n1-2 hours\n\n---\n\n## Reference\n\nSee `features/vault-eval/spec.md` sections:\n- Error Output Schema\n- Exit Codes","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-14T00:22:23.462257-06:00","updated_at":"2025-12-15T20:48:31.644478-06:00","closed_at":"2025-12-15T20:48:31.644478-06:00","dependencies":[{"issue_id":"scribe-use.4","depends_on_id":"scribe-use","type":"parent-child","created_at":"2025-12-14T00:22:23.462612-06:00","created_by":"daemon"},{"issue_id":"scribe-use.4","depends_on_id":"scribe-use.1","type":"blocks","created_at":"2025-12-14T00:33:49.675072-06:00","created_by":"daemon"}]}
{"id":"scribe-use.5","title":"Implement `vault info` command","description":"## Overview\n\nImplement the `vault info` command that shows vault statistics and metadata for LLM context gathering.\n\n---\n\n## Why This Command?\n\nBefore searching a vault, an LLM needs to understand what's in it:\n- How many notes? What types?\n- What are the common tags?\n- How many tasks are open?\n- When was the vault last modified?\n\nThis is typically the FIRST command an LLM should run to understand the vault landscape.\n\n---\n\n## Command Specification\n\n```bash\nvault-eval info --json\nvault-eval info --include-quarantine --json\n```\n\n### Options\n| Flag | Type | Default | Description |\n|------|------|---------|-------------|\n| `--include-quarantine` | boolean | false | Include quarantined file info |\n| `--json` | boolean | true | JSON output (default for this command) |\n| `--vault, -v` | string | cwd | Vault path |\n\n### JSON Output\n```json\n{\n  \"vault\": {\n    \"path\": \"/Users/name/Documents/my-vault\",\n    \"version\": \"1.0.0\"\n  },\n  \"stats\": {\n    \"totalNotes\": 523,\n    \"byType\": {\n      \"regular\": 450,\n      \"daily\": 45,\n      \"meeting\": 18,\n      \"person\": 8,\n      \"project\": 2,\n      \"template\": 0\n    },\n    \"totalTasks\": 127,\n    \"openTasks\": 43,\n    \"completedTasks\": 84\n  },\n  \"tags\": {\n    \"total\": 89,\n    \"top\": [\n      { \"tag\": \"meeting\", \"count\": 45 },\n      { \"tag\": \"project-alpha\", \"count\": 32 },\n      { \"tag\": \"todo\", \"count\": 28 }\n    ]\n  },\n  \"graph\": {\n    \"nodes\": 523,\n    \"edges\": 1847,\n    \"orphanNotes\": 12\n  },\n  \"activity\": {\n    \"lastModified\": \"2025-01-15T14:30:00Z\",\n    \"modifiedLast7Days\": 23,\n    \"modifiedLast30Days\": 89\n  },\n  \"quarantine\": {\n    \"count\": 2,\n    \"files\": [\"notes/corrupted-abc.json\", \"notes/invalid-xyz.json\"]\n  }\n}\n```\n\n---\n\n## Implementation\n\n```typescript\n// File: packages/vault-eval/src/commands/info.ts\n\nimport { EngineLoader } from '../index/loader.js';\nimport { writeJson, writeError } from '../formatters/json.js';\nimport { getBoolean } from '../args.js';\nimport type { CommandContext } from '../types.js';\n\nexport async function infoCommand(ctx: CommandContext): Promise\u003cnumber\u003e {\n  const { vaultPath, flags } = ctx;\n  const includeQuarantine = getBoolean(flags, 'include-quarantine');\n  \n  const loader = new EngineLoader(vaultPath);\n  \n  // Validate vault exists\n  const validation = await loader.validateVault();\n  if (!validation.valid) {\n    writeError('VAULT_INVALID', validation.error!);\n    return 2;\n  }\n  \n  // Load engines\n  const vault = await loader.getVault();\n  const graph = await loader.getGraphEngine();\n  const taskIndex = await loader.getTaskIndex();\n  \n  const notes = vault.list();\n  const graphStats = graph.getStats();\n  \n  // Build stats\n  const byType = countByType(notes);\n  const taskSummary = getTaskSummary(taskIndex);\n  const tagCounts = getTopTags(graph, 10);\n  const orphans = countOrphans(graph, notes);\n  const activity = getActivityStats(notes);\n  \n  const output = {\n    vault: { path: vaultPath, version: '1.0.0' },\n    stats: { totalNotes: notes.length, byType, ...taskSummary },\n    tags: { total: tagCounts.length, top: tagCounts.slice(0, 10) },\n    graph: { nodes: graphStats.nodes, edges: graphStats.edges, orphanNotes: orphans },\n    activity,\n    ...(includeQuarantine \u0026\u0026 { quarantine: getQuarantineInfo(vault) })\n  };\n  \n  writeJson(output, { prettyPrint: true });\n  return 0;\n}\n```\n\n### Helper Functions\n```typescript\nfunction countByType(notes: Note[]): Record\u003cstring, number\u003e;\nfunction getTaskSummary(taskIndex: TaskIndex): { totalTasks, openTasks, completedTasks };\nfunction getTopTags(graph: GraphEngine, limit: number): Array\u003c{ tag: string; count: number }\u003e;\nfunction countOrphans(graph: GraphEngine, notes: Note[]): number;\nfunction getActivityStats(notes: Note[]): { lastModified, modifiedLast7Days, modifiedLast30Days };\nfunction getQuarantineInfo(vault: FileSystemVault): { count, files };\n```\n\n---\n\n## Exit Criteria\n\n- [ ] Command outputs all stats in specified JSON format\n- [ ] Works with empty vault (all stats = 0)\n- [ ] `--include-quarantine` shows corrupted files\n- [ ] Exit code 0 on success, 2 on vault error\n- [ ] Performance: \u003c500ms for 500-note vault\n- [ ] Unit tests verify stat calculations\n\n---\n\n## Dependencies\n\n- **Blocked by**: scribe-use.2 (CLI parser), scribe-use.3 (EngineLoader), scribe-use.4 (formatters)\n\n## Parallelization\n\nCan be developed in parallel with other Phase 2 commands (.6, .7, .8, .14) once foundation is ready.\n\n---\n\n## Estimated Time\n\n2-3 hours\n\n---\n\n## Reference\n\nSee `features/vault-eval/spec.md` section: Commands Specification - `vault info`","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-14T00:22:45.771324-06:00","updated_at":"2025-12-15T20:57:32.469604-06:00","closed_at":"2025-12-15T20:57:32.469604-06:00","dependencies":[{"issue_id":"scribe-use.5","depends_on_id":"scribe-use","type":"parent-child","created_at":"2025-12-14T00:22:45.771673-06:00","created_by":"daemon"},{"issue_id":"scribe-use.5","depends_on_id":"scribe-use.2","type":"blocks","created_at":"2025-12-14T00:33:53.566943-06:00","created_by":"daemon"},{"issue_id":"scribe-use.5","depends_on_id":"scribe-use.3","type":"blocks","created_at":"2025-12-14T00:33:53.617537-06:00","created_by":"daemon"},{"issue_id":"scribe-use.5","depends_on_id":"scribe-use.4","type":"blocks","created_at":"2025-12-14T00:33:53.664999-06:00","created_by":"daemon"}]}
{"id":"scribe-use.6","title":"Implement `vault read` command","description":"## Overview\n\nImplement the `vault read` command that retrieves full content of a specific note by ID.\n\n---\n\n## Why This Command?\n\nAfter search/retrieve finds relevant notes, the LLM needs to read full content. This command provides:\n- Full note content (not just excerpts)\n- Metadata (type, tags, dates)\n- Optional backlink context\n\n---\n\n## Command Specification\n\n```bash\nvault read --id abc123 --json\nvault read --id abc123 --format text\nvault read --id abc123 --include-backlinks --json\n```\n\n### Options\n| Flag | Type | Default | Description |\n|------|------|---------|-------------|\n| `--id` | string | required | Note ID |\n| `--format` | string | json | Output format: json, text, markdown |\n| `--include-backlinks` | boolean | false | Include list of backlinks |\n| `--json` | boolean | false | JSON output |\n| `--vault, -v` | string | cwd | Vault path |\n\n### JSON Output\n```json\n{\n  \"id\": \"abc123\",\n  \"title\": \"Project Alpha Kickoff\",\n  \"type\": \"meeting\",\n  \"createdAt\": \"2025-01-10T09:00:00Z\",\n  \"updatedAt\": \"2025-01-15T10:30:00Z\",\n  \"tags\": [\"meeting\", \"project-alpha\"],\n  \"metadata\": {\n    \"tags\": [\"kickoff\"],\n    \"links\": [\"def456\", \"ghi789\"],\n    \"mentions\": [\"person-alice\", \"person-bob\"]\n  },\n  \"content\": {\n    \"text\": \"# Agenda\\n\\nDiscussed project timeline...\",\n    \"tokens\": 450,\n    \"wordCount\": 320\n  },\n  \"meeting\": {\n    \"date\": \"2025-01-10\",\n    \"dailyNoteId\": \"daily-2025-01-10\",\n    \"attendees\": [\"person-alice\", \"person-bob\"]\n  },\n  \"backlinks\": [\n    { \"id\": \"jkl012\", \"title\": \"Weekly Review\", \"context\": \"...referenced [[Project Alpha Kickoff]] for...\" }\n  ]\n}\n```\n\n### Text Output (--format text)\n```\n# Project Alpha Kickoff\n\nDiscussed project timeline...\n[full plain text extracted from Lexical content]\n```\n\n---\n\n## Implementation Details\n\n1. Parse `--id` flag (required)\n2. Load vault via EngineLoader\n3. Call `vault.read(noteId)` - throws if not found\n4. Extract plain text from Lexical content using `extractTextFromNodes()`\n5. Calculate token estimate: `Math.ceil(text.length / 4)`\n6. If `--include-backlinks`, get backlinks from GraphEngine and extract context\n7. Format output based on `--format` flag\n\n---\n\n## Exit Criteria\n\n- [ ] Returns note in all three formats (json, text, markdown)\n- [ ] `NOTE_NOT_FOUND` error for invalid IDs\n- [ ] Backlinks include context when `--include-backlinks`\n- [ ] Token estimation works\n- [ ] Meeting/daily-specific fields included when applicable\n- [ ] Unit tests verify output formats\n\n---\n\n## Dependencies\n\n- **Blocked by**: scribe-use.2, scribe-use.3, scribe-use.4\n- **Uses**: scribe-use.19 (extractLinkContext) for backlink context\n\n## Parallelization\n\nCan be developed in parallel with other Phase 2 commands.\n\n---\n\n## Estimated Time\n\n2-3 hours\n\n---\n\n## Reference\n\nSee `features/vault-eval/spec.md` section: Commands Specification - `vault read`","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-14T00:23:01.259449-06:00","updated_at":"2025-12-15T20:55:50.049562-06:00","closed_at":"2025-12-15T20:55:50.049562-06:00","dependencies":[{"issue_id":"scribe-use.6","depends_on_id":"scribe-use","type":"parent-child","created_at":"2025-12-14T00:23:01.25979-06:00","created_by":"daemon"},{"issue_id":"scribe-use.6","depends_on_id":"scribe-use.2","type":"blocks","created_at":"2025-12-14T00:33:58.507013-06:00","created_by":"daemon"},{"issue_id":"scribe-use.6","depends_on_id":"scribe-use.3","type":"blocks","created_at":"2025-12-14T00:33:58.558372-06:00","created_by":"daemon"},{"issue_id":"scribe-use.6","depends_on_id":"scribe-use.4","type":"blocks","created_at":"2025-12-14T00:33:58.607237-06:00","created_by":"daemon"}]}
{"id":"scribe-use.7","title":"Implement `vault search` command","description":"## Overview\n\nImplement the `vault search` command that wraps the existing FlexSearch engine with enhanced output.\n\n---\n\n## Why This Command?\n\nFlexSearch is already implemented in `@scribe/engine-search`. This command exposes it via CLI with:\n- Normalized scores (0-1 range)\n- Snippet extraction\n- Field filtering\n- Pagination\n\n---\n\n## Command Specification\n\n```bash\nvault search --query \"meeting notes\" --limit 20 --json\nvault search -q \"project:alpha\" --fields title,tags --json\n```\n\n### Options\n| Flag | Type | Default | Description |\n|------|------|---------|-------------|\n| `--query, -q` | string | required | Search terms |\n| `--limit, -n` | number | 20 | Max results |\n| `--cursor` | string | - | Pagination cursor from previous query |\n| `--fields` | string | all | Output fields to include (title,tags,content,path) |\n| `--json` | boolean | false | JSON output |\n| `--vault, -v` | string | cwd | Vault path |\n\n### JSON Output\n```json\n{\n  \"query\": \"meeting notes\",\n  \"count\": 3,\n  \"totalMatches\": 3,\n  \"nextCursor\": null,\n  \"results\": [\n    {\n      \"id\": \"abc123\",\n      \"title\": \"Weekly Standup Notes\",\n      \"score\": 0.95,\n      \"rawScore\": 15,\n      \"snippet\": \"...discussed the **meeting** agenda for next week...\",\n      \"matches\": [\n        { \"field\": \"title\", \"term\": \"notes\" },\n        { \"field\": \"content\", \"term\": \"meeting\" }\n      ],\n      \"path\": \"notes/abc123.json\",\n      \"updatedAt\": \"2025-01-15T10:30:00Z\",\n      \"tags\": [\"meetings\", \"team\"]\n    }\n  ]\n}\n```\n\n---\n\n## Score Normalization\n\n- `rawScore`: Original FlexSearch weighted sum (title×10 + tags×5 + content×1)\n- `score`: Normalized to 0-1 range by dividing by max rawScore in result set\n\n**Important**: The `--fields` flag filters OUTPUT display, not search scope. FlexSearch always searches all indexed fields.\n\n---\n\n## Implementation Details\n\n1. Parse required `--query` flag\n2. Load SearchEngine via EngineLoader\n3. Call `searchEngine.search(query, limit)`\n4. Normalize scores against max rawScore\n5. Apply `--fields` filter to output\n6. Handle pagination via cursor encoding\n\n---\n\n## Exit Criteria\n\n- [ ] Returns search results in specified JSON format\n- [ ] Score normalization works correctly\n- [ ] Empty query returns error\n- [ ] `--fields` filter works for output\n- [ ] Pagination with cursors works\n- [ ] Unit tests verify score normalization\n\n---\n\n## Dependencies\n\n- **Blocked by**: scribe-use.2, scribe-use.3, scribe-use.4\n\n## Parallelization\n\nCan be developed in parallel with other Phase 2 commands.\n\n---\n\n## Estimated Time\n\n2-3 hours\n\n---\n\n## Reference\n\nSee `features/vault-eval/spec.md` section: Commands Specification - `vault search`","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-14T00:23:14.200314-06:00","updated_at":"2025-12-15T20:55:44.27912-06:00","closed_at":"2025-12-15T20:55:44.27912-06:00","dependencies":[{"issue_id":"scribe-use.7","depends_on_id":"scribe-use","type":"parent-child","created_at":"2025-12-14T00:23:14.200662-06:00","created_by":"daemon"},{"issue_id":"scribe-use.7","depends_on_id":"scribe-use.2","type":"blocks","created_at":"2025-12-14T00:33:58.656231-06:00","created_by":"daemon"},{"issue_id":"scribe-use.7","depends_on_id":"scribe-use.3","type":"blocks","created_at":"2025-12-14T00:33:58.703631-06:00","created_by":"daemon"},{"issue_id":"scribe-use.7","depends_on_id":"scribe-use.4","type":"blocks","created_at":"2025-12-14T00:33:58.75152-06:00","created_by":"daemon"}]}
{"id":"scribe-use.8","title":"Implement `vault recent` command","description":"## Overview\n\nImplement the `vault recent` command that lists notes modified within a time window, sorted by recency.\n\n---\n\n## Why This Command?\n\nLLMs need to understand \"what's happening now\" in a vault:\n- What notes were recently edited?\n- What new notes were created this week?\n- What daily/meeting notes exist for recent dates?\n\nThis command enables temporal awareness for LLM reasoning about recent activity and ongoing work.\n\n---\n\n## Command Specification\n\n```bash\nvault recent --days 7 --json\nvault recent --since 2025-01-10 --type meeting --json\nvault recent --since 2025-01-10 --until 2025-01-15 --limit 20 --json\n```\n\n### Options\n| Flag | Type | Default | Description |\n|------|------|---------|-------------|\n| `--days` | number | 7 | Days to look back |\n| `--since` | string | - | ISO date cutoff (mutually exclusive with --days) |\n| `--until` | string | - | ISO date upper bound |\n| `--type` | string | - | Filter by note type (regular, daily, meeting, person, project) |\n| `--limit` | number | 50 | Max results |\n| `--cursor` | string | - | Pagination cursor |\n| `--json` | boolean | false | JSON output |\n| `--vault, -v` | string | cwd | Vault path |\n\n### JSON Output\n```json\n{\n  \"since\": \"2025-01-08T00:00:00Z\",\n  \"until\": \"2025-01-15T23:59:59Z\",\n  \"count\": 12,\n  \"nextCursor\": null,\n  \"notes\": [\n    {\n      \"id\": \"pqr678\",\n      \"title\": \"Sprint Planning\",\n      \"type\": \"meeting\",\n      \"updatedAt\": \"2025-01-15T14:30:00Z\",\n      \"createdAt\": \"2025-01-15T14:00:00Z\",\n      \"isNew\": true,\n      \"tags\": [\"sprint\", \"planning\"]\n    }\n  ],\n  \"summary\": {\n    \"created\": 3,\n    \"modified\": 9,\n    \"byType\": { \"meeting\": 4, \"regular\": 6, \"daily\": 2 }\n  }\n}\n```\n\n---\n\n## Implementation Details\n\n### commands/recent.ts\n\n```typescript\nimport type { CommandContext } from '../types.js';\nimport { EngineLoader } from '../index/loader.js';\nimport { writeJson, writeError } from '../formatters/json.js';\nimport { getString, getNumber, getBoolean } from '../args.js';\nimport type { Note } from '@scribe/shared';\n\nexport async function recentCommand(ctx: CommandContext): Promise\u003cnumber\u003e {\n  const { vaultPath, flags } = ctx;\n  \n  // Parse date range options\n  const days = getNumber(flags, 'days');\n  const sinceStr = getString(flags, 'since');\n  const untilStr = getString(flags, 'until');\n  const noteType = getString(flags, 'type');\n  const limit = getNumber(flags, 'limit') ?? 50;\n  const cursor = getString(flags, 'cursor');\n  \n  // Compute date range\n  let since: Date;\n  let until: Date = new Date();\n  \n  if (sinceStr) {\n    since = new Date(sinceStr);\n    if (isNaN(since.getTime())) {\n      writeError('INVALID_ARGUMENT', `Invalid date format for --since: ${sinceStr}`);\n      return 1;\n    }\n  } else {\n    const lookbackDays = days ?? 7;\n    since = new Date(Date.now() - lookbackDays * 24 * 60 * 60 * 1000);\n  }\n  \n  if (untilStr) {\n    until = new Date(untilStr);\n    if (isNaN(until.getTime())) {\n      writeError('INVALID_ARGUMENT', `Invalid date format for --until: ${untilStr}`);\n      return 1;\n    }\n  }\n  \n  // Load vault\n  const loader = new EngineLoader(vaultPath);\n  const validation = await loader.validateVault();\n  if (!validation.valid) {\n    writeError('VAULT_INVALID', validation.error!);\n    return 2;\n  }\n  \n  const notes = await loader.getNotes();\n  \n  // Filter by date range\n  const sinceMs = since.getTime();\n  const untilMs = until.getTime();\n  \n  let filtered = notes.filter(note =\u003e \n    note.updatedAt \u003e= sinceMs \u0026\u0026 note.updatedAt \u003c= untilMs\n  );\n  \n  // Filter by type if specified\n  if (noteType) {\n    filtered = filtered.filter(note =\u003e note.type === noteType);\n  }\n  \n  // Sort by updatedAt descending\n  filtered.sort((a, b) =\u003e b.updatedAt - a.updatedAt);\n  \n  // Apply pagination\n  const offset = cursor ? decodeCursor(cursor) : 0;\n  const paginated = filtered.slice(offset, offset + limit);\n  const hasMore = offset + limit \u003c filtered.length;\n  \n  // Calculate summary stats\n  const created = filtered.filter(n =\u003e n.createdAt \u003e= sinceMs).length;\n  const modified = filtered.length - created;\n  const byType: Record\u003cstring, number\u003e = {};\n  for (const note of filtered) {\n    const type = note.type ?? 'regular';\n    byType[type] = (byType[type] ?? 0) + 1;\n  }\n  \n  // Format output\n  const output = {\n    since: since.toISOString(),\n    until: until.toISOString(),\n    count: paginated.length,\n    nextCursor: hasMore ? encodeCursor(offset + limit) : null,\n    notes: paginated.map(note =\u003e ({\n      id: note.id,\n      title: note.title ?? 'Untitled',\n      type: note.type ?? 'regular',\n      updatedAt: new Date(note.updatedAt).toISOString(),\n      createdAt: new Date(note.createdAt).toISOString(),\n      isNew: note.createdAt \u003e= sinceMs,\n      tags: note.tags ?? []\n    })),\n    summary: { created, modified, byType }\n  };\n  \n  writeJson(output, { prettyPrint: true });\n  return 0;\n}\n\n// Simple base64 cursor encoding\nfunction encodeCursor(offset: number): string {\n  return Buffer.from(JSON.stringify({ offset })).toString('base64');\n}\n\nfunction decodeCursor(cursor: string): number {\n  try {\n    const { offset } = JSON.parse(Buffer.from(cursor, 'base64').toString());\n    return offset ?? 0;\n  } catch {\n    return 0;\n  }\n}\n```\n\n---\n\n## Date Range Logic\n\nThe command supports two modes:\n1. **Relative**: `--days 7` → last 7 days from now\n2. **Absolute**: `--since 2025-01-10 --until 2025-01-15` → specific date range\n\nIf both `--days` and `--since` are provided, `--since` takes precedence.\n\n---\n\n## `isNew` Flag\n\nA note is marked `isNew: true` if its `createdAt` timestamp is within the query date range. This helps distinguish:\n- Newly created notes (isNew: true)\n- Existing notes that were modified (isNew: false)\n\n---\n\n## Exit Criteria\n\n- [ ] Returns notes modified in time window\n- [ ] `--days` and `--since`/`--until` work correctly\n- [ ] `--type` filter works for all note types\n- [ ] `isNew` flag correctly identifies newly created notes\n- [ ] Pagination with cursors works\n- [ ] Summary stats (created/modified/byType) are accurate\n- [ ] Sorted by updatedAt descending\n- [ ] Empty result returns empty array, not error\n- [ ] Unit tests verify date filtering logic\n\n---\n\n## Dependencies\n\n- **Blocked by**: scribe-use.2, scribe-use.3, scribe-use.4\n\n## Parallelization\n\nCan be developed in parallel with scribe-use.5, .6, .7, .14 once foundation is ready.\n\n---\n\n## Estimated Time\n\n1-2 hours\n\n---\n\n## Reference\n\nSee `features/vault-eval/spec.md` section: Commands Specification - `vault recent` (lines 1132-1176)","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-14T00:23:25.112052-06:00","updated_at":"2025-12-15T20:54:46.2826-06:00","closed_at":"2025-12-15T20:54:46.2826-06:00","dependencies":[{"issue_id":"scribe-use.8","depends_on_id":"scribe-use","type":"parent-child","created_at":"2025-12-14T00:23:25.112405-06:00","created_by":"daemon"},{"issue_id":"scribe-use.8","depends_on_id":"scribe-use.2","type":"blocks","created_at":"2025-12-14T00:33:58.799765-06:00","created_by":"daemon"},{"issue_id":"scribe-use.8","depends_on_id":"scribe-use.3","type":"blocks","created_at":"2025-12-14T00:33:58.846536-06:00","created_by":"daemon"},{"issue_id":"scribe-use.8","depends_on_id":"scribe-use.4","type":"blocks","created_at":"2025-12-14T00:33:58.8957-06:00","created_by":"daemon"}]}
{"id":"scribe-use.9","title":"Implement `vault retrieve` command with hybrid scoring","description":"## Overview\n\nImplement the `vault retrieve` command with multi-signal hybrid ranking combining text match, title match, tags, recency, and link centrality.\n\n---\n\n## Why This Command?\n\nSimple keyword search isn't enough for LLM context gathering:\n- **\"authentication\"** might match 50 notes - which are most relevant?\n- Recent notes about auth are probably more useful than 2-year-old ones\n- Notes linked by many others are probably authoritative\n- Title matches are stronger signals than content matches\n\n`vault retrieve` goes beyond simple search by combining 5 signals into a single relevance score.\n\n---\n\n## Command Specification\n\n```bash\nvault retrieve --query \"authentication design\" --k 10 --json\nvault retrieve -q \"onboarding\" --boost-recent --json\nvault retrieve -q \"API\" --tags architecture --exclude-tags draft --json\n```\n\n### Options\n| Flag | Type | Default | Description |\n|------|------|---------|-------------|\n| `--query, -q` | string | required | Query text |\n| `--k` | number | 20 | Top-k results |\n| `--boost-recent` | boolean | false | Weight recent edits higher |\n| `--boost-linked` | boolean | false | Weight highly-linked notes higher |\n| `--tags` | string | - | Required tags (comma-separated) |\n| `--exclude-tags` | string | - | Excluded tags |\n| `--type` | string | - | Note type filter |\n| `--json` | boolean | false | JSON output |\n| `--vault, -v` | string | cwd | Vault path |\n\n### JSON Output\n```json\n{\n  \"query\": \"authentication design\",\n  \"scoring\": {\n    \"weights\": { \"text\": 0.4, \"title\": 0.25, \"tags\": 0.15, \"recency\": 0.1, \"links\": 0.1 },\n    \"boosts\": { \"recent\": true, \"linked\": false }\n  },\n  \"count\": 10,\n  \"results\": [\n    {\n      \"id\": \"def456\",\n      \"title\": \"Auth Architecture Decision\",\n      \"score\": 0.87,\n      \"breakdown\": {\n        \"text\": 0.32,\n        \"title\": 0.25,\n        \"tags\": 0.15,\n        \"recency\": 0.08,\n        \"links\": 0.07\n      },\n      \"tags\": [\"architecture\", \"auth\", \"decision\"],\n      \"linkCount\": 5,\n      \"backlinkCount\": 12,\n      \"updatedAt\": \"2025-01-14T14:00:00Z\"\n    }\n  ]\n}\n```\n\n---\n\n## Scoring Formula\n\n```\nscore = (0.40 × text_match) \n      + (0.25 × title_match) \n      + (0.15 × tag_match) \n      + (0.10 × recency_decay) \n      + (0.10 × link_centrality)\n```\n\nAll components normalized to 0-1 range before weighting.\n\n---\n\n## Implementation Details\n\n### commands/retrieve.ts\n\n```typescript\nimport type { CommandContext } from '../types.js';\nimport { EngineLoader } from '../index/loader.js';\nimport { calculateHybridScore, DEFAULT_WEIGHTS, type ScoringConfig } from '../scoring/hybrid.js';\nimport { writeJson, writeError } from '../formatters/json.js';\nimport { getString, getNumber, getBoolean, getList } from '../args.js';\n\nexport async function retrieveCommand(ctx: CommandContext): Promise\u003cnumber\u003e {\n  const { vaultPath, flags } = ctx;\n  \n  const query = getString(flags, 'query') ?? getString(flags, 'q');\n  if (!query) {\n    writeError('INVALID_ARGUMENT', 'Missing required --query flag');\n    return 1;\n  }\n  \n  const k = getNumber(flags, 'k') ?? 20;\n  const boostRecent = getBoolean(flags, 'boost-recent');\n  const boostLinked = getBoolean(flags, 'boost-linked');\n  const requiredTags = getList(flags, 'tags');\n  const excludedTags = getList(flags, 'exclude-tags');\n  const noteType = getString(flags, 'type');\n  \n  // Load engines\n  const loader = new EngineLoader(vaultPath);\n  const searchEngine = await loader.getSearchEngine();\n  const graphEngine = await loader.getGraphEngine();\n  const notes = await loader.getNotes();\n  \n  // Build scoring config\n  const config: ScoringConfig = {\n    weights: DEFAULT_WEIGHTS,\n    boosts: {\n      recent: boostRecent ? { days: 7, multiplier: 1.5 } : undefined,\n      linked: boostLinked ? { threshold: 5, multiplier: 1.3 } : undefined\n    },\n    recencyHalfLifeDays: 30\n  };\n  \n  // Get initial search results (2x k for filtering headroom)\n  const searchResults = searchEngine.search(query, k * 2);\n  const maxRawScore = Math.max(...searchResults.map(r =\u003e r.score), 1);\n  \n  // Create note lookup for quick access\n  const noteMap = new Map(notes.map(n =\u003e [n.id, n]));\n  \n  // Score all candidates\n  let candidates = searchResults\n    .map(result =\u003e {\n      const note = noteMap.get(result.id);\n      if (!note) return null;\n      \n      const normalizedSearchScore = result.score / maxRawScore;\n      const { score, breakdown } = calculateHybridScore(\n        note, query, normalizedSearchScore, graphEngine, config\n      );\n      \n      const backlinks = graphEngine.backlinks(note.id);\n      const neighbors = graphEngine.neighbors(note.id);\n      \n      return {\n        id: note.id,\n        title: note.title ?? 'Untitled',\n        score,\n        breakdown,\n        tags: note.tags ?? [],\n        linkCount: neighbors.length - backlinks.length,  // Outgoing links\n        backlinkCount: backlinks.length,\n        updatedAt: new Date(note.updatedAt).toISOString()\n      };\n    })\n    .filter((c): c is NonNullable\u003ctypeof c\u003e =\u003e c !== null);\n  \n  // Apply tag filters\n  if (requiredTags.length \u003e 0) {\n    candidates = candidates.filter(c =\u003e \n      requiredTags.every(tag =\u003e c.tags.includes(tag))\n    );\n  }\n  if (excludedTags.length \u003e 0) {\n    candidates = candidates.filter(c =\u003e \n      !excludedTags.some(tag =\u003e c.tags.includes(tag))\n    );\n  }\n  \n  // Apply type filter\n  if (noteType) {\n    const noteTypeSet = new Set(candidates.map(c =\u003e noteMap.get(c.id)?.type));\n    candidates = candidates.filter(c =\u003e noteMap.get(c.id)?.type === noteType);\n  }\n  \n  // Sort by score and take top k\n  candidates.sort((a, b) =\u003e b.score - a.score);\n  const results = candidates.slice(0, k);\n  \n  // Format output\n  const output = {\n    query,\n    scoring: {\n      weights: {\n        text: config.weights.textMatch,\n        title: config.weights.titleMatch,\n        tags: config.weights.tagMatch,\n        recency: config.weights.recency,\n        links: config.weights.linkCentrality\n      },\n      boosts: { recent: boostRecent, linked: boostLinked }\n    },\n    count: results.length,\n    results\n  };\n  \n  writeJson(output, { prettyPrint: true });\n  return 0;\n}\n```\n\n---\n\n## Hybrid Scoring Module\n\nUses the `calculateHybridScore()` function from scribe-use.22:\n\n```typescript\n// From scoring/hybrid.ts\nfunction calculateHybridScore(\n  note: Note,\n  query: string,\n  searchScore: number,  // Pre-normalized 0-1\n  graph: GraphEngine,\n  config: ScoringConfig\n): ScoringResult {\n  // Compute all 5 components...\n  // Return { score, breakdown }\n}\n```\n\n---\n\n## Exit Criteria\n\n- [ ] Hybrid scoring works with all 5 signals\n- [ ] Score breakdown shows component contributions\n- [ ] `--boost-recent` and `--boost-linked` modify scores\n- [ ] Tag filtering works (include and exclude)\n- [ ] Type filtering works\n- [ ] Results sorted by combined score\n- [ ] Unit tests verify scoring math\n\n---\n\n## Dependencies\n\n- **Blocked by**: scribe-use.2, scribe-use.3, scribe-use.4, scribe-use.7, scribe-use.22\n- **Uses**: scribe-use.22 (hybrid scoring module)\n\n## Used By\n\n- scribe-use.10 (context command - uses retrieve for candidate selection)\n\n## Parallelization\n\nCan be developed after scribe-use.7 (search) and scribe-use.22 (hybrid scoring) are complete.\n\n---\n\n## Estimated Time\n\n2-3 hours\n\n---\n\n## Reference\n\nSee `features/vault-eval/spec.md` section:\n- Commands Specification - `vault retrieve` (lines 866-925)\n- Hybrid Scoring Algorithm (lines 1368-1426)","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-14T00:23:43.376463-06:00","updated_at":"2025-12-15T21:03:28.877613-06:00","closed_at":"2025-12-15T21:03:28.877613-06:00","dependencies":[{"issue_id":"scribe-use.9","depends_on_id":"scribe-use","type":"parent-child","created_at":"2025-12-14T00:23:43.3768-06:00","created_by":"daemon"},{"issue_id":"scribe-use.9","depends_on_id":"scribe-use.7","type":"blocks","created_at":"2025-12-14T00:34:05.875533-06:00","created_by":"daemon"},{"issue_id":"scribe-use.9","depends_on_id":"scribe-use.22","type":"blocks","created_at":"2025-12-14T00:34:05.926132-06:00","created_by":"daemon"},{"issue_id":"scribe-use.9","depends_on_id":"scribe-use.2","type":"blocks","created_at":"2025-12-14T08:55:28.721621-06:00","created_by":"daemon"},{"issue_id":"scribe-use.9","depends_on_id":"scribe-use.3","type":"blocks","created_at":"2025-12-14T08:55:28.76624-06:00","created_by":"daemon"},{"issue_id":"scribe-use.9","depends_on_id":"scribe-use.4","type":"blocks","created_at":"2025-12-14T08:55:28.809203-06:00","created_by":"daemon"}]}
{"id":"scribe-v3c","title":"search-engine silently swallows date parsing errors","description":"In packages/engine-search/src/search-engine.ts lines 86-88, date parsing errors are caught with empty handler. While intentional (invalid dates should use original title), the pattern is fragile. Consider using try-with-fallback pattern more explicitly or logging at debug level for troubleshooting.","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-12T21:00:05.881824-06:00","updated_at":"2025-12-12T23:59:46.14263-06:00","closed_at":"2025-12-12T23:59:46.14263-06:00","dependencies":[{"issue_id":"scribe-v3c","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:00:12.394846-06:00","created_by":"daemon"}]}
{"id":"scribe-vum","title":"Add JSDoc to FileSystemVault class and methods","description":"FileSystemVault in storage.ts lacks comprehensive documentation despite being a critical class.\n\n**Needs documentation:**\n\n**Class level:**\n- Overall purpose and responsibility\n- Thread-safety / concurrent access behavior\n- Constructor `vaultPath` parameter expectations\n\n**Methods:**\n- quarantineFile (lines 64-80) - naming convention, error handling\n- atomicWrite (lines 285-314) - performance, disk space, network filesystem behavior\n- isValidNote (lines 322-385) - validation rules, why fields are optional\n- migrateNote (lines 413-439) - migration scenarios, field precedence\n\n**Files:**\n- packages/storage-fs/src/storage.ts","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:20:07.221387-06:00","updated_at":"2025-12-13T00:34:39.622858-06:00","closed_at":"2025-12-13T00:34:39.622858-06:00","dependencies":[{"issue_id":"scribe-vum","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:20:26.568445-06:00","created_by":"daemon"}]}
{"id":"scribe-w3n","title":"Extract hardcoded CSS values to design tokens in design-system package","description":"Extract hardcoded CSS values to design tokens for consistency:\n\n**primitives/Overlay/Overlay.css.ts**\n- Line 16: `'150ms'` - should use vars.animation.duration.fast or similar\n- Line 22: `'rgba(0, 0, 0, 0.4)'` - BACKDROP_COLOR_TRANSPARENT\n- Line 25: `'rgba(0, 0, 0, 0.3)'` - BACKDROP_COLOR_BLUR\n- Line 26-27: `'blur(4px)'` - BACKDROP_BLUR_AMOUNT\n\n**tokens/animations.css.ts**\n- Line 78: `'1s'` in spin animation - should use vars.animation.duration token\n- Lines 22, 31: `'10px'` translateY offset - SLIDE_OFFSET token\n\nThe design system already has a token system (vars.animation.duration, etc.) - these values should be migrated to use existing tokens or new tokens should be added to contract.css.ts.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:00:38.334086-06:00","updated_at":"2025-12-13T01:38:47.643793-06:00","closed_at":"2025-12-13T01:38:47.643793-06:00","dependencies":[{"issue_id":"scribe-w3n","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:00:41.664077-06:00","created_by":"daemon"}]}
{"id":"scribe-wzv","title":"Extract shared PaletteItem component from CommandPalette browse modes","description":"CommandPalette.tsx (1339 lines) has 3 nearly identical render functions:\n- renderFileBrowseResults() (lines 804-889) \n- renderDeleteBrowseResults() (lines 892-963)\n- renderPersonBrowseResults() (lines 966-1035)\n\n~90% of the code is identical:\n1. Loading state rendering\n2. Empty state rendering  \n3. No results rendering\n4. Item rendering with icon, title, description, enter hint\n5. Mouse hover/click handlers\n6. Selected state styling\n\nDifferences are minimal:\n- Icon type (FileTextIcon vs UserIcon)\n- Empty state message text\n- Click handler action (navigate vs delete-confirm vs navigate)\n- Optional delete button on file-browse items\n\n**Suggested fix**: Extract a PaletteItem component and a PaletteItemList wrapper:\n\n```tsx\ninterface PaletteItemProps {\n  icon: ReactNode;\n  title: string;\n  description: string;\n  isSelected: boolean;\n  onClick: () =\u003e void;\n  onMouseEnter: () =\u003e void;\n  actions?: ReactNode; // For delete button\n}\n\ninterface PaletteItemListProps\u003cT\u003e {\n  items: T[];\n  isLoading: boolean;\n  emptyMessage: string;\n  noResultsMessage: string;\n  selectedIndex: number;\n  renderItem: (item: T, index: number) =\u003e PaletteItemProps;\n}\n```\n\nThis would reduce ~270 lines to ~50 lines.\n\nEstimate: ~2 hours","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:00:39.510106-06:00","updated_at":"2025-12-13T01:36:22.764501-06:00","closed_at":"2025-12-13T01:36:22.764501-06:00","dependencies":[{"issue_id":"scribe-wzv","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:00:42.664365-06:00","created_by":"daemon"}]}
{"id":"scribe-x6z","title":"Add tests for FloatingDock component","description":"FloatingDock.tsx has NO tests.\n\n**Files needing tests:**\n- apps/desktop/renderer/src/components/FloatingDock/FloatingDock.tsx\n\n**Test scenarios:**\n- Dock visibility\n- Action button clicks\n- Keyboard navigation\n- Position/styling\n\n**Files:**\n- apps/desktop/renderer/src/components/FloatingDock/*","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:27:38.507301-06:00","updated_at":"2025-12-13T01:24:52.107373-06:00","closed_at":"2025-12-13T01:24:52.107373-06:00","dependencies":[{"issue_id":"scribe-x6z","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:27:41.89076-06:00","created_by":"daemon"}]}
{"id":"scribe-xub","title":"Refactor FileSystemVault: Extract QuarantineManager for corrupt files","description":"FileSystemVault handles corrupt file quarantine inline (lines 64-80, 117-124). This is a cross-cutting concern that clutters the main load flow.\n\n**Extract: QuarantineManager**\n- Move quarantineFile() method\n- Move quarantinedFiles list tracking\n- Move getQuarantinedFiles() accessor\n- Add recovery/restore capabilities\n\n**Interface:**\n```typescript\ninterface QuarantineManager {\n  quarantine(sourcePath: string, reason: string): Promise\u003cvoid\u003e\n  listQuarantined(): string[]\n  restore(fileName: string): Promise\u003cvoid\u003e\n  deleteQuarantined(fileName: string): Promise\u003cvoid\u003e\n}\n```\n\n**Current behavior:**\n- Creates .scribe/quarantine/ directory\n- Renames file with ISO timestamp prefix\n- Tracks quarantined files in memory\n- Logs warning to console\n\n**Benefits:**\n- load() becomes cleaner (just call quarantine on parse failure)\n- Quarantine policy (what to quarantine, retention) centralized\n- Could add notifications for quarantined files\n- Recovery tooling lives in one place","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:01:08.373608-06:00","updated_at":"2025-12-13T00:23:19.51644-06:00","closed_at":"2025-12-13T00:23:19.51644-06:00","dependencies":[{"issue_id":"scribe-xub","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:01:11.49167-06:00","created_by":"daemon"}]}
{"id":"scribe-y7a","title":"Add tests for useScrollHeader hook","description":"apps/desktop/renderer/src/hooks/useScrollHeader.ts (99 lines) has NO tests.\n\n**What needs testing:**\n- Scroll position tracking\n- Parallax calculation\n- Header visibility state\n- Scroll direction detection\n- Performance (no excessive re-renders)\n\n**Files:**\n- apps/desktop/renderer/src/hooks/useScrollHeader.ts","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:19:20.424471-06:00","updated_at":"2025-12-13T01:20:49.295905-06:00","closed_at":"2025-12-13T01:20:49.295905-06:00","dependencies":[{"issue_id":"scribe-y7a","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:20:26.838601-06:00","created_by":"daemon"}]}
{"id":"scribe-ybm","title":"Add self-referencing note tests for GraphEngine","description":"Add tests for self-referencing notes in graph-engine.test.ts:\n- Note links to itself (metadata.links includes own ID)\n- backlinks() for self-referencing note\n- neighbors() for self-referencing note (should include self?)\n- Edge count when note links to itself\n- Updating self-referencing note (edge cleanup)\n- Removing self-referencing note\n\nThis is a valid edge case (e.g., recursive topic notes) that needs defined behavior.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:01:16.69194-06:00","updated_at":"2025-12-13T00:33:26.761778-06:00","closed_at":"2025-12-13T00:33:26.761778-06:00","dependencies":[{"issue_id":"scribe-ybm","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:01:19.782765-06:00","created_by":"daemon"}]}
{"id":"scribe-yhw","title":"Add tests for SlashMenuPlugin and SlashMenu components","description":"SlashMenu components have NO tests despite being 341+ lines of complex menu logic:\n\n**Files needing tests:**\n- apps/desktop/renderer/src/components/Editor/SlashMenu/SlashMenuPlugin.tsx (341 lines)\n- apps/desktop/renderer/src/components/Editor/SlashMenu/SlashMenu.tsx\n- apps/desktop/renderer/src/components/Editor/SlashMenu/SlashMenuItem.tsx\n- apps/desktop/renderer/src/components/Editor/SlashMenu/commands.ts (197 lines)\n\n**Test scenarios:**\n- Trigger detection (typing '/')\n- Menu positioning\n- Keyboard navigation (up/down/enter/escape)\n- Command filtering based on query\n- Command execution for each command type\n- Menu closing on blur/click outside\n- Nested menu state (if applicable)\n\n**Complexity:** These components handle:\n- Lexical editor integration\n- Keyboard event handling\n- Dynamic positioning\n- Command registry\n\n**Files:**\n- apps/desktop/renderer/src/components/Editor/SlashMenu/*","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:27:01.391259-06:00","updated_at":"2025-12-12T23:52:20.633714-06:00","closed_at":"2025-12-12T23:52:20.633714-06:00","dependencies":[{"issue_id":"scribe-yhw","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:27:10.284341-06:00","created_by":"daemon"}]}
{"id":"scribe-ys3","title":"Task key generation uses Math.random() despite 'deterministic' comment","description":"CRITICAL: In packages/engine-core/src/task-extraction.ts lines 169-171, getNodeKey() claims to generate a 'deterministic key from position' but uses Math.random(). This causes:\n1. Task IDs to change on every re-extraction\n2. Task reconciliation to fail (tasks appear as new/removed)\n3. Priority and completedAt metadata loss\n4. Potential duplicate tasks\n\nThe fallback should use actual deterministic data (parent key + index, or text hash). While the code says 'this shouldn't happen in practice', defensive code should still be correct.","acceptance_criteria":"- getNodeKey() uses deterministic data only (parent key + index, or text hash)\n- No Math.random() in any code path\n- Add unit test that extracts tasks twice and verifies stable IDs\n- Add test for task reconciliation preserving metadata","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-12T21:00:03.240413-06:00","updated_at":"2025-12-12T21:52:34.370494-06:00","closed_at":"2025-12-12T21:52:34.370494-06:00","dependencies":[{"issue_id":"scribe-ys3","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:00:11.604112-06:00","created_by":"daemon"}]}
{"id":"scribe-yzl","title":"Extract CollapsiblePanel primitive from Sidebar and ContextPanel","description":"Sidebar.css.ts and ContextPanel.css.ts have identical panel container patterns (~60 lines duplicated):\n\n**Duplicated Patterns:**\n1. CSS custom property for width (`sidebarWidth`/`panelWidth`)\n2. Main container style with identical transition, overflow, position, zIndex\n3. Open/closed variant styles with identical transform/opacity patterns\n4. Inner container with width variable binding\n\n**Solution:**\nExtract to a shared `CollapsiblePanel` primitive in the design system.\n\n**Files:**\n- apps/desktop/renderer/src/components/Sidebar/Sidebar.css.ts (lines 17-54)\n- apps/desktop/renderer/src/components/ContextPanel/ContextPanel.css.ts (lines 17-57)\n\n**Estimated savings:** ~60 lines","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-12T21:18:46.360252-06:00","updated_at":"2025-12-13T01:35:49.201403-06:00","closed_at":"2025-12-13T01:35:49.201403-06:00","dependencies":[{"issue_id":"scribe-yzl","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:20:26.996846-06:00","created_by":"daemon"}]}
{"id":"scribe-zz5","title":"Decouple shared types from Lexical editor internals","description":"**Problem**: The shared package (types.ts:44-58, 172) is tightly coupled to Lexical editor internals:\n- `LexicalState` and `LexicalNode` leak editor implementation details\n- `Note.content: LexicalState` forces all consumers to understand Lexical\n- `LexicalNode` uses `[key: string]: unknown` which is too permissive\n\n**Solution**:\n1. Define an abstract `NoteContent` type in shared\n2. Move Lexical-specific types to renderer or a dedicated `lexical-types` package\n3. Use a branded opaque type: `type NoteContent = { __contentFormat: 'lexical-v1' }`\n4. Add a `contentVersion` field for future format migrations\n\n**Alternative**: If Lexical types must stay, at least constrain `LexicalNode`:\n```typescript\ninterface LexicalNode {\n  type: LexicalNodeType; // union of known node types\n  version: number;\n  children?: LexicalNode[];\n  // other known fields...\n}\n```\n\n**Files**: packages/shared/src/types.ts\n**Impact**: Reduces coupling, enables future editor migrations","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-12T21:00:45.098387-06:00","updated_at":"2025-12-12T22:45:45.839615-06:00","closed_at":"2025-12-12T22:45:45.839615-06:00","dependencies":[{"issue_id":"scribe-zz5","depends_on_id":"scribe-0w9","type":"parent-child","created_at":"2025-12-12T21:00:47.75257-06:00","created_by":"daemon"},{"issue_id":"scribe-zz5","depends_on_id":"scribe-0fq","type":"related","created_at":"2025-12-12T21:42:15.698155-06:00","created_by":"daemon"}]}
