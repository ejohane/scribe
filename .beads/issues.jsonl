{"id":"scribe-58c","title":"In-Note Search with Cmd+F (Issue #46)","description":"## Overview\n\nImplement in-note text search functionality activated via `Cmd+F` (Mac) / `Ctrl+F` (Windows/Linux), allowing users to find text within the currently open note.\n\n## Why This Feature Matters\n\n**User Value:**\n- Quick navigation within long notes (meetings, technical docs, journals)\n- Standard keyboard shortcut users expect from any text editor\n- Reduces friction when working with content-heavy notes\n- Essential for productivity-focused users who keyboard-navigate\n\n**Product Strategy:**\n- Aligns with Scribe's goal of being a \"thinking partner\" that stays out of your way\n- Matches native app expectations (not a web app limitation)\n- Foundation for future Replace functionality (Phase 2, out of scope)\n\n## Technical Approach\n\nImplement as a **Lexical editor plugin** following established patterns:\n- `ManualSavePlugin` for keyboard command registration\n- `SelectionToolbarPlugin` for floating UI with portal rendering\n- `WikiLinkPlugin` for debounced search patterns\n\n**Key Dependencies:**\n- `@lexical/mark` - MarkNode for text highlighting without affecting document structure\n- `@lexical/text` - Text traversal utilities ($rootTextContent, $findTextIntersectionFromCharacters)\n\n**Architecture Decisions:**\n1. **Plugin Pattern**: Pure logic plugin + UI component via portal (same as SelectionToolbar)\n2. **Highlighting**: Use MarkNode with CSS-based styling (not inline styles) for theme consistency\n3. **State Management**: Custom hook (useFindReplace) for clean separation of concerns\n4. **Performance**: 150ms debounce on search, process matches in reverse order for offset stability\n5. **Undo/Redo**: All highlight operations use `{ discrete: true }` to exclude from history\n\n## Design Considerations\n\n**UI Placement:** Top-right fixed position (avoids collision with SelectionToolbar which appears near selection)\n**Visual Hierarchy:** Matches existing floating overlays (shadow, border, animation)\n**Accessibility:** Full ARIA support, keyboard navigation, screen reader announcements\n\n## Out of Scope (Future Work)\n\n- Replace functionality (Find \u0026 Replace)\n- Case sensitivity toggle\n- Regex/pattern search\n- Cross-note search (already exists via command palette)\n- Match whole word only\n- Search history persistence\n\n## Success Criteria\n\n1. Cmd+F opens search bar, Escape closes it\n2. All matches highlighted in yellow, current match in orange with outline\n3. Enter/Shift+Enter navigates between matches with wrap-around\n4. Clears highlights when closed or query emptied\n5. Does not pollute undo/redo history\n6. Works correctly with complex content (tables, lists, formatted text)\n7. Accessible via screen reader\n\n## Reference Files\n\n**Plugin Architecture:**\n- `apps/desktop/renderer/src/components/Editor/plugins/ManualSavePlugin.tsx`\n- `apps/desktop/renderer/src/components/Editor/SelectionToolbar/SelectionToolbarPlugin.tsx`\n\n**UI Patterns:**\n- `apps/desktop/renderer/src/components/Editor/SlashMenu/SlashMenu.css.ts`\n\n**Test Patterns:**\n- `apps/desktop/renderer/src/components/Editor/plugins/ManualSavePlugin.test.tsx`\n\n**Design System:**\n- `packages/design-system/src/tokens/contract.css.ts`\n- Icons: SearchIcon, ChevronUpIcon, ChevronDownIcon, CloseIcon already available","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-22T19:10:29.080581-06:00","updated_at":"2025-12-22T19:10:29.080581-06:00"}
{"id":"scribe-58c.1","title":"Phase 0: Dependencies and Configuration","description":"## Phase 0: Dependencies and Configuration\n\nThis phase sets up the foundation for the FindReplace feature by installing required packages and configuring the editor.\n\n### Tasks in This Phase\n1. **scribe-58c.2**: Add @lexical/mark and @lexical/text dependencies\n2. **scribe-58c.3**: Register MarkNode in EditorRoot config\n3. **scribe-58c.4**: Add search highlight CSS styles\n\n### Why This Phase First\n- All subsequent work depends on these packages being available\n- MarkNode must be registered before it can be used\n- CSS must exist for highlights to be visible\n\n### Estimated Phase Duration: 30-45 minutes","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-22T19:10:29.165781-06:00","updated_at":"2025-12-22T19:19:18.65347-06:00","closed_at":"2025-12-22T19:19:18.65347-06:00","dependencies":[{"issue_id":"scribe-58c.1","depends_on_id":"scribe-58c","type":"parent-child","created_at":"2025-12-22T19:10:29.166134-06:00","created_by":"daemon"}]}
{"id":"scribe-58c.10","title":"Write unit tests for useFindReplace hook","description":"## Task: Write unit tests for useFindReplace hook\n\n### What\nComprehensive unit tests for the useFindReplace hook.\n\n### Why\nThe hook contains critical business logic that must work correctly. Tests provide:\n- Confidence in implementation correctness\n- Regression prevention\n- Documentation of expected behavior\n- Safe refactoring in the future\n\n### Test Cases\n\n```typescript\ndescribe('useFindReplace', () =\u003e {\n  describe('search functionality', () =\u003e {\n    it('returns empty matches for empty query');\n    it('returns empty matches for whitespace-only query');\n    it('finds all occurrences of search term');\n    it('performs case-insensitive matching');\n    it('handles special regex characters in query');\n    it('finds overlapping matches (e.g., \"aa\" in \"aaa\")');\n    it('debounces rapid query changes (150ms)');\n  });\n\n  describe('highlight management', () =\u003e {\n    it('wraps matches in MarkNode with search-match ID');\n    it('clearSearch removes all search MarkNodes');\n    it('preserves non-search MarkNodes');\n    it('handles matches spanning multiple text nodes');\n  });\n\n  describe('navigation', () =\u003e {\n    it('goToNext advances activeIndex');\n    it('goToNext wraps from last to first');\n    it('goToPrevious decrements activeIndex');\n    it('goToPrevious wraps from first to last');\n    it('updates ACTIVE_MARK_ID on navigation');\n    it('scrolls active match into view');\n    it('is no-op when no matches');\n  });\n\n  describe('edge cases', () =\u003e {\n    it('handles empty document');\n    it('handles document with only whitespace');\n    it('handles query longer than document');\n    it('handles matches at document boundaries');\n    it('handles matches in tables');\n    it('handles matches in lists');\n    it('handles matches in formatted text (bold, italic)');\n  });\n\n  describe('cleanup', () =\u003e {\n    it('clears highlights when query emptied');\n    it('operations use discrete flag (no undo pollution)');\n  });\n});\n```\n\n### Test Setup Pattern\n\n```typescript\n// Follow ManualSavePlugin.test.tsx pattern\nfunction TestEditor({ children, editorRef }) {\n  return (\n    \u003cLexicalComposer initialConfig={{\n      namespace: 'test',\n      nodes: [MarkNode], // Include MarkNode for tests\n      onError: (error) =\u003e { throw error; },\n    }}\u003e\n      \u003cRichTextPlugin ... /\u003e\n      \u003cEditorCapture editorRef={editorRef} /\u003e\n      {children}\n    \u003c/LexicalComposer\u003e\n  );\n}\n\n// Custom hook testing with @testing-library/react\nimport { renderHook } from '@testing-library/react';\n```\n\n### Acceptance Criteria\n- [ ] All test cases implemented\n- [ ] Tests pass\n- [ ] Good coverage of happy path and edge cases\n- [ ] Tests are readable and serve as documentation\n\n### Dependencies\n- Requires: scribe-58c.9 (navigation implementation)\n\n### Estimated Effort: L (1-2 hours)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-22T19:10:29.917231-06:00","updated_at":"2025-12-22T19:19:35.636883-06:00","closed_at":"2025-12-22T19:19:35.636883-06:00","dependencies":[{"issue_id":"scribe-58c.10","depends_on_id":"scribe-58c","type":"parent-child","created_at":"2025-12-22T19:10:29.917571-06:00","created_by":"daemon"}]}
{"id":"scribe-58c.11","title":"Phase 2: UI Component (FindReplaceBar)","description":"## Phase 2: UI Component (FindReplaceBar)\n\nThis phase creates the user interface for the search feature.\n\n### Tasks in This Phase\n1. **scribe-58c.12**: CSS styles with design system tokens\n2. **scribe-58c.13**: FindReplaceBar React component\n3. **scribe-58c.14**: Keyboard shortcuts (Enter, Escape, Cmd+G)\n4. **scribe-58c.15**: Unit tests for component\n\n### UI Design\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ üîç [Search input        ] 1 of 15  ‚ñ≤  ‚ñº  ‚úï     ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n- Fixed position: top-right corner\n- Slide-in animation\n- Theme-aware (dark/light)\n- Accessible (ARIA, keyboard nav)\n\n### Estimated Phase Duration: 2-3 hours","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-22T19:10:29.996969-06:00","updated_at":"2025-12-22T19:19:20.44485-06:00","closed_at":"2025-12-22T19:19:20.44485-06:00","dependencies":[{"issue_id":"scribe-58c.11","depends_on_id":"scribe-58c","type":"parent-child","created_at":"2025-12-22T19:10:29.997356-06:00","created_by":"daemon"}]}
{"id":"scribe-58c.12","title":"Create FindReplaceBar.css.ts with design system tokens","description":"## Task: Create FindReplaceBar.css.ts with design system tokens\n\n### What\nCreate the stylesheet for the FindReplaceBar component using vanilla-extract and design system tokens.\n\n### Why\n- Consistent styling with rest of app\n- Theme-aware (works in dark/light mode)\n- Type-safe CSS via vanilla-extract\n- Follows established patterns (see SlashMenu.css.ts)\n\n### Implementation\n\n```typescript\nimport { style, keyframes } from '@vanilla-extract/css';\nimport { vars } from '@scribe/design-system';\n\nconst slideIn = keyframes({\n  from: { opacity: 0, transform: 'translateY(-8px)' },\n  to: { opacity: 1, transform: 'translateY(0)' },\n});\n\nexport const container = style({\n  position: 'fixed',\n  top: vars.spacing['4'],      // 16px from top\n  right: vars.spacing['4'],    // 16px from right\n  zIndex: vars.zIndex.popover, // 300 - above content, below modal\n  \n  display: 'flex',\n  alignItems: 'center',\n  gap: vars.spacing['2'],      // 8px between elements\n  padding: vars.spacing['2'],  // 8px all around\n  \n  backgroundColor: vars.color.background,\n  borderRadius: vars.radius.lg,\n  boxShadow: vars.shadow.lg,\n  border: `1px solid ${vars.color.border}`,\n  \n  animation: `${slideIn} ${vars.animation.duration.normal} ${vars.animation.easing.default}`,\n});\n\nexport const searchIcon = style({\n  color: vars.color.foregroundMuted,\n  flexShrink: 0,\n});\n\nexport const input = style({\n  width: '200px',\n  padding: `${vars.spacing['1']} ${vars.spacing['2']}`,\n  fontSize: vars.typography.size.sm,\n  fontFamily: vars.typography.fontFamily.ui,\n  backgroundColor: vars.color.surface,\n  border: `1px solid ${vars.color.border}`,\n  borderRadius: vars.radius.md,\n  color: vars.color.foreground,\n  outline: 'none',\n  \n  ':focus': {\n    borderColor: vars.color.accent,\n    boxShadow: `0 0 0 2px color-mix(in srgb, ${vars.color.accent} 20%, transparent)`,\n  },\n  \n  '::placeholder': {\n    color: vars.color.foregroundMuted,\n  },\n});\n\nexport const matchCount = style({\n  fontSize: vars.typography.size.xs,\n  color: vars.color.foregroundMuted,\n  minWidth: '56px',           // Prevent layout shift\n  textAlign: 'center',\n  whiteSpace: 'nowrap',\n});\n\nexport const noResults = style({\n  color: vars.color.danger,   // Red for \"no results\"\n});\n\nexport const navButton = style({\n  display: 'flex',\n  alignItems: 'center',\n  justifyContent: 'center',\n  width: '28px',\n  height: '28px',\n  borderRadius: vars.radius.sm,\n  backgroundColor: 'transparent',\n  border: 'none',\n  cursor: 'pointer',\n  color: vars.color.foreground,\n  transition: `all ${vars.animation.duration.fast}`,\n  \n  ':hover': {\n    backgroundColor: vars.color.surface,\n  },\n  \n  ':disabled': {\n    opacity: 0.5,\n    cursor: 'not-allowed',\n  },\n});\n\nexport const closeButton = style({\n  // Same as navButton, but with danger hover\n  display: 'flex',\n  alignItems: 'center',\n  justifyContent: 'center',\n  width: '28px',\n  height: '28px',\n  borderRadius: vars.radius.sm,\n  backgroundColor: 'transparent',\n  border: 'none',\n  cursor: 'pointer',\n  color: vars.color.foreground,\n  transition: `all ${vars.animation.duration.fast}`,\n  \n  ':hover': {\n    backgroundColor: vars.color.danger,\n    color: vars.color.accentForeground, // White text on red bg\n  },\n});\n```\n\n### Design Decisions\n- **Fixed positioning**: Always visible regardless of scroll\n- **Top-right placement**: Out of the way, doesn't obscure content\n- **Subtle animation**: Slide-in feels polished without being distracting\n- **Input width**: 200px is enough for typical search terms\n- **Button size**: 28px matches design system small button height\n\n### Acceptance Criteria\n- [ ] All styles use design system tokens\n- [ ] Works in dark theme\n- [ ] Works in light theme (test visually)\n- [ ] Animation is smooth\n- [ ] Focus states are visible\n\n### Dependencies\n- None (can be done in parallel with hook work)\n\n### Estimated Effort: S (20 minutes)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T19:10:30.082089-06:00","updated_at":"2025-12-22T19:20:50.200806-06:00","closed_at":"2025-12-22T19:20:50.200806-06:00","dependencies":[{"issue_id":"scribe-58c.12","depends_on_id":"scribe-58c","type":"parent-child","created_at":"2025-12-22T19:10:30.082401-06:00","created_by":"daemon"},{"issue_id":"scribe-58c.12","depends_on_id":"scribe-58c.7","type":"blocks","created_at":"2025-12-22T19:20:35.402934-06:00","created_by":"daemon"}]}
{"id":"scribe-58c.13","title":"Implement FindReplaceBar component (styles, keyboard, a11y) with tests","description":"## Implement FindReplaceBar Component (with styles, keyboard shortcuts, accessibility, tests)\n\n### What\nCreate the complete FindReplaceBar UI component including:\n- CSS styles using design system tokens (vanilla-extract)\n- React component with search input, match counter, navigation buttons\n- Keyboard shortcuts (Enter, Escape, Cmd+G)\n- Full accessibility (ARIA labels, focus management, announcements)\n- Unit tests\n\n### Files to Create\n```\napps/desktop/renderer/src/components/Editor/FindReplace/\n‚îú‚îÄ‚îÄ FindReplaceBar.tsx\n‚îú‚îÄ‚îÄ FindReplaceBar.css.ts\n‚îî‚îÄ‚îÄ FindReplaceBar.test.tsx\n```\n\n### UI Layout\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ üîç [Search input        ] 1 of 15  ‚ñ≤  ‚ñº  ‚úï     ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n### Keyboard Shortcuts\n- Escape: Close search bar\n- Enter: Next match\n- Shift+Enter: Previous match\n- Cmd/Ctrl+G: Next match (alternative)\n- Cmd/Ctrl+Shift+G: Previous match (alternative)\n\n### Accessibility Requirements\n- `role=\"search\"` on container\n- `aria-label` on input and buttons\n- `aria-live=\"polite\"` on match counter\n- Auto-focus input on open\n- Focus returns to editor on close\n\n### Icons\nUse existing: SearchIcon, ChevronUpIcon, ChevronDownIcon, CloseIcon\n\n### Acceptance Criteria\n- [ ] Component renders with all elements\n- [ ] Keyboard shortcuts work\n- [ ] Accessibility audit passes (no axe violations)\n- [ ] Unit tests pass\n\n### Estimated Effort: M (1.5-2 hours)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-22T19:10:30.164097-06:00","updated_at":"2025-12-22T19:21:11.60729-06:00","dependencies":[{"issue_id":"scribe-58c.13","depends_on_id":"scribe-58c","type":"parent-child","created_at":"2025-12-22T19:10:30.164457-06:00","created_by":"daemon"},{"issue_id":"scribe-58c.13","depends_on_id":"scribe-58c.12","type":"blocks","created_at":"2025-12-22T19:20:36.369471-06:00","created_by":"daemon"},{"issue_id":"scribe-58c.13","depends_on_id":"scribe-58c.7","type":"blocks","created_at":"2025-12-22T19:20:36.913832-06:00","created_by":"daemon"}]}
{"id":"scribe-58c.14","title":"Add keyboard shortcuts within FindReplaceBar (Enter, Escape, Cmd+G)","description":"## Task: Add keyboard shortcuts within FindReplaceBar\n\n### What\nImplement keyboard event handlers for the search bar component.\n\n### Why\nPower users expect keyboard navigation:\n- Enter to go to next match (universal pattern)\n- Shift+Enter to go to previous\n- Escape to close\n- Cmd/Ctrl+G as alternative navigation (common in editors)\n\n### Implementation\n\n```typescript\n// Handle keyboard shortcuts within the bar\nconst handleKeyDown = (e: React.KeyboardEvent) =\u003e {\n  if (e.key === 'Escape') {\n    e.preventDefault();\n    onClose();\n  } else if (e.key === 'Enter') {\n    e.preventDefault();\n    if (e.shiftKey) {\n      goToPrevious();\n    } else {\n      goToNext();\n    }\n  } else if (e.key === 'g' \u0026\u0026 (e.metaKey || e.ctrlKey)) {\n    e.preventDefault();\n    if (e.shiftKey) {\n      goToPrevious();\n    } else {\n      goToNext();\n    }\n  }\n};\n\n// In the component:\n\u003cdiv \n  className={styles.container}\n  onKeyDown={handleKeyDown}\n  role=\"search\"\n  aria-label=\"Find in note\"\n\u003e\n```\n\n### Keyboard Shortcut Reference\n\n| Shortcut | Action |\n|----------|--------|\n| `Escape` | Close search bar |\n| `Enter` | Go to next match |\n| `Shift+Enter` | Go to previous match |\n| `Cmd+G` / `Ctrl+G` | Go to next match (alternative) |\n| `Cmd+Shift+G` / `Ctrl+Shift+G` | Go to previous match (alternative) |\n\n### Event Handling Details\n\n**preventDefault():**\n- Escape: Prevent it from bubbling to other handlers\n- Enter: Prevent form submission (if wrapped in form)\n- Cmd+G: Prevent browser's \"Find Again\" (in some browsers)\n\n**Event Target:**\n- Handler on container div, not input\n- Captures all keyboard events in the search bar\n- Input still receives normal typing events\n\n### Acceptance Criteria\n- [ ] Escape closes the search bar\n- [ ] Enter goes to next match\n- [ ] Shift+Enter goes to previous match\n- [ ] Cmd+G goes to next match\n- [ ] Cmd+Shift+G goes to previous match\n- [ ] Ctrl+G works on Windows/Linux\n- [ ] Events are preventDefault'd appropriately\n\n### Dependencies\n- Requires: scribe-58c.13 (base component)\n\n### Estimated Effort: S (15 minutes)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T19:10:30.243563-06:00","updated_at":"2025-12-22T19:19:39.322593-06:00","closed_at":"2025-12-22T19:19:39.322593-06:00","dependencies":[{"issue_id":"scribe-58c.14","depends_on_id":"scribe-58c","type":"parent-child","created_at":"2025-12-22T19:10:30.243903-06:00","created_by":"daemon"}]}
{"id":"scribe-58c.15","title":"Write unit tests for FindReplaceBar component","description":"## Task: Write unit tests for FindReplaceBar component\n\n### What\nUnit tests for the FindReplaceBar UI component.\n\n### Why\n- Verify UI renders correctly\n- Test user interactions\n- Ensure keyboard shortcuts work\n- Accessibility validation\n\n### Test Cases\n\n```typescript\ndescribe('FindReplaceBar', () =\u003e {\n  const defaultProps = {\n    query: '',\n    setQuery: vi.fn(),\n    matches: [],\n    matchCount: 0,\n    activeIndex: 0,\n    goToNext: vi.fn(),\n    goToPrevious: vi.fn(),\n    clearSearch: vi.fn(),\n    onClose: vi.fn(),\n  };\n\n  describe('rendering', () =\u003e {\n    it('renders search input');\n    it('renders navigation buttons');\n    it('renders close button');\n    it('auto-focuses input on mount');\n    it('selects existing text on mount');\n  });\n\n  describe('match counter', () =\u003e {\n    it('shows nothing when query is empty');\n    it('shows \"X of Y\" when matches found');\n    it('shows \"No results\" when no matches and query exists');\n    it('applies danger styling to \"No results\"');\n  });\n\n  describe('button states', () =\u003e {\n    it('disables navigation when no matches');\n    it('enables navigation when matches exist');\n    it('close button is always enabled');\n  });\n\n  describe('callbacks', () =\u003e {\n    it('calls setQuery on input change');\n    it('calls goToNext on next button click');\n    it('calls goToPrevious on previous button click');\n    it('calls onClose on close button click');\n  });\n\n  describe('keyboard shortcuts', () =\u003e {\n    it('calls onClose on Escape');\n    it('calls goToNext on Enter');\n    it('calls goToPrevious on Shift+Enter');\n    it('calls goToNext on Cmd+G');\n    it('calls goToPrevious on Cmd+Shift+G');\n    it('calls goToNext on Ctrl+G');\n    it('calls goToPrevious on Ctrl+Shift+G');\n    it('prevents default for handled shortcuts');\n  });\n\n  describe('accessibility', () =\u003e {\n    it('has role=\"search\" on container');\n    it('has aria-label on container');\n    it('has aria-label on input');\n    it('has aria-live=\"polite\" on match counter');\n    it('buttons have aria-labels');\n  });\n});\n```\n\n### Testing Utilities\n\n```typescript\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\n\n// For keyboard events\nawait userEvent.type(input, 'search term');\nawait userEvent.keyboard('{Enter}');\nawait userEvent.keyboard('{Shift\u003e}{Enter}{/Shift}');\nawait userEvent.keyboard('{Control\u003e}g{/Control}');\n```\n\n### Acceptance Criteria\n- [ ] All test cases implemented\n- [ ] Tests pass\n- [ ] Good coverage of rendering, interactions, and accessibility\n- [ ] Uses @testing-library best practices (query by role/label)\n\n### Dependencies\n- Requires: scribe-58c.14 (keyboard shortcuts)\n\n### Estimated Effort: M (45 minutes)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-22T19:10:30.325903-06:00","updated_at":"2025-12-22T19:19:40.22175-06:00","closed_at":"2025-12-22T19:19:40.22175-06:00","dependencies":[{"issue_id":"scribe-58c.15","depends_on_id":"scribe-58c","type":"parent-child","created_at":"2025-12-22T19:10:30.326295-06:00","created_by":"daemon"}]}
{"id":"scribe-58c.16","title":"Phase 3: Plugin Integration (FindReplacePlugin)","description":"## Phase 3: Plugin Integration (FindReplacePlugin)\n\nThis phase creates the Lexical plugin that ties everything together.\n\n### Tasks in This Phase\n1. **scribe-58c.17**: Main plugin with Cmd+F handler\n2. **scribe-58c.18**: Cleanup logic for unmount/note switch\n3. **scribe-58c.19**: Register plugin in EditorRoot\n4. **scribe-58c.20**: Integration tests\n\n### Plugin Responsibilities\n- Register Cmd+F keyboard shortcut (COMMAND_PRIORITY_HIGH)\n- Manage open/close state\n- Connect useFindReplace hook to FindReplaceBar UI\n- Render via portal for proper z-index\n- Clean up on unmount\n\n### Integration Pattern\n```\nLexicalComposer\n  ‚îî‚îÄ FindReplacePlugin\n       ‚îú‚îÄ useFindReplace(editor) ‚Üí search state \u0026 actions\n       ‚îî‚îÄ Portal ‚Üí FindReplaceBar UI\n```\n\n### Estimated Phase Duration: 2-3 hours","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-22T19:10:30.411908-06:00","updated_at":"2025-12-22T19:19:21.402519-06:00","closed_at":"2025-12-22T19:19:21.402519-06:00","dependencies":[{"issue_id":"scribe-58c.16","depends_on_id":"scribe-58c","type":"parent-child","created_at":"2025-12-22T19:10:30.412276-06:00","created_by":"daemon"}]}
{"id":"scribe-58c.17","title":"Implement FindReplacePlugin (Cmd+F, cleanup) with integration tests","description":"## Implement FindReplacePlugin (with cleanup and integration tests)\n\n### What\nCreate the Lexical plugin that ties everything together:\n- Register Cmd/Ctrl+F keyboard shortcut\n- Manage open/close state\n- Connect useFindReplace hook to FindReplaceBar UI\n- Render via portal for proper z-index\n- Cleanup on unmount and note switch\n- Integration tests\n\n### Files to Create/Modify\n```\napps/desktop/renderer/src/components/Editor/FindReplace/\n‚îú‚îÄ‚îÄ FindReplacePlugin.tsx\n‚îî‚îÄ‚îÄ FindReplacePlugin.test.tsx\n```\n\n### Key Implementation Details\n- Use COMMAND_PRIORITY_HIGH to intercept before browser handles Cmd+F\n- Use createPortal to render to document.body\n- Return focus to editor on close\n- Clean up highlights on unmount\n\n### Integration Points\n- Import and use useFindReplace hook\n- Import and render FindReplaceBar\n- Follows patterns from ManualSavePlugin (keyboard) and SelectionToolbarPlugin (portal)\n\n### Acceptance Criteria\n- [ ] Cmd/Ctrl+F opens search bar\n- [ ] Browser find dialog does NOT open\n- [ ] Escape closes and clears highlights\n- [ ] Focus returns to editor on close\n- [ ] Cleanup works on unmount\n- [ ] Integration tests pass\n\n### Estimated Effort: M (1.5-2 hours)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-22T19:10:30.494902-06:00","updated_at":"2025-12-22T19:21:12.956923-06:00","dependencies":[{"issue_id":"scribe-58c.17","depends_on_id":"scribe-58c","type":"parent-child","created_at":"2025-12-22T19:10:30.495271-06:00","created_by":"daemon"},{"issue_id":"scribe-58c.17","depends_on_id":"scribe-58c.13","type":"blocks","created_at":"2025-12-22T19:20:37.56809-06:00","created_by":"daemon"}]}
{"id":"scribe-58c.18","title":"Add cleanup logic for note switching and unmount","description":"## Task: Add cleanup logic for note switching and unmount\n\n### What\nEnsure search highlights are properly cleaned up when:\n- User switches to a different note\n- Plugin unmounts\n- Editor instance changes\n\n### Why\nWithout cleanup:\n- Old highlights could persist into new notes (visual bugs)\n- Memory leaks from orphaned state\n- Confusing UX when highlights don't match current note\n\n### Implementation\n\n```typescript\n// Cleanup on unmount\nuseEffect(() =\u003e {\n  return () =\u003e {\n    findReplace.clearSearch();\n  };\n}, [findReplace]);\n\n// Optional: Close search when note changes\n// This requires passing noteId as a prop or using context\nuseEffect(() =\u003e {\n  // If noteId changes while search is open, close it\n  if (isOpen) {\n    handleClose();\n  }\n}, [noteId]); // Dependency on noteId if available\n\n// Alternative: Use editor event listener\nuseEffect(() =\u003e {\n  // Listen for editor content reset (which happens on note switch)\n  return editor.registerCommand(\n    CLEAR_HISTORY_COMMAND, // Fired when switching notes\n    () =\u003e {\n      if (isOpen) {\n        handleClose();\n      }\n      return false; // Don't consume the command\n    },\n    COMMAND_PRIORITY_LOW\n  );\n}, [editor, isOpen, handleClose]);\n```\n\n### Cleanup Scenarios\n\n| Scenario | Expected Behavior |\n|----------|-------------------|\n| User closes search bar | Clear highlights, return focus |\n| User switches notes | Close search bar, clear highlights |\n| Plugin unmounts | Clear highlights |\n| Editor remounts | Search state resets |\n\n### Edge Cases\n- User switches notes while typing in search\n- Rapid note switching\n- Note load failure during search\n\n### Acceptance Criteria\n- [ ] Highlights cleared on search bar close\n- [ ] Highlights cleared on plugin unmount\n- [ ] No errors when unmounting during search\n- [ ] State resets cleanly for new notes\n\n### Dependencies\n- Requires: scribe-58c.17 (base plugin)\n\n### Estimated Effort: S (20 minutes)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T19:10:30.577392-06:00","updated_at":"2025-12-22T19:19:46.287042-06:00","closed_at":"2025-12-22T19:19:46.287042-06:00","dependencies":[{"issue_id":"scribe-58c.18","depends_on_id":"scribe-58c","type":"parent-child","created_at":"2025-12-22T19:10:30.577761-06:00","created_by":"daemon"}]}
{"id":"scribe-58c.19","title":"Register FindReplacePlugin in EditorRoot.tsx","description":"## Task: Register FindReplacePlugin in EditorRoot.tsx\n\n### What\nAdd the FindReplacePlugin to the editor's plugin list in EditorRoot.tsx.\n\n### Why\nPlugins must be rendered within the LexicalComposer context to function. This is the final integration step.\n\n### Implementation\n\n```typescript\n// In EditorRoot.tsx\n\n// Add import\nimport { FindReplacePlugin } from './FindReplace';\n\n// In the JSX, add plugin\n\u003cLexicalComposer initialConfig={editorConfig}\u003e\n  \u003cdiv className={styles.editorContainer}\u003e\n    \u003cRichTextPlugin ... /\u003e\n    \u003cHistoryPlugin /\u003e\n    {/* ... other plugins ... */}\n    \n    {/* In-note search with Cmd+F */}\n    \u003cFindReplacePlugin /\u003e\n    \n    {/* Floating toolbar for text selection formatting */}\n    \u003cSelectionToolbarPlugin /\u003e\n    {/* Slash command menu */}\n    \u003cSlashMenuPlugin /\u003e\n  \u003c/div\u003e\n\u003c/LexicalComposer\u003e\n```\n\n### Plugin Order Considerations\n\nThe order of plugins matters for:\n1. **Keyboard priority**: Plugins registered later can override earlier ones if using same priority\n2. **Update listeners**: Plugins process updates in registration order\n\nFor FindReplacePlugin:\n- Uses COMMAND_PRIORITY_HIGH for Cmd+F\n- Should not conflict with other plugins\n- Order relative to SelectionToolbar/SlashMenu doesn't matter (different triggers)\n\n### Acceptance Criteria\n- [ ] Plugin imported from './FindReplace'\n- [ ] Plugin rendered within LexicalComposer\n- [ ] No TypeScript errors\n- [ ] Cmd+F works in the editor\n- [ ] No conflicts with existing plugins\n\n### Manual Verification\n1. Run the app\n2. Open a note\n3. Press Cmd+F\n4. Search bar should appear\n5. Type to search\n6. Navigate with Enter/Shift+Enter\n7. Close with Escape\n8. Highlights should clear\n\n### Dependencies\n- Requires: scribe-58c.18 (cleanup logic)\n- Requires: scribe-58c.3 (MarkNode registered)\n\n### Estimated Effort: XS (5 minutes)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-22T19:10:30.660088-06:00","updated_at":"2025-12-22T19:14:19.740177-06:00","dependencies":[{"issue_id":"scribe-58c.19","depends_on_id":"scribe-58c","type":"parent-child","created_at":"2025-12-22T19:10:30.660433-06:00","created_by":"daemon"},{"issue_id":"scribe-58c.19","depends_on_id":"scribe-58c.17","type":"blocks","created_at":"2025-12-22T19:20:38.37846-06:00","created_by":"daemon"},{"issue_id":"scribe-58c.19","depends_on_id":"scribe-58c.4","type":"blocks","created_at":"2025-12-22T19:20:39.522705-06:00","created_by":"daemon"}]}
{"id":"scribe-58c.2","title":"Add @lexical/mark and @lexical/text dependencies","description":"## Task: Add @lexical/mark and @lexical/text dependencies\n\n### What\nAdd the required Lexical packages to enable text highlighting and traversal.\n\n### Why\n- `@lexical/mark`: Provides `MarkNode` - a wrapper node that can apply visual styling to text spans without modifying the underlying text structure. Essential for highlighting search matches.\n- `@lexical/text`: Provides utilities like `$rootTextContent()` (get all text) and `$findTextIntersectionFromCharacters()` (locate text by character offset).\n\n### How\n```bash\ncd apps/desktop/renderer\nbun add @lexical/mark@^0.38.2 @lexical/text@^0.38.2\n```\n\n### Acceptance Criteria\n- [ ] Both packages added to `apps/desktop/renderer/package.json`\n- [ ] Versions match existing Lexical packages (^0.38.2)\n- [ ] `bun install` completes without errors\n- [ ] TypeScript can import from both packages\n\n### Notes\n- Version ^0.38.2 matches existing Lexical packages in the project\n- These are peer dependencies of the main `lexical` package, so version alignment is critical\n- No configuration changes needed - just package installation\n\n### Estimated Effort: XS (5 minutes)","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-22T19:10:29.245428-06:00","updated_at":"2025-12-22T19:26:25.325985-06:00","closed_at":"2025-12-22T19:26:25.325985-06:00","dependencies":[{"issue_id":"scribe-58c.2","depends_on_id":"scribe-58c","type":"parent-child","created_at":"2025-12-22T19:10:29.245831-06:00","created_by":"daemon"}]}
{"id":"scribe-58c.20","title":"Write integration tests for FindReplacePlugin","description":"## Task: Write integration tests for FindReplacePlugin\n\n### What\nIntegration tests that verify the plugin works correctly within the full Lexical editor context.\n\n### Why\n- Hook tests verify logic in isolation\n- Component tests verify UI in isolation\n- Integration tests verify everything works together\n\n### Test Cases\n\n```typescript\ndescribe('FindReplacePlugin', () =\u003e {\n  describe('keyboard activation', () =\u003e {\n    it('opens on Cmd+F (metaKey: true)');\n    it('opens on Ctrl+F (ctrlKey: true)');\n    it('prevents browser find from opening (preventDefault called)');\n    it('does not open on just F key');\n    it('does not open on Cmd+other keys');\n  });\n\n  describe('search and highlight', () =\u003e {\n    it('highlights matches in editor DOM (mark elements present)');\n    it('active match has distinct styling (search-match-active ID)');\n    it('updates highlights when query changes');\n    it('clears highlights when query is emptied');\n  });\n\n  describe('navigation', () =\u003e {\n    it('Enter navigates to next match');\n    it('Shift+Enter navigates to previous match');\n    it('navigation updates active match styling');\n    it('scrolls active match into view');\n  });\n\n  describe('close behavior', () =\u003e {\n    it('Escape closes search bar');\n    it('closing clears all highlights');\n    it('focus returns to editor after close');\n    it('Cmd+F reopens after close');\n  });\n\n  describe('cleanup', () =\u003e {\n    it('clears highlights on unmount');\n    it('removes command listener on unmount');\n    it('does not cause errors when unmounting during search');\n  });\n\n  describe('edge cases', () =\u003e {\n    it('handles empty document');\n    it('handles document with formatted text');\n    it('handles matches in tables');\n    it('handles matches in lists');\n    it('handles special characters in query');\n  });\n});\n```\n\n### Test Setup\n\n```typescript\n// Follow ManualSavePlugin.test.tsx pattern\nfunction TestEditor({ children, editorRef }) {\n  return (\n    \u003cLexicalComposer initialConfig={{\n      namespace: 'test',\n      nodes: [MarkNode, ...otherNodes],\n      onError: (error) =\u003e { throw error; },\n    }}\u003e\n      \u003cRichTextPlugin ... /\u003e\n      \u003cEditorCapture editorRef={editorRef} /\u003e\n      {children}\n    \u003c/LexicalComposer\u003e\n  );\n}\n\n// Helper to populate editor content\nasync function populateEditor(editor, text) {\n  await act(async () =\u003e {\n    editor.update(() =\u003e {\n      const root = $getRoot();\n      root.clear();\n      const paragraph = $createParagraphNode();\n      paragraph.append($createTextNode(text));\n      root.append(paragraph);\n    });\n  });\n}\n\n// Helper to dispatch keyboard events\nfunction dispatchKeyDown(editor, key, options = {}) {\n  const event = new KeyboardEvent('keydown', {\n    key,\n    metaKey: options.metaKey ?? false,\n    ctrlKey: options.ctrlKey ?? false,\n    shiftKey: options.shiftKey ?? false,\n    bubbles: true,\n    cancelable: true,\n  });\n  editor.getRootElement()?.dispatchEvent(event);\n}\n```\n\n### DOM Assertions\n\n```typescript\n// Check for mark elements\nconst marks = document.querySelectorAll('mark[data-lexical-mark-ids*=\"search-match\"]');\nexpect(marks.length).toBe(3);\n\n// Check for active mark\nconst activeMarks = document.querySelectorAll('mark[data-lexical-mark-ids*=\"search-match-active\"]');\nexpect(activeMarks.length).toBe(1);\n```\n\n### Acceptance Criteria\n- [ ] All test cases implemented\n- [ ] Tests pass\n- [ ] Covers keyboard activation, search, navigation, and cleanup\n- [ ] Uses realistic editor setup with MarkNode\n\n### Dependencies\n- Requires: scribe-58c.19 (plugin registered)\n\n### Estimated Effort: L (1-2 hours)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-22T19:10:30.742569-06:00","updated_at":"2025-12-22T19:19:47.411034-06:00","closed_at":"2025-12-22T19:19:47.411034-06:00","dependencies":[{"issue_id":"scribe-58c.20","depends_on_id":"scribe-58c","type":"parent-child","created_at":"2025-12-22T19:10:30.742953-06:00","created_by":"daemon"}]}
{"id":"scribe-58c.21","title":"Phase 4: Edge Cases and Polish","description":"## Phase 4: Edge Cases and Polish\n\nThis phase handles complex scenarios and ensures the feature is production-ready.\n\n### Tasks in This Phase\n1. **scribe-58c.22**: Handle tables, lists, formatted text\n2. **scribe-58c.23**: Accessibility audit and enhancements\n3. **scribe-58c.24**: Verify/add icons if needed\n\n### Edge Cases to Address\n- Matches spanning formatted text (bold **middle** word)\n- Text in table cells\n- Nested list items\n- Code blocks\n- Wiki-links and person mentions\n\n### Accessibility Checklist\n- [ ] role=\"search\" landmark\n- [ ] aria-live announcements\n- [ ] Focus management\n- [ ] Keyboard navigation\n- [ ] Screen reader testing\n\n### Estimated Phase Duration: 1-2 hours","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-22T19:10:30.824533-06:00","updated_at":"2025-12-22T19:19:22.234458-06:00","closed_at":"2025-12-22T19:19:22.234458-06:00","dependencies":[{"issue_id":"scribe-58c.21","depends_on_id":"scribe-58c","type":"parent-child","created_at":"2025-12-22T19:10:30.824893-06:00","created_by":"daemon"}]}
{"id":"scribe-58c.22","title":"Handle edge cases: tables, lists, formatted text","description":"## Task: Handle edge cases: tables, lists, formatted text\n\n### What\nEnsure search works correctly with complex document structures.\n\n### Why\nReal notes contain:\n- Tables with data\n- Nested lists\n- Formatted text (bold, italic, links)\n- Code blocks\n- Headings\n\nThe search implementation must handle text that spans multiple Lexical nodes.\n\n### Edge Cases to Handle\n\n**1. Formatted Text**\n- Query: \"hello world\"\n- Document: \"hello **world**\" (world is bold)\n- The text content is \"hello world\" but spans two nodes\n- Solution: `$wrapSelectionInMarkNode` handles this automatically\n\n**2. Tables**\n- Text in table cells should be searchable\n- `$rootTextContent()` includes table cell content\n- `$findTextIntersectionFromCharacters` traverses into tables\n\n**3. Nested Lists**\n- List items with sub-items\n- Text content is flattened for search\n- Highlights wrap correctly within list structure\n\n**4. Code Blocks**\n- Text in code blocks should be searchable\n- May want to preserve syntax highlighting (MarkNode doesn't interfere)\n\n**5. Links**\n- Link text should be searchable\n- Link node structure preserved when wrapped in MarkNode\n\n### Testing Strategy\n\n```typescript\ndescribe('edge cases', () =\u003e {\n  it('finds matches across formatted text', async () =\u003e {\n    await populateEditor(editor, () =\u003e {\n      const root = $getRoot();\n      const p = $createParagraphNode();\n      p.append(\n        $createTextNode('hello '),\n        $createTextNode('world').toggleFormat('bold')\n      );\n      root.append(p);\n    });\n    \n    // Search for \"hello world\"\n    // Should find 1 match spanning both nodes\n  });\n\n  it('finds matches in tables', async () =\u003e {\n    await populateEditor(editor, () =\u003e {\n      // Create table with text\n    });\n    // Verify search finds text in cells\n  });\n});\n```\n\n### Potential Issues\n\n1. **Match spans block boundaries**: \"hello\\n\\nworld\" - query \"hello world\" should NOT match (newlines are significant)\n2. **Invisible characters**: Some nodes insert characters for cursor placement\n3. **Performance with very long documents**: Consider chunked search for 100K+ character docs\n\n### Acceptance Criteria\n- [ ] Search works across bold/italic text\n- [ ] Search works in table cells\n- [ ] Search works in list items\n- [ ] Search works in code blocks\n- [ ] No errors with complex document structures\n- [ ] Edge case tests pass\n\n### Dependencies\n- Requires: scribe-58c.20 (integration tests as baseline)\n\n### Estimated Effort: M (30 minutes)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-22T19:10:30.904187-06:00","updated_at":"2025-12-22T19:19:41.988352-06:00","closed_at":"2025-12-22T19:19:41.988352-06:00","dependencies":[{"issue_id":"scribe-58c.22","depends_on_id":"scribe-58c","type":"parent-child","created_at":"2025-12-22T19:10:30.904595-06:00","created_by":"daemon"}]}
{"id":"scribe-58c.23","title":"Ensure accessibility: ARIA labels, focus management, announcements","description":"## Task: Ensure accessibility: ARIA labels, focus management, announcements\n\n### What\nAudit and enhance accessibility of the FindReplace feature.\n\n### Why\n- Screen reader users need to use search effectively\n- Keyboard-only users need clear navigation\n- WCAG compliance\n- Professional quality product\n\n### Accessibility Requirements\n\n**1. ARIA Attributes (Already Implemented)**\n```tsx\n\u003cdiv \n  role=\"search\"              // Landmark role\n  aria-label=\"Find in note\"  // Descriptive label\n\u003e\n  \u003cinput \n    aria-label=\"Search in note\"\n  /\u003e\n  \u003cspan \n    aria-live=\"polite\"  // Announce match count changes\n  \u003e\n    {matchCount}\n  \u003c/span\u003e\n  \u003cbutton aria-label=\"Previous match\" /\u003e\n  \u003cbutton aria-label=\"Next match\" /\u003e\n  \u003cbutton aria-label=\"Close search\" /\u003e\n\u003c/div\u003e\n```\n\n**2. Focus Management**\n- [x] Auto-focus input on open\n- [x] Select existing text for easy replacement\n- [ ] Focus trap within search bar? (probably not needed)\n- [x] Return focus to editor on close\n\n**3. Keyboard Navigation**\n- [x] Escape closes\n- [x] Enter/Shift+Enter navigates\n- [ ] Tab cycles through buttons\n- [ ] Focus visible on all interactive elements\n\n**4. Screen Reader Announcements**\n- `aria-live=\"polite\"` on match counter announces changes\n- Consider: \"X of Y matches\" vs \"1 of 15\" (more descriptive)\n- Consider: Announce when no results found\n\n### Enhancement: More Descriptive Announcements\n\n```tsx\n\u003cspan \n  aria-live=\"polite\"\n  role=\"status\"\n\u003e\n  {query ? (\n    matchCount \u003e 0 \n      ? `${activeIndex + 1} of ${matchCount} matches`  // More descriptive\n      : 'No matches found'\n  ) : ''}\n\u003c/span\u003e\n```\n\n### Testing Accessibility\n\n**Manual Testing:**\n1. Use VoiceOver (Mac) or NVDA (Windows)\n2. Navigate to search bar\n3. Enter query\n4. Listen for match count announcement\n5. Navigate between matches\n6. Close and verify editor focus\n\n**Automated Testing:**\n```typescript\nimport { axe, toHaveNoViolations } from 'jest-axe';\n\nit('has no accessibility violations', async () =\u003e {\n  const { container } = render(\u003cFindReplaceBar {...props} /\u003e);\n  const results = await axe(container);\n  expect(results).toHaveNoViolations();\n});\n```\n\n### Acceptance Criteria\n- [ ] All interactive elements have accessible names\n- [ ] Match counter announces changes via aria-live\n- [ ] Focus is managed correctly (open/close)\n- [ ] Keyboard navigation works for all actions\n- [ ] No axe-core violations\n- [ ] Manual screen reader testing passed\n\n### Dependencies\n- Requires: scribe-58c.15 (component tests)\n\n### Estimated Effort: S (30 minutes)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-22T19:10:30.984911-06:00","updated_at":"2025-12-22T19:19:42.9931-06:00","closed_at":"2025-12-22T19:19:42.9931-06:00","dependencies":[{"issue_id":"scribe-58c.23","depends_on_id":"scribe-58c","type":"parent-child","created_at":"2025-12-22T19:10:30.985289-06:00","created_by":"daemon"}]}
{"id":"scribe-58c.24","title":"Add ChevronLeftIcon and ChevronRightIcon to design system","description":"## Task: Add ChevronLeftIcon and ChevronRightIcon to design system\n\n### What\nExport ChevronLeft and ChevronRight icons from the design system for use in FindReplaceBar.\n\n### Why\nThe design system currently exports ChevronUp/ChevronDown but not Left/Right. However, looking at the FindReplaceBar design, we're actually using Up/Down for navigation (which makes sense for vertical scrolling through a document).\n\n### Analysis\n\nLooking at the current icon exports:\n```typescript\n// Already available:\nChevronDownIcon,\nChevronUpIcon,\n```\n\nFor the FindReplaceBar navigation, we have two options:\n1. **Use ChevronUp/ChevronDown** (recommended) - Matches the vertical scroll direction\n2. **Use ChevronLeft/ChevronRight** - More traditional but less intuitive for document navigation\n\n### Decision: Use Existing ChevronUp/ChevronDown\n\nAfter analysis, the existing icons are sufficient:\n- ChevronUpIcon for \"Previous match\"\n- ChevronDownIcon for \"Next match\"\n\nThis matches the mental model of scrolling through a vertical document.\n\n### Alternative: If Left/Right Preferred\n\n```typescript\n// In packages/design-system/src/icons/icons.tsx\nexport {\n  // ...existing exports\n  ChevronLeft as ChevronLeftIcon,\n  ChevronRight as ChevronRightIcon,\n} from 'lucide-react';\n\n// In packages/design-system/src/icons/index.ts\nexport {\n  // ...existing exports\n  ChevronLeftIcon,\n  ChevronRightIcon,\n} from './icons';\n```\n\n### Acceptance Criteria\n- [ ] Determine which icons to use (Up/Down vs Left/Right)\n- [ ] If new icons needed, add to icons.tsx and index.ts\n- [ ] Verify export works in FindReplaceBar\n\n### Note\nThis task may be a no-op if we use ChevronUp/ChevronDown as analyzed above.\n\n### Dependencies\n- None (design system change is independent)\n\n### Estimated Effort: XS (5 minutes) or N/A","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-22T19:10:31.064981-06:00","updated_at":"2025-12-22T19:19:27.689068-06:00","closed_at":"2025-12-22T19:19:27.689068-06:00","dependencies":[{"issue_id":"scribe-58c.24","depends_on_id":"scribe-58c","type":"parent-child","created_at":"2025-12-22T19:10:31.065321-06:00","created_by":"daemon"}]}
{"id":"scribe-58c.25","title":"Phase 5: Final QA and Documentation","description":"## Phase 5: Final QA and Documentation\n\nThis phase ensures the feature is fully tested and documented.\n\n### Tasks in This Phase\n1. **scribe-58c.26**: Manual QA on Mac, Windows, Linux\n2. **scribe-58c.27**: Run full test suite, fix regressions\n3. **scribe-58c.28**: Update CHANGELOG.md\n\n### QA Focus Areas\n- Platform-specific keyboard shortcuts\n- Visual consistency across themes\n- Performance with large documents\n- Integration with existing features\n\n### Definition of Done\n- [ ] All tests pass\n- [ ] No regressions\n- [ ] Manual QA approved on all platforms\n- [ ] Changelog updated\n- [ ] No accessibility violations\n\n### Estimated Phase Duration: 2-3 hours","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-22T19:10:31.145256-06:00","updated_at":"2025-12-22T19:19:23.557844-06:00","closed_at":"2025-12-22T19:19:23.557844-06:00","dependencies":[{"issue_id":"scribe-58c.25","depends_on_id":"scribe-58c","type":"parent-child","created_at":"2025-12-22T19:10:31.145639-06:00","created_by":"daemon"}]}
{"id":"scribe-58c.26","title":"Manual QA testing across platforms (Mac, Windows, Linux)","description":"## Task: Manual QA testing across platforms\n\n### What\nComprehensive manual testing of the FindReplace feature on Mac, Windows, and Linux.\n\n### Why\n- Keyboard shortcuts differ by platform\n- Rendering may differ\n- Electron behavior variations\n- Catch issues automated tests miss\n\n### Test Matrix\n\n| Platform | Shortcut | Test |\n|----------|----------|------|\n| macOS | Cmd+F | Opens search |\n| macOS | Cmd+G | Next match |\n| macOS | Cmd+Shift+G | Previous match |\n| Windows | Ctrl+F | Opens search |\n| Windows | Ctrl+G | Next match |\n| Windows | Ctrl+Shift+G | Previous match |\n| Linux | Ctrl+F | Opens search |\n| Linux | Ctrl+G | Next match |\n| Linux | Ctrl+Shift+G | Previous match |\n\n### Test Scenarios\n\n**1. Basic Flow**\n- [ ] Open note with content\n- [ ] Press Cmd/Ctrl+F\n- [ ] Search bar appears at top-right\n- [ ] Type search term\n- [ ] Matches highlighted in yellow\n- [ ] Current match in orange with outline\n- [ ] Match counter updates\n- [ ] Press Enter - next match\n- [ ] Press Shift+Enter - previous match\n- [ ] Press Escape - bar closes, highlights clear\n\n**2. Edge Cases**\n- [ ] Empty document - \"No results\"\n- [ ] No matches - \"No results\" in red\n- [ ] Single match - navigation stays on it\n- [ ] Match at document start\n- [ ] Match at document end\n- [ ] Matches in tables\n- [ ] Matches in lists\n- [ ] Matches spanning formatted text\n\n**3. Visual Verification**\n- [ ] Search bar positioning correct\n- [ ] Animation smooth\n- [ ] Highlights visible in dark theme\n- [ ] Highlights visible in light theme (if applicable)\n- [ ] Scroll to match works\n- [ ] Focus indicators visible\n\n**4. Integration**\n- [ ] Does not interfere with Cmd+S save\n- [ ] Does not interfere with Cmd+B bold\n- [ ] Works after note switch\n- [ ] Works with selection toolbar\n\n### Known Platform Quirks\n- **macOS**: Cmd+G may conflict with \"Find Again\" in some browsers\n- **Windows**: Ctrl+F may be intercepted by Electron shell\n- **Linux**: Keyboard events may have different key codes\n\n### Acceptance Criteria\n- [ ] All test scenarios pass on macOS\n- [ ] All test scenarios pass on Windows\n- [ ] All test scenarios pass on Linux\n- [ ] No visual regressions\n- [ ] No keyboard conflicts\n\n### Dependencies\n- Requires: scribe-58c.20 (feature complete)\n- Requires: Access to all three platforms\n\n### Estimated Effort: M (1 hour)","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-22T19:10:31.228582-06:00","updated_at":"2025-12-22T19:15:37.801509-06:00","dependencies":[{"issue_id":"scribe-58c.26","depends_on_id":"scribe-58c","type":"parent-child","created_at":"2025-12-22T19:10:31.228929-06:00","created_by":"daemon"},{"issue_id":"scribe-58c.26","depends_on_id":"scribe-58c.19","type":"blocks","created_at":"2025-12-22T19:20:43.995112-06:00","created_by":"daemon"}]}
{"id":"scribe-58c.27","title":"Run full test suite and fix any regressions","description":"## Task: Run full test suite and fix any regressions\n\n### What\nRun the complete test suite to catch any regressions introduced by the FindReplace feature.\n\n### Why\n- New code may break existing functionality\n- Keyboard handling changes could affect other plugins\n- CSS changes could affect other components\n- MarkNode addition could have side effects\n\n### Test Commands\n\n```bash\n# Run all tests\nbun run test\n\n# Run with coverage\nbun run test -- --coverage\n\n# Run specific test files\nbun run test apps/desktop/renderer/src/components/Editor/\n\n# Run in watch mode during development\nbun run test:watch\n```\n\n### Areas to Watch\n\n**1. Keyboard Handling**\n- ManualSavePlugin (Cmd+S)\n- SelectionToolbar (selection events)\n- SlashMenu (slash key)\n- WikiLink (double bracket)\n- PersonMention (@ key)\n\n**2. Editor State**\n- InitialStatePlugin (content loading)\n- AutosavePlugin (state serialization)\n- HistoryPlugin (undo/redo isolation)\n\n**3. CSS Conflicts**\n- globalStyle additions\n- z-index changes\n- Animation timing\n\n### Regression Checklist\n\n- [ ] All existing tests pass\n- [ ] No new test warnings\n- [ ] Coverage doesn't decrease significantly\n- [ ] TypeScript compiles without new errors\n- [ ] ESLint passes\n\n### If Regressions Found\n\n1. Document the failing test\n2. Identify the cause (new code or test environment)\n3. Fix the regression without breaking new feature\n4. Re-run full suite\n5. Document any test updates needed\n\n### Acceptance Criteria\n- [ ] Full test suite passes\n- [ ] No regressions in existing functionality\n- [ ] Coverage maintained or improved\n- [ ] All new code has tests\n\n### Dependencies\n- Requires: scribe-58c.20 (all new tests written)\n\n### Estimated Effort: S-M (30-60 minutes depending on regressions)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-22T19:10:31.308106-06:00","updated_at":"2025-12-22T19:15:49.193019-06:00","dependencies":[{"issue_id":"scribe-58c.27","depends_on_id":"scribe-58c","type":"parent-child","created_at":"2025-12-22T19:10:31.308484-06:00","created_by":"daemon"},{"issue_id":"scribe-58c.27","depends_on_id":"scribe-58c.19","type":"blocks","created_at":"2025-12-22T19:20:43.097296-06:00","created_by":"daemon"}]}
{"id":"scribe-58c.28","title":"Update CHANGELOG.md with feature entry","description":"## Task: Update CHANGELOG.md with feature entry\n\n### What\nAdd an entry to CHANGELOG.md documenting the new in-note search feature.\n\n### Why\n- Users should know about new features\n- Release notes rely on changelog\n- Historical record of changes\n\n### Changelog Entry\n\n```markdown\n## [Unreleased]\n\n### Added\n- **In-note search**: Press `Cmd+F` (Mac) or `Ctrl+F` (Windows/Linux) to search within the current note. Navigate between matches with `Enter`/`Shift+Enter` or `Cmd+G`/`Cmd+Shift+G`. All matches are highlighted in yellow, with the current match in orange. Press `Escape` to close and clear highlights.\n```\n\n### Semantic Versioning Impact\n- This is a new feature (Added)\n- Non-breaking change\n- Suggests minor version bump (if following semver)\n\n### Acceptance Criteria\n- [ ] Entry added to CHANGELOG.md\n- [ ] Follows existing changelog format\n- [ ] Includes keyboard shortcuts\n- [ ] Clear and user-friendly language\n\n### Dependencies\n- Requires: scribe-58c.26 (QA complete, feature verified)\n\n### Estimated Effort: XS (5 minutes)","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-22T19:10:31.390377-06:00","updated_at":"2025-12-22T19:15:55.948112-06:00","dependencies":[{"issue_id":"scribe-58c.28","depends_on_id":"scribe-58c","type":"parent-child","created_at":"2025-12-22T19:10:31.391712-06:00","created_by":"daemon"},{"issue_id":"scribe-58c.28","depends_on_id":"scribe-58c.27","type":"blocks","created_at":"2025-12-22T19:20:44.926949-06:00","created_by":"daemon"},{"issue_id":"scribe-58c.28","depends_on_id":"scribe-58c.26","type":"blocks","created_at":"2025-12-22T19:20:45.741196-06:00","created_by":"daemon"}]}
{"id":"scribe-58c.3","title":"Register MarkNode in EditorRoot config","description":"## Task: Register MarkNode in EditorRoot config\n\n### What\nAdd `MarkNode` to the Lexical editor's node registry so it can be used for search highlighting.\n\n### Why\nLexical requires all node types to be explicitly registered in the editor configuration. Without registration, `MarkNode` instances cannot be created or serialized.\n\n### How\n```typescript\n// In EditorRoot.tsx\nimport { MarkNode } from '@lexical/mark';\n\nconst editorConfig = {\n  // ...existing config\n  nodes: [\n    HeadingNode,\n    QuoteNode,\n    // ...existing nodes\n    MarkNode, // Add this\n  ],\n};\n```\n\n### Acceptance Criteria\n- [ ] `MarkNode` imported from `@lexical/mark`\n- [ ] `MarkNode` added to the `nodes` array in `editorConfig`\n- [ ] Editor still initializes correctly\n- [ ] No console errors related to node registration\n\n### Technical Details\n- `MarkNode` is a built-in Lexical node type\n- It wraps text content and applies CSS classes via `data-lexical-mark-ids` attribute\n- Multiple mark IDs can be applied to the same node (space-separated in the attribute)\n- DOM output: `\u003cmark data-lexical-mark-ids=\"id1 id2\"\u003etext\u003c/mark\u003e`\n\n### Dependencies\n- Requires: scribe-58c.2 (packages must be installed first)\n\n### Estimated Effort: XS (5 minutes)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T19:10:29.329336-06:00","updated_at":"2025-12-22T19:28:38.937877-06:00","closed_at":"2025-12-22T19:28:38.937877-06:00","dependencies":[{"issue_id":"scribe-58c.3","depends_on_id":"scribe-58c","type":"parent-child","created_at":"2025-12-22T19:10:29.329693-06:00","created_by":"daemon"},{"issue_id":"scribe-58c.3","depends_on_id":"scribe-58c.2","type":"blocks","created_at":"2025-12-22T19:20:32.584881-06:00","created_by":"daemon"}]}
{"id":"scribe-58c.4","title":"Add search highlight CSS styles to EditorRoot.css.ts","description":"## Task: Add search highlight CSS styles to EditorRoot.css.ts\n\n### What\nAdd global CSS styles for search match highlighting using vanilla-extract.\n\n### Why\nMarkNode renders as `\u003cmark\u003e` elements with `data-lexical-mark-ids` attribute. We need CSS to:\n1. Style ALL matches with a yellow highlight (visibility)\n2. Style the CURRENT match with orange highlight + outline (emphasis)\n\n### How\nAdd to `EditorRoot.css.ts`:\n\n```typescript\n// Base search highlight (all matches)\nglobalStyle(`${editorInput} mark[data-lexical-mark-ids*=\"search-match\"]`, {\n  backgroundColor: 'rgba(255, 212, 0, 0.4)',  // Yellow highlight\n  borderRadius: vars.radius.sm,\n  padding: '0 1px',\n});\n\n// Active/current match - more prominent styling\nglobalStyle(`${editorInput} mark[data-lexical-mark-ids*=\"search-match-active\"]`, {\n  backgroundColor: 'rgba(255, 165, 0, 0.6)',  // Orange for current match\n  outline: `2px solid ${vars.color.accent}`,\n  outlineOffset: '1px',\n});\n```\n\n### Design Rationale\n- **Yellow for all matches**: Standard \"highlighter\" metaphor, low visual weight\n- **Orange for current**: Higher contrast, distinct from yellow\n- **Accent outline**: Provides additional emphasis, matches app accent color\n- **Semi-transparent backgrounds**: Text remains readable\n- **Border radius**: Softer visual appearance, matches design system\n\n### Acceptance Criteria\n- [ ] Styles added to EditorRoot.css.ts\n- [ ] Uses design system tokens where appropriate (vars.radius.sm, vars.color.accent)\n- [ ] Colors provide sufficient contrast for readability\n- [ ] Works in both light and dark themes (test visually)\n\n### Accessibility Consideration\nHighlight colors should not be the ONLY way to identify matches. The outline on the active match provides an additional visual cue. Screen reader users will rely on the match counter in the UI.\n\n### Dependencies\n- Requires: scribe-58c.3 (MarkNode must be registered)\n\n### Estimated Effort: S (15 minutes)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T19:10:29.409904-06:00","updated_at":"2025-12-22T19:29:53.266401-06:00","closed_at":"2025-12-22T19:29:53.266401-06:00","dependencies":[{"issue_id":"scribe-58c.4","depends_on_id":"scribe-58c","type":"parent-child","created_at":"2025-12-22T19:10:29.410285-06:00","created_by":"daemon"},{"issue_id":"scribe-58c.4","depends_on_id":"scribe-58c.3","type":"blocks","created_at":"2025-12-22T19:20:33.679755-06:00","created_by":"daemon"}]}
{"id":"scribe-58c.5","title":"Phase 1: Core Search Logic (useFindReplace hook)","description":"## Phase 1: Core Search Logic (useFindReplace hook)\n\nThis phase implements the business logic for searching and highlighting text within the editor.\n\n### Tasks in This Phase\n1. **scribe-58c.6**: Create directory structure and types\n2. **scribe-58c.7**: Search logic (find all matches)\n3. **scribe-58c.8**: Highlight management (wrap matches in MarkNode)\n4. **scribe-58c.9**: Navigation (next/previous with scroll)\n5. **scribe-58c.10**: Unit tests for the hook\n\n### Architecture\nThe hook encapsulates all search logic:\n- State: query, matches[], activeIndex\n- Actions: setQuery, goToNext, goToPrevious, clearSearch\n- Side effects: MarkNode manipulation, scrolling\n\n### Key Technical Decisions\n- **Debounce**: 150ms to avoid searching on every keystroke\n- **Case-insensitive**: Default behavior users expect\n- **Reverse processing**: Process matches from last to first to maintain offset validity\n- **Discrete updates**: Use `{ discrete: true }` to exclude from undo/redo\n\n### Estimated Phase Duration: 3-4 hours","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-22T19:10:29.498511-06:00","updated_at":"2025-12-22T19:19:19.604403-06:00","closed_at":"2025-12-22T19:19:19.604403-06:00","dependencies":[{"issue_id":"scribe-58c.5","depends_on_id":"scribe-58c","type":"parent-child","created_at":"2025-12-22T19:10:29.498951-06:00","created_by":"daemon"}]}
{"id":"scribe-58c.6","title":"Create FindReplace directory structure and types.ts","description":"## Task: Create FindReplace directory structure and types.ts\n\n### What\nSet up the directory structure and TypeScript types for the FindReplace feature.\n\n### Why\n- Clean separation of concerns\n- Type safety for search state\n- Re-export pattern matching other editor plugins\n\n### Directory Structure\n```\napps/desktop/renderer/src/components/Editor/FindReplace/\n‚îú‚îÄ‚îÄ index.ts                    # Re-exports (FindReplacePlugin)\n‚îú‚îÄ‚îÄ types.ts                    # TypeScript interfaces\n‚îú‚îÄ‚îÄ useFindReplace.ts          # State management hook\n‚îú‚îÄ‚îÄ useFindReplace.test.ts     # Hook tests\n‚îú‚îÄ‚îÄ FindReplacePlugin.tsx      # Main plugin\n‚îú‚îÄ‚îÄ FindReplacePlugin.test.tsx # Plugin tests\n‚îú‚îÄ‚îÄ FindReplaceBar.tsx         # UI component\n‚îú‚îÄ‚îÄ FindReplaceBar.test.tsx    # UI tests\n‚îî‚îÄ‚îÄ FindReplaceBar.css.ts      # Styles\n```\n\n### Types Definition (types.ts)\n```typescript\n/**\n * Represents a single search match in the document\n */\nexport interface SearchMatch {\n  /** Unique identifier for this match (used as MarkNode id) */\n  id: string;\n  /** Character offset from start of document text */\n  startOffset: number;\n  /** Character offset for end of match */\n  endOffset: number;\n}\n\n/**\n * Return type for useFindReplace hook\n */\nexport interface UseFindReplaceReturn {\n  /** Current search query */\n  query: string;\n  /** Update search query (triggers debounced search) */\n  setQuery: (query: string) =\u003e void;\n  /** All matches found in document */\n  matches: SearchMatch[];\n  /** Total number of matches */\n  matchCount: number;\n  /** Index of currently highlighted match (0-based) */\n  activeIndex: number;\n  /** Navigate to next match (wraps around) */\n  goToNext: () =\u003e void;\n  /** Navigate to previous match (wraps around) */\n  goToPrevious: () =\u003e void;\n  /** Clear all highlights and reset state */\n  clearSearch: () =\u003e void;\n}\n\n/**\n * Props for FindReplaceBar component\n */\nexport interface FindReplaceBarProps extends UseFindReplaceReturn {\n  /** Callback when user closes the search bar */\n  onClose: () =\u003e void;\n}\n```\n\n### Index Re-exports (index.ts)\n```typescript\nexport { FindReplacePlugin } from './FindReplacePlugin';\nexport type { SearchMatch, UseFindReplaceReturn, FindReplaceBarProps } from './types';\n```\n\n### Acceptance Criteria\n- [ ] Directory created at correct location\n- [ ] types.ts with all interfaces documented\n- [ ] index.ts with re-exports (empty implementations ok for now)\n- [ ] TypeScript compiles without errors\n\n### Estimated Effort: S (15 minutes)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T19:10:29.59146-06:00","updated_at":"2025-12-22T19:19:32.080463-06:00","closed_at":"2025-12-22T19:19:32.080463-06:00","dependencies":[{"issue_id":"scribe-58c.6","depends_on_id":"scribe-58c","type":"parent-child","created_at":"2025-12-22T19:10:29.591809-06:00","created_by":"daemon"}]}
{"id":"scribe-58c.7","title":"Implement useFindReplace hook (search, highlight, navigation) with tests","description":"## Implement useFindReplace Hook (with tests)\n\n### What\nCreate the complete useFindReplace hook including:\n- Directory structure and TypeScript types\n- Search logic (find all matches, case-insensitive)\n- Highlight management (wrap matches in MarkNode)\n- Navigation (next/prev with wrap-around, scroll into view)\n- Unit tests\n\n### Files to Create\n```\napps/desktop/renderer/src/components/Editor/FindReplace/\n‚îú‚îÄ‚îÄ index.ts\n‚îú‚îÄ‚îÄ types.ts\n‚îú‚îÄ‚îÄ useFindReplace.ts\n‚îî‚îÄ‚îÄ useFindReplace.test.ts\n```\n\n### Key Implementation Details\n- Use `@lexical/text` for `$rootTextContent()` and `$findTextIntersectionFromCharacters()`\n- Use `@lexical/mark` for MarkNode wrapping\n- 150ms debounce on search input\n- Process matches in reverse order to maintain offset validity\n- Use `{ discrete: true }` to exclude from undo/redo history\n- `search-match` ID for all matches, `search-match-active` for current\n\n### Acceptance Criteria\n- [ ] Hook returns query, setQuery, matches, matchCount, activeIndex, goToNext, goToPrevious, clearSearch\n- [ ] Case-insensitive search\n- [ ] All matches highlighted with MarkNode\n- [ ] Navigation wraps around\n- [ ] Active match scrolls into view\n- [ ] All unit tests pass\n\n### Estimated Effort: M-L (2-3 hours)","status":"in_progress","priority":1,"issue_type":"task","created_at":"2025-12-22T19:10:29.673022-06:00","updated_at":"2025-12-22T19:32:34.91289-06:00","dependencies":[{"issue_id":"scribe-58c.7","depends_on_id":"scribe-58c","type":"parent-child","created_at":"2025-12-22T19:10:29.673337-06:00","created_by":"daemon"},{"issue_id":"scribe-58c.7","depends_on_id":"scribe-58c.2","type":"blocks","created_at":"2025-12-22T19:20:34.404701-06:00","created_by":"daemon"}]}
{"id":"scribe-58c.8","title":"Implement useFindReplace hook - highlight management","description":"## Task: Implement useFindReplace hook - highlight management\n\n### What\nAdd MarkNode highlighting to wrap matched text with visual indicators.\n\n### Why\nUsers need to SEE where matches are in the document. MarkNode provides non-destructive text wrapping that:\n- Doesn't modify the underlying text\n- Can be styled via CSS\n- Can be easily added/removed\n- Preserves existing formatting (bold, italic, etc.)\n\n### Implementation Details\n\n```typescript\nimport { \n  MarkNode, \n  $isMarkNode, \n  $unwrapMarkNode,\n  $wrapSelectionInMarkNode \n} from '@lexical/mark';\nimport { $findTextIntersectionFromCharacters } from '@lexical/text';\nimport { $createRangeSelection } from 'lexical';\n\nconst SEARCH_MARK_ID = 'search-match';\nconst ACTIVE_MARK_ID = 'search-match-active';\n\n// Clear existing highlights\nconst clearSearch = useCallback(() =\u003e {\n  editor.update(() =\u003e {\n    const root = $getRoot();\n    const markNodes = root.getDescendants().filter($isMarkNode);\n    for (const mark of markNodes) {\n      // Only unwrap OUR marks, not other marks\n      if (mark.hasID(SEARCH_MARK_ID) || mark.hasID(ACTIVE_MARK_ID)) {\n        $unwrapMarkNode(mark);\n      }\n    }\n  }, { discrete: true });\n  setMatches([]);\n  setActiveIndex(0);\n}, [editor]);\n\n// Wrap matches in MarkNodes (in performSearch, after finding positions)\n// Process in REVERSE order to maintain correct offsets\nfor (let i = newMatches.length - 1; i \u003e= 0; i--) {\n  const match = newMatches[i];\n  \n  const startIntersection = $findTextIntersectionFromCharacters(root, match.startOffset);\n  const endIntersection = $findTextIntersectionFromCharacters(root, match.endOffset);\n  \n  if (startIntersection \u0026\u0026 endIntersection) {\n    const selection = $createRangeSelection();\n    selection.anchor.set(startIntersection.node.getKey(), startIntersection.offset, 'text');\n    selection.focus.set(endIntersection.node.getKey(), endIntersection.offset, 'text');\n    \n    $wrapSelectionInMarkNode(selection, false, SEARCH_MARK_ID);\n  }\n}\n```\n\n### Critical: Reverse Order Processing\n\nWhen wrapping text in MarkNodes, the DOM changes. If we process match 0 first, the character offsets for matches 1, 2, 3... become invalid. Processing in reverse (last match first) preserves offset validity.\n\n### Mark ID Strategy\n- `search-match`: Applied to ALL matches (yellow highlight)\n- `search-match-active`: ADDED to current match (orange highlight)\n- IDs are space-separated in the DOM: `data-lexical-mark-ids=\"search-match search-match-active\"`\n\n### Acceptance Criteria\n- [ ] All matches wrapped in MarkNode with `search-match` ID\n- [ ] clearSearch() removes all search-related MarkNodes\n- [ ] Other MarkNodes (if any) are preserved\n- [ ] Highlights visually appear (verify CSS is working)\n- [ ] Reverse-order processing maintains correct offsets\n\n### Dependencies\n- Requires: scribe-58c.7 (search logic)\n- Requires: scribe-58c.4 (CSS styles)\n\n### Estimated Effort: M (45 minutes)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T19:10:29.754488-06:00","updated_at":"2025-12-22T19:19:33.558529-06:00","closed_at":"2025-12-22T19:19:33.558529-06:00","dependencies":[{"issue_id":"scribe-58c.8","depends_on_id":"scribe-58c","type":"parent-child","created_at":"2025-12-22T19:10:29.754863-06:00","created_by":"daemon"}]}
{"id":"scribe-58c.9","title":"Implement useFindReplace hook - navigation (next/prev)","description":"## Task: Implement useFindReplace hook - navigation (next/prev)\n\n### What\nImplement navigation between search matches with visual feedback and scroll-to-view.\n\n### Why\nUsers need to:\n1. Know WHICH match they're currently on (active index)\n2. Move through matches sequentially\n3. Have the current match scroll into view\n4. Wrap around at list boundaries (last ‚Üí first, first ‚Üí last)\n\n### Implementation Details\n\n```typescript\n// Update active match highlighting and scroll into view\nconst updateActiveMatch = useCallback((newIndex: number) =\u003e {\n  if (matches.length === 0) return;\n  \n  editor.update(() =\u003e {\n    const root = $getRoot();\n    const markNodes = root.getDescendants().filter($isMarkNode);\n    \n    // Remove active styling from all marks\n    for (const mark of markNodes) {\n      if (mark.hasID(ACTIVE_MARK_ID)) {\n        mark.deleteID(ACTIVE_MARK_ID);\n      }\n    }\n    \n    // Add active styling to current match\n    // We need to find the Nth mark that has our search ID\n    let matchIndex = 0;\n    for (const mark of markNodes) {\n      if (mark.hasID(SEARCH_MARK_ID)) {\n        if (matchIndex === newIndex) {\n          mark.addID(ACTIVE_MARK_ID);\n          \n          // Scroll into view\n          const markElement = editor.getElementByKey(mark.getKey());\n          if (markElement) {\n            markElement.scrollIntoView({ \n              behavior: 'smooth', \n              block: 'center' \n            });\n          }\n          break;\n        }\n        matchIndex++;\n      }\n    }\n  }, { discrete: true });\n  \n  setActiveIndex(newIndex);\n}, [editor, matches]);\n\n// Navigation with wrap-around\nconst goToNext = useCallback(() =\u003e {\n  if (matches.length === 0) return;\n  const newIndex = (activeIndex + 1) % matches.length;\n  updateActiveMatch(newIndex);\n}, [activeIndex, matches.length, updateActiveMatch]);\n\nconst goToPrevious = useCallback(() =\u003e {\n  if (matches.length === 0) return;\n  const newIndex = (activeIndex - 1 + matches.length) % matches.length;\n  updateActiveMatch(newIndex);\n}, [activeIndex, matches.length, updateActiveMatch]);\n```\n\n### Scroll Behavior\n- `behavior: 'smooth'`: Animated scroll for visual continuity\n- `block: 'center'`: Centers the match vertically in viewport\n- Fallback: If element not found, just update index (edge case)\n\n### Wrap-Around Logic\n- Next on last match (index N-1) ‚Üí goes to first (index 0)\n- Previous on first match (index 0) ‚Üí goes to last (index N-1)\n- Uses modulo arithmetic for clean implementation\n\n### Edge Cases\n- No matches: goToNext/goToPrevious are no-ops\n- Single match: Navigation still works (stays on same match)\n- Match removed while navigating: Index bounds check needed\n\n### Acceptance Criteria\n- [ ] goToNext advances activeIndex with wrap-around\n- [ ] goToPrevious decrements activeIndex with wrap-around\n- [ ] Current match has ACTIVE_MARK_ID\n- [ ] Previous current match loses ACTIVE_MARK_ID\n- [ ] Current match scrolls into center of view\n- [ ] Navigation with 0 matches is a no-op\n- [ ] Navigation with 1 match stays on that match\n\n### Dependencies\n- Requires: scribe-58c.8 (highlight management)\n\n### Estimated Effort: M (30 minutes)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T19:10:29.836906-06:00","updated_at":"2025-12-22T19:19:34.467951-06:00","closed_at":"2025-12-22T19:19:34.467951-06:00","dependencies":[{"issue_id":"scribe-58c.9","depends_on_id":"scribe-58c","type":"parent-child","created_at":"2025-12-22T19:10:29.837304-06:00","created_by":"daemon"}]}
{"id":"scribe-bw0","title":"Architecture Documentation Synchronization","description":"## Overview\n\nThis epic addresses GitHub Issue #48: Architecture documentation out of sync with implementation. The `/architecture/` documentation, while architecturally sound, has fallen behind the rapidly evolving codebase.\n\n### Work Structure (Simplified)\n\nThe original phased milestone approach created artificial bottlenecks. Tasks are now organized by natural dependencies:\n\n**Fix Inaccuracies (P1)** - Docs that actively mislead:\n- bw0.2: Package names in Decision 2\n- bw0.3: Package names in Decision 3 (parallel with bw0.2)\n- bw0.4: Electron-builder config in Decision 2\n- bw0.5: Preload API in Decision 3\n- bw0.6: IPC channels in Decision 5 (parallel with bw0.5)\n- bw0.7: Editor structure in Decision 7\n\n**Add Missing Documentation (P1-P2)** - Undocumented systems:\n- bw0.10: Create Decision 9 (CLI Architecture)\n- bw0.11: Create Decision 10 (Task System)\n- bw0.12: Auto-update section in Decision 5\n- bw0.13: Quarantine section in Decision 4\n- bw0.14: Create Decision 11 (Design System)\n\n**Expand Coverage (P2-P3)** - Incomplete but not wrong:\n- bw0.8: Command palette commands in Decision 6\n- bw0.16: Vault structure in Decision 4\n- bw0.17: Types organization in Decision 3\n- bw0.19: Handler organization in Decision 5\n- bw0.20: Note type details in Decision 3\n- bw0.21: Test-utils package in Decision 2\n- bw0.22: Update README.md index (do last)\n\n### Natural Dependencies\n\nMost tasks can run in parallel. Key dependencies:\n- bw0.20 (note types) after bw0.17 (types org) - same file section\n- bw0.16 (vault structure) after bw0.13 (quarantine) - same file\n- bw0.22 (README) after bw0.10, bw0.11, bw0.14 - indexes new docs\n\n### Success Criteria\n\n1. All architecture docs accurately reflect the codebase\n2. New decision documents created for major undocumented systems\n3. Each document includes implementation file references\n4. README.md index updated with all documents","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-22T19:08:36.042391-06:00","updated_at":"2025-12-22T19:22:15.590838-06:00"}
{"id":"scribe-bw0.1","title":"Phase 1: Fix Critical Documentation Inaccuracies","description":"## Phase 1: Fix Critical Documentation Inaccuracies\n\nThis is a **milestone marker** for Phase 1 completion. It has no work of its own but depends on all Phase 1 tasks.\n\n### Why Phase 1 is Critical\n\nThese inaccuracies actively mislead developers:\n\n1. **Package naming mismatch**: Developers looking for `/packages/search` find nothing; the actual package is `/packages/engine-search`. This wastes time and erodes trust.\n\n2. **Build config location**: The documented `/apps/desktop/electron/builder/electron-builder.yml` doesn't exist. The config lives in `package.json` under the `\"build\"` key‚Äîa common electron-builder pattern that's not obvious to newcomers.\n\n3. **Preload API surface**: The documented API shows ~10 methods. The actual API has 50+ methods across 13 domains. Developers building new features may reinvent existing functionality.\n\n4. **Editor structure**: Decision 7 shows 3-4 plugins. The actual editor has 25+ plugins. This understates complexity and misrepresents the extension patterns.\n\n### Completion Criteria\n\nAll Phase 1 subtasks (scribe-bw0.2 through scribe-bw0.8) are marked closed.\n\n### Blocking\n\nPhase 2 tasks should not start until Phase 1 completes. Reason: Phase 2 creates NEW documents that will reference the corrected Phase 1 content. Starting Phase 2 early risks propagating inaccuracies into new documents.","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-22T19:08:36.127056-06:00","updated_at":"2025-12-22T19:21:20.883639-06:00","closed_at":"2025-12-22T19:21:20.883639-06:00","dependencies":[{"issue_id":"scribe-bw0.1","depends_on_id":"scribe-bw0","type":"parent-child","created_at":"2025-12-22T19:08:36.127407-06:00","created_by":"daemon"},{"issue_id":"scribe-bw0.1","depends_on_id":"scribe-bw0.2","type":"blocks","created_at":"2025-12-22T19:14:03.520653-06:00","created_by":"daemon"},{"issue_id":"scribe-bw0.1","depends_on_id":"scribe-bw0.3","type":"blocks","created_at":"2025-12-22T19:14:03.605877-06:00","created_by":"daemon"},{"issue_id":"scribe-bw0.1","depends_on_id":"scribe-bw0.4","type":"blocks","created_at":"2025-12-22T19:14:03.696146-06:00","created_by":"daemon"},{"issue_id":"scribe-bw0.1","depends_on_id":"scribe-bw0.5","type":"blocks","created_at":"2025-12-22T19:14:03.781936-06:00","created_by":"daemon"},{"issue_id":"scribe-bw0.1","depends_on_id":"scribe-bw0.6","type":"blocks","created_at":"2025-12-22T19:14:03.866117-06:00","created_by":"daemon"},{"issue_id":"scribe-bw0.1","depends_on_id":"scribe-bw0.7","type":"blocks","created_at":"2025-12-22T19:14:03.95134-06:00","created_by":"daemon"},{"issue_id":"scribe-bw0.1","depends_on_id":"scribe-bw0.8","type":"blocks","created_at":"2025-12-22T19:14:04.037852-06:00","created_by":"daemon"}]}
{"id":"scribe-bw0.10","title":"Create Decision 9: CLI Architecture","description":"## Create Decision 9: CLI Architecture\n\n**New file**: `architecture/decision_9_cli_architecture.md`\n**Source of truth**: `apps/cli/src/`\n\n### Why This Document Matters\n\nThe CLI application is the PROOF that Scribe's engine-first architecture works. Decision 1 claims the engine packages are reusable across applications‚Äîthe CLI proves it by running the same `@scribe/engine-*` packages outside Electron.\n\nWithout documenting this, we lose:\n1. The validation of our architectural bet\n2. Guidance for future non-Electron consumers (web app, mobile, etc.)\n3. Understanding of what the engine layer actually abstracts\n\n### Document Structure\n\n```markdown\n# Decision 9: CLI Architecture \u0026 Engine Reusability Validation\n\n## 1. Overview\n- CLI as proof of engine reusability\n- Same vault, same indexes, different runtime\n\n## 2. Design Principles\n- Direct engine access (no IPC layer needed)\n- POSIX-friendly output (piping, scripting)\n- Vault path resolution hierarchy\n\n## 3. Command Structure\n- Command registration pattern (yargs-like)\n- Subcommand organization (notes, search, graph, etc.)\n- Global options (--vault, --format, --quiet)\n\n## 4. Engine Integration\n- Direct imports from @scribe/engine-*\n- No preload, no IPC‚Äîjust function calls\n- Shared types via @scribe/shared\n\n## 5. Vault Resolution\n- Default: ~/Scribe/vault\n- Override: --vault flag\n- Environment: SCRIBE_VAULT\n\n## 6. Output Formatting\n- JSON mode for scripting\n- Human-readable text mode\n- Quiet mode for automation\n\n## 7. Installation from Desktop App\n- CLI API in preload\n- Symlink to /usr/local/bin\n- Status checking\n\n## 8. Rationale\n- Why CLI proves architecture\n- Why direct engine access is safe outside Electron\n\n## 9. Final Definition\n```\n\n### Commands to Document\n\n| Command | Subcommands | Engine Packages Used |\n|---------|-------------|---------------------|\n| notes | create, list, show, update, delete, find, export, append, add-task | engine-core, storage-fs |\n| search | query | engine-search |\n| graph | backlinks, outlinks | engine-graph |\n| daily | create, show | engine-core, storage-fs |\n| people | list, create | engine-core |\n| tasks | list, toggle | engine-core |\n| tags | list | engine-graph |\n| vault | init, status | storage-fs |\n\n### Implementation Notes\n\n1. Create new file with full structure\n2. Include code examples showing direct engine imports\n3. Diagram showing CLI vs Desktop architecture differences\n4. Reference the existing CLI code as source of truth\n5. Add to README.md index with ~5 min reading time estimate","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-22T19:08:36.843406-06:00","updated_at":"2025-12-22T19:11:08.196824-06:00","dependencies":[{"issue_id":"scribe-bw0.10","depends_on_id":"scribe-bw0","type":"parent-child","created_at":"2025-12-22T19:08:36.843754-06:00","created_by":"daemon"},{"issue_id":"scribe-bw0.10","depends_on_id":"scribe-bw0.1","type":"blocks","created_at":"2025-12-22T19:14:15.11895-06:00","created_by":"daemon"}]}
{"id":"scribe-bw0.11","title":"Create Decision 10: Task System Architecture","description":"## Create Decision 10: Task System Architecture\n\n**New file**: `architecture/decision_10_task_system.md`\n**Source of truth**: `packages/engine-core/src/task-*.ts`\n\n### Why This Document Matters\n\nThe task system is one of Scribe's most sophisticated subsystems:\n- Extracts tasks from Lexical checklist nodes\n- Maintains a persistent index across sessions\n- Reconciles changes when notes are edited\n- Provides real-time updates via IPC\n\nIt's complex enough to warrant its own decision document, not just a section in Decision 3.\n\n### System Overview\n\n```\nNote (Lexical JSON) \n    ‚Üì extractTasksFromNote()\nExtractedTask[] \n    ‚Üì TaskReconciler.reconcile()\nTaskIndex (in-memory)\n    ‚Üì TaskPersistence.save()\ntasks.jsonl (derived/tasks.jsonl)\n```\n\n### Document Structure\n\n```markdown\n# Decision 10: Task System Architecture\n\n## 1. Overview\n- Tasks as first-class entities extracted from notes\n- Bidirectional sync between note content and task index\n- System note for task management UI\n\n## 2. Core Concepts\n- Task: A checklist item with identity, status, and note linkage\n- NodeKey: Lexical's stable identifier for checklist nodes\n- TextHash: DJB2 hash for content-based identity fallback\n- Reconciliation: Syncing extracted tasks with persistent index\n\n## 3. Task Extraction\n- extractTasksFromNote(): Browser-safe extraction\n- Traverses Lexical AST for checklist nodes\n- Computes nodeKey (stable) and textHash (fallback)\n\n## 4. Task Index\n- In-memory Map with secondary index by noteId\n- Pluggable persistence via TaskPersistence interface\n- Debounced saves (5000ms default)\n\n## 5. Reconciliation Rules\n1. New tasks: Add with fresh createdAt/priority\n2. Same nodeKey: Update, preserve metadata\n3. New nodeKey + same textHash: Treat as move (preserve identity)\n4. Missing nodeKey + no textHash match: Remove from index\n\n## 6. Persistence\n- JSONL format in vault/derived/tasks.jsonl\n- One line per task (append-friendly)\n- Periodic compaction (future)\n\n## 7. IPC Integration\n- tasks:list, tasks:toggle, tasks:reorder, tasks:get\n- tasks:changed event for real-time updates\n\n## 8. System Note: Tasks Screen\n- Virtual note with id: 'system:tasks'\n- Renders task list from index\n- FocusNodePlugin for navigation to source\n\n## 9. Rationale\n- Why nodeKey-first reconciliation\n- Why textHash fallback is necessary\n- Why JSONL over SQLite for this use case\n\n## 10. Final Definition\n```\n\n### Key Files to Reference\n\n| File | Purpose |\n|------|---------|\n| task-extraction.ts | Browser-safe task extraction |\n| task-index.ts | In-memory index with persistence |\n| task-persistence.ts | JSONL file storage |\n| task-reconciler.ts | Sync logic |\n| task-query.ts | Fluent query API |\n\n### Implementation Notes\n\n1. Create comprehensive document covering full task lifecycle\n2. Include diagrams for extraction and reconciliation flows\n3. Explain the nodeKey vs textHash identity strategy\n4. Document the real-time update mechanism\n5. Reference the existing task system code as source of truth","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-22T19:08:36.921481-06:00","updated_at":"2025-12-22T19:11:26.564743-06:00","dependencies":[{"issue_id":"scribe-bw0.11","depends_on_id":"scribe-bw0","type":"parent-child","created_at":"2025-12-22T19:08:36.921858-06:00","created_by":"daemon"},{"issue_id":"scribe-bw0.11","depends_on_id":"scribe-bw0.1","type":"blocks","created_at":"2025-12-22T19:14:15.201814-06:00","created_by":"daemon"}]}
{"id":"scribe-bw0.12","title":"Document auto-update system in Decision 5","description":"## Document Auto-Update System in Decision 5\n\n**File**: `architecture/decision_5_engine_lifecycle.md`\n**Section to add**: New section between current 7 and 8 (or as Section 9)\n**Source of truth**: `apps/desktop/electron/main/src/auto-updater.ts`\n\n### Why Document This\n\nAuto-update is critical for desktop applications:\n1. Security patches must reach users quickly\n2. User experience depends on seamless updates\n3. Failure modes need careful handling\n\nCurrently, auto-update is completely undocumented despite being production-ready.\n\n### Content to Add\n\n```markdown\n## Auto-Update Lifecycle\n\n### Overview\n\nScribe uses electron-updater for automatic updates. The system:\n- Checks for updates on startup (after 10s delay)\n- Checks periodically (every hour)\n- Downloads updates automatically in background\n- Installs on app quit (user-triggered)\n\n### Update Flow\n\n1. **Startup check** (10s delay to avoid blocking)\n2. **Periodic check** (3600s interval)\n3. **Update available** ‚Üí Auto-download begins\n4. **Download complete** ‚Üí Notify renderer via IPC\n5. **User quits** ‚Üí Install and restart\n\n### IPC Channels\n\n| Channel | Direction | Purpose |\n|---------|-----------|---------|\n| update:check | Renderer ‚Üí Main | Manual check trigger |\n| update:install | Renderer ‚Üí Main | Install downloaded update |\n| update:checking | Main ‚Üí Renderer | Check started |\n| update:available | Main ‚Üí Renderer | Update found |\n| update:not-available | Main ‚Üí Renderer | No update |\n| update:downloaded | Main ‚Üí Renderer | Ready to install |\n| update:error | Main ‚Üí Renderer | Error occurred |\n\n### Configuration\n\n- Update server: GitHub Releases (default for electron-builder)\n- macOS: DMG with code signing\n- Windows: NSIS installer (future)\n- Linux: AppImage (future)\n\n### Error Handling\n\n- Network errors: Silent retry on next interval\n- Download errors: Logged, retry on next interval\n- Install errors: Logged, update preserved for next quit\n\n### Security Considerations\n\n- Updates are code-signed (macOS)\n- HTTPS-only download\n- Signature verification by electron-updater\n```\n\n### Implementation Notes\n\n1. Add as new section in Decision 5\n2. Include sequence diagram for update flow\n3. Reference the UpdateAPI interface from ipc-contract.ts\n4. Note the relationship to CI/CD (release.yml creates releases)\n\n### Relationship to ci_cd_pipeline.md\n\nThe CI/CD document covers how releases are CREATED. This section covers how they are CONSUMED by the running app. They're complementary.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-22T19:08:37.001185-06:00","updated_at":"2025-12-22T19:11:41.756635-06:00","dependencies":[{"issue_id":"scribe-bw0.12","depends_on_id":"scribe-bw0","type":"parent-child","created_at":"2025-12-22T19:08:37.001539-06:00","created_by":"daemon"}]}
{"id":"scribe-bw0.13","title":"Document quarantine system in Decision 4","description":"## Document Quarantine System in Decision 4\n\n**File**: `architecture/decision_4_vault_structure.md`\n**Section to add**: New section after \"Save Pipeline\" (Section 6)\n**Source of truth**: `packages/storage-fs/src/quarantine-manager.ts`\n\n### Why Document This\n\nData integrity is a core promise of local-first software. When note files become corrupt (JSON parse errors, validation failures), Scribe must:\n1. Not crash or block vault loading\n2. Preserve the corrupt file for manual recovery\n3. Provide a path to restoration\n\nThe quarantine system does this, but it's undocumented.\n\n### Content to Add\n\n```markdown\n## Quarantine System for Corrupt Files\n\n### Overview\n\nWhen a note file fails to load (parse error, validation failure), it is moved to quarantine rather than being deleted or blocking the vault. This preserves data for manual recovery.\n\n### Directory Structure\n\n```\n/vault\n  /notes          # Valid notes\n  /quarantine     # Corrupt files awaiting recovery\n  /derived        # Generated data (tasks.jsonl)\n```\n\n### Quarantine Process\n\n1. **Detection**: Note fails JSON.parse() or validation\n2. **Isolation**: File moved to `/vault/quarantine/`\n3. **Naming**: Prefixed with ISO timestamp (e.g., `2024-01-15T10-30-00_abc123.json`)\n4. **Logging**: Error logged with reason and original path\n5. **Continuation**: Vault load continues with remaining notes\n\n### Two-Strategy Approach\n\n**Primary strategy**: Move to quarantine directory\n- Cleanest separation\n- Easy to list quarantined files\n- Preserves original filename in suffix\n\n**Fallback strategy**: Rename in place with `.corrupt` extension\n- Used if quarantine directory is unavailable\n- File becomes `{noteId}.json.corrupt`\n- Still prevents loading but keeps file accessible\n\n### Recovery Operations\n\n| Operation | Method | Description |\n|-----------|--------|-------------|\n| List | `quarantine.list()` | Show all quarantined files |\n| Restore | `quarantine.restore(filename)` | Move back to notes/ |\n| Delete | `quarantine.delete(filename)` | Permanent removal |\n\n### When Files Get Quarantined\n\n1. **JSON syntax error**: Malformed JSON\n2. **Schema validation failure**: Missing required fields\n3. **Type mismatch**: Wrong data types\n4. **Unknown note type**: Unrecognized discriminator\n\n### Implementation Location\n\n- `packages/storage-fs/src/quarantine-manager.ts`\n- Integrated into `FileSystemVault` load process\n```\n\n### Implementation Notes\n\n1. Add as Section 7 in Decision 4 (after Save Pipeline)\n2. Update vault directory structure diagram to include `/quarantine`\n3. Reference the QuarantineManager API\n4. Explain why \"fail gracefully\" is important for local-first\n\n### Connection to Decision 8\n\nDecision 8 (Data Flow) mentions \"corrupt files skipped and flagged\" but doesn't explain how. This section provides the implementation details.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-22T19:08:37.079387-06:00","updated_at":"2025-12-22T19:11:58.352922-06:00","dependencies":[{"issue_id":"scribe-bw0.13","depends_on_id":"scribe-bw0","type":"parent-child","created_at":"2025-12-22T19:08:37.079706-06:00","created_by":"daemon"}]}
{"id":"scribe-bw0.14","title":"Create Decision 11: Design System Architecture","description":"## Create Decision 11: Design System Architecture\n\n**New file**: `architecture/decision_11_design_system.md`\n**Source of truth**: `packages/design-system/src/`\n\n### Why This Document Matters\n\nThe design system is the foundation of Scribe's UI:\n1. **Tokens**: CSS variables for colors, spacing, typography\n2. **Themes**: Dark/light mode with runtime switching\n3. **Primitives**: Reusable components (Button, Surface, etc.)\n\nAs Scribe's UI grows, consistent design patterns become critical. The design system enforces this consistency.\n\n### Document Structure\n\n```markdown\n# Decision 11: Design System Architecture\n\n## 1. Overview\n- Contract-based theming with vanilla-extract\n- Runtime theme switching\n- Primitive components as building blocks\n\n## 2. Design Principles\n- Tokens over hard-coded values\n- Composition over inheritance\n- Type-safe styling\n\n## 3. Token Architecture\n\n### Contract (CSS Variables)\n```typescript\n// tokens/contract.css.ts\nexport const vars = createThemeContract({\n  colors: {\n    background: null,\n    foreground: null,\n    primary: null,\n    // ...\n  },\n  spacing: { xs, sm, md, lg, xl },\n  radii: { sm, md, lg },\n  fonts: { body, mono },\n});\n```\n\n### Themes\n- `themes/dark.css.ts`: Dark mode values\n- `themes/light.css.ts`: Light mode values\n- Applied via className on root element\n\n## 4. Theme Provider\n```typescript\n\u003cThemeProvider defaultTheme=\"dark\"\u003e\n  \u003cApp /\u003e\n\u003c/ThemeProvider\u003e\n```\n- useTheme() hook for components\n- System preference detection\n- Persisted preference\n\n## 5. Primitive Components\n\n| Component | Purpose | Key Props |\n|-----------|---------|-----------|\n| Surface | Container with background | variant, padding |\n| Text | Typography | size, weight, color |\n| Button | Interactive button | variant, size, disabled |\n| Icon | Icon wrapper | name, size, color |\n| Overlay | Modal backdrop | onClose |\n| Portal | Render outside tree | container |\n| FloatingMenu | Dropdown menus | items, trigger |\n| Calendar | Date display | value, onChange |\n| DatePicker | Date input | value, onChange |\n\n## 6. Style Patterns\n\n### Recipe-based variants (vanilla-extract)\n```typescript\nconst button = recipe({\n  base: { /* shared styles */ },\n  variants: {\n    size: { small: {}, medium: {}, large: {} },\n    color: { primary: {}, secondary: {} },\n  },\n});\n```\n\n### Composition\n```typescript\n\u003cSurface variant=\"elevated\" padding=\"md\"\u003e\n  \u003cText size=\"lg\" weight=\"bold\"\u003eTitle\u003c/Text\u003e\n  \u003cButton variant=\"primary\"\u003eAction\u003c/Button\u003e\n\u003c/Surface\u003e\n```\n\n## 7. Animation Tokens\n- Keyframe definitions in `tokens/animations.css.ts`\n- fadeIn, fadeOut, slideUp, slideDown, scaleIn\n- Duration and easing tokens\n\n## 8. Rationale\n- Why vanilla-extract over CSS-in-JS runtime\n- Why contract-based theming\n- Why primitive + composition over complex components\n\n## 9. Final Definition\n```\n\n### Implementation Notes\n\n1. Create new file with full structure\n2. Include actual token values from contract.css.ts\n3. Document each primitive component's API\n4. Show composition patterns\n5. Reference the design-system package structure\n\n### Relationship to Other Documents\n\n- Decision 2 mentions `/packages/ui` which is now `/packages/design-system`\n- Decision 7 (Editor) uses these primitives for UI chrome","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-22T19:08:37.159018-06:00","updated_at":"2025-12-22T19:12:16.295382-06:00","dependencies":[{"issue_id":"scribe-bw0.14","depends_on_id":"scribe-bw0","type":"parent-child","created_at":"2025-12-22T19:08:37.159472-06:00","created_by":"daemon"},{"issue_id":"scribe-bw0.14","depends_on_id":"scribe-bw0.2","type":"blocks","created_at":"2025-12-22T19:14:15.458776-06:00","created_by":"daemon"}]}
{"id":"scribe-bw0.15","title":"Phase 3: Minor Updates and Polish","description":"## Phase 3: Minor Updates and Polish\n\nThis is a **milestone marker** for Phase 3 completion. It depends on Phase 2 completion and all Phase 3 tasks.\n\n### Why Phase 3 Matters\n\nPhase 3 handles the \"long tail\" of documentation updates:\n- Details that are incomplete but not critically wrong\n- Cross-references between documents\n- Final consistency checks\n\nThese are lower priority because they don't actively mislead developers, but they reduce documentation quality over time.\n\n### Scope\n\n1. **Vault structure updates**: Add /quarantine, /derived directories\n2. **Types organization**: Document the types/ subdirectory structure\n3. **Command expansion**: Complete the command palette list\n4. **Handler organization**: Document the handler file structure\n5. **Note type details**: Document DailyNote, MeetingNote, PersonNote, SystemNote\n6. **Test utils package**: Add to project structure\n7. **README index**: Update with new decision documents\n\n### Completion Criteria\n\nAll Phase 3 subtasks (scribe-bw0.16 through scribe-bw0.22) are marked closed.\n\n### Quality Checks After Phase 3\n\n1. Grep all docs for outdated paths‚Äîshould return zero\n2. Verify all cross-references resolve\n3. Verify README.md lists all 11 decision documents\n4. Run linkchecker on markdown files (if tooling available)\n\n### Dependencies\n\n- Depends on Phase 2 completion (new documents must exist before referencing them)\n- scribe-bw0.22 (README update) should be LAST‚Äîit indexes everything else","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-22T19:08:37.238691-06:00","updated_at":"2025-12-22T19:21:23.351887-06:00","closed_at":"2025-12-22T19:21:23.351887-06:00","dependencies":[{"issue_id":"scribe-bw0.15","depends_on_id":"scribe-bw0","type":"parent-child","created_at":"2025-12-22T19:08:37.239071-06:00","created_by":"daemon"},{"issue_id":"scribe-bw0.15","depends_on_id":"scribe-bw0.9","type":"blocks","created_at":"2025-12-22T19:14:08.761515-06:00","created_by":"daemon"},{"issue_id":"scribe-bw0.15","depends_on_id":"scribe-bw0.16","type":"blocks","created_at":"2025-12-22T19:14:08.845969-06:00","created_by":"daemon"},{"issue_id":"scribe-bw0.15","depends_on_id":"scribe-bw0.17","type":"blocks","created_at":"2025-12-22T19:14:08.930313-06:00","created_by":"daemon"},{"issue_id":"scribe-bw0.15","depends_on_id":"scribe-bw0.18","type":"blocks","created_at":"2025-12-22T19:14:09.016301-06:00","created_by":"daemon"},{"issue_id":"scribe-bw0.15","depends_on_id":"scribe-bw0.19","type":"blocks","created_at":"2025-12-22T19:14:09.104147-06:00","created_by":"daemon"},{"issue_id":"scribe-bw0.15","depends_on_id":"scribe-bw0.20","type":"blocks","created_at":"2025-12-22T19:14:09.187544-06:00","created_by":"daemon"},{"issue_id":"scribe-bw0.15","depends_on_id":"scribe-bw0.21","type":"blocks","created_at":"2025-12-22T19:14:09.272693-06:00","created_by":"daemon"},{"issue_id":"scribe-bw0.15","depends_on_id":"scribe-bw0.22","type":"blocks","created_at":"2025-12-22T19:14:09.35826-06:00","created_by":"daemon"}]}
{"id":"scribe-bw0.16","title":"Update vault directory structure in Decision 4","description":"## Update Vault Directory Structure in Decision 4\n\n**File**: `architecture/decision_4_vault_structure.md`\n**Section**: 2 (Vault Directory Structure)\n**Source of truth**: `packages/storage-fs/src/vault.ts`\n\n### Current State\n\n```\n/vault\n  /notes\n  manifest.json (optional)\n```\n\n### Target State\n\n```\n/vault\n  /notes          # Active note files\n  /quarantine     # Corrupt files isolated for recovery\n  /derived        # Generated data (not source of truth)\n    tasks.jsonl   # Extracted task index\n  manifest.json   # Optional vault metadata (future)\n```\n\n### New Directories Explained\n\n**`/quarantine`**:\n- Created by vault initialization\n- Receives corrupt files that fail to load\n- Preserves data for manual recovery\n- See Quarantine System section (added in scribe-bw0.13)\n\n**`/derived`**:\n- Data generated FROM notes, not edited directly\n- Currently contains `tasks.jsonl`\n- Could include future derived data (search index, etc.)\n- NOT backed up independently‚Äîregenerable from notes\n\n### Implementation Notes\n\n1. Update the directory diagram in Section 2\n2. Add brief descriptions for each directory\n3. Note that VAULT_SUBDIRS constant defines these\n4. Explain the \"derived\" concept: data that can be regenerated\n\n### Relationship to scribe-bw0.13\n\nscribe-bw0.13 adds the Quarantine System section. This task updates the structure diagram that section references.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-22T19:08:37.316328-06:00","updated_at":"2025-12-22T19:12:40.665048-06:00","dependencies":[{"issue_id":"scribe-bw0.16","depends_on_id":"scribe-bw0","type":"parent-child","created_at":"2025-12-22T19:08:37.316681-06:00","created_by":"daemon"},{"issue_id":"scribe-bw0.16","depends_on_id":"scribe-bw0.13","type":"blocks","created_at":"2025-12-22T19:14:17.21004-06:00","created_by":"daemon"}]}
{"id":"scribe-bw0.17","title":"Update types organization in Decision 3","description":"## Update Types Organization in Decision 3\n\n**File**: `architecture/decision_3_internal_architecture.md`\n**Section**: 2 (Foundations / Shared Types)\n**Source of truth**: `packages/shared/src/types/`\n\n### Current State\n\nThe document references `shared/types.ts` as a single file.\n\n### Target State\n\nTypes have been reorganized into a directory structure:\n\n```\npackages/shared/src/types/\n  index.ts              # Barrel re-exports\n  note-types.ts         # Note, NoteId, NoteType, note variants\n  editor-types.ts       # EditorContent, EditorNode\n  task-types.ts         # Task, TaskId, TaskFilter, TaskChangeEvent\n  graph-types.ts        # GraphNode, GraphEdge\n  search-types.ts       # SearchResult\n```\n\n### Type Categories\n\n**Note Types** (note-types.ts):\n- `NoteId`: Branded string type for note identifiers\n- `BaseNote`: Common fields (id, createdAt, updatedAt, content)\n- `NoteType`: Discriminator enum (regular, person, daily, meeting, etc.)\n- Note variants: `RegularNote`, `PersonNote`, `DailyNote`, `MeetingNote`, `ProjectNote`, `TemplateNote`, `SystemNote`\n- Type guards: `isRegularNote()`, `isDailyNote()`, etc.\n\n**Editor Types** (editor-types.ts):\n- `EditorContent`: Wrapper for Lexical JSON\n- `EditorNode`: Generic node structure\n\n**Task Types** (task-types.ts):\n- `Task`: Full task with metadata\n- `TaskId`: Branded string\n- `TaskFilter`: Query parameters\n- `TaskChangeEvent`: For real-time updates\n\n**Graph Types** (graph-types.ts):\n- `GraphNode`: Node in knowledge graph\n- `GraphEdge`: Directed edge (link, mention, tag)\n\n**Search Types** (search-types.ts):\n- `SearchResult`: Search hit with score and snippet\n\n### Implementation Notes\n\n1. Update Section 2 with directory structure\n2. List the type categories and their contents\n3. Explain the barrel export pattern\n4. Note that types are consumed by all packages\n\n### Why This Organization\n\n1. **Discoverability**: Related types grouped together\n2. **Tree-shaking**: Consumers can import specific type files\n3. **Maintenance**: Smaller files are easier to review\n4. **Documentation**: File names describe contents","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-22T19:08:37.395162-06:00","updated_at":"2025-12-22T19:12:53.715413-06:00","dependencies":[{"issue_id":"scribe-bw0.17","depends_on_id":"scribe-bw0","type":"parent-child","created_at":"2025-12-22T19:08:37.395523-06:00","created_by":"daemon"}]}
{"id":"scribe-bw0.18","title":"Expand command palette commands list in Decision 6","description":"## Expand Command Palette Commands List in Decision 6\n\n**File**: `architecture/decision_6_command_palette_architecture.md`\n**Section**: 4 (Core Commands)\n**Source of truth**: `apps/desktop/renderer/src/hooks/useAppCommands.tsx`\n\n### Current State\n\n6 commands listed (MVP scope):\n- New Note, Open Note, Search Notes, Show Backlinks, Save Note, Open Developer Tools\n\n### Target State\n\nFull command inventory organized by group:\n\n```markdown\n### Notes Group\n| Command | Shortcut | Description |\n|---------|----------|-------------|\n| Create Note | Cmd+N | Create new empty note |\n| Open Note | Cmd+O | Open existing note |\n| Save Note | Cmd+S | Save current note |\n| Delete Note | Cmd+Backspace | Delete current note |\n| Show Backlinks | | Show notes linking here |\n\n### Navigation Group\n| Command | Shortcut | Description |\n|---------|----------|-------------|\n| Go to Tasks | | Open Tasks system note |\n| Go to Today | | Open today's daily note |\n\n### People Group\n| Command | Shortcut | Description |\n|---------|----------|-------------|\n| Create Person | | Create new person note |\n| Search People | | Find person by name |\n\n### Templates Group\n| Command | Shortcut | Description |\n|---------|----------|-------------|\n| Create Daily Note | | Create dated daily note |\n| Create Meeting | | Create meeting note |\n\n### View Group\n| Command | Shortcut | Description |\n|---------|----------|-------------|\n| Toggle Theme | | Switch dark/light mode |\n\n### Developer Group\n| Command | Shortcut | Description |\n|---------|----------|-------------|\n| Open DevTools | Cmd+Shift+I | Open Chrome DevTools |\n```\n\n### Implementation Notes\n\n1. Expand Section 4 with complete command table\n2. Group commands by their `group` property\n3. Include shortcuts where defined\n4. Note any commands that require specific context (e.g., \"Show Backlinks\" needs a note open)\n\n### Relationship to scribe-bw0.5\n\nCommands invoke the preload API documented in scribe-bw0.5. Each command's `run()` function typically calls `window.scribe.*` methods.\n\n### Priority\n\nThis is P3 because the documented commands are accurate‚Äîwe're just adding more. It doesn't mislead, just underrepresents.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-22T19:08:37.475328-06:00","updated_at":"2025-12-22T19:21:27.091341-06:00","closed_at":"2025-12-22T19:21:27.091341-06:00","dependencies":[{"issue_id":"scribe-bw0.18","depends_on_id":"scribe-bw0","type":"parent-child","created_at":"2025-12-22T19:08:37.475709-06:00","created_by":"daemon"}]}
{"id":"scribe-bw0.19","title":"Document handler organization in Decision 5","description":"## Document Handler Organization in Decision 5\n\n**File**: `architecture/decision_5_engine_lifecycle.md`\n**Section**: 6 (IPC Routing Architecture) - add subsection\n**Source of truth**: `apps/desktop/electron/main/src/handlers/`\n\n### Current State\n\nThe document mentions IPC handlers but doesn't explain how they're organized in the codebase.\n\n### Target State\n\nAdd handler organization documentation:\n\n```markdown\n### Handler File Organization\n\nIPC handlers are organized by domain in `/apps/desktop/electron/main/src/handlers/`:\n\n| File | Channels | Engine Dependencies |\n|------|----------|---------------------|\n| notesHandlers.ts | notes:* | vault, graphEngine, searchEngine |\n| searchHandlers.ts | search:* | searchEngine |\n| graphHandlers.ts | graph:* | graphEngine |\n| peopleHandlers.ts | people:* | vault |\n| dailyHandlers.ts | daily:* | vault |\n| meetingHandlers.ts | meeting:* | vault |\n| dictionaryHandlers.ts | dictionary:* | (electron webContents) |\n| tasksHandlers.ts | tasks:* | taskIndex, vault |\n| cliHandlers.ts | cli:* | (filesystem) |\n| exportHandlers.ts | export:* | vault |\n| appHandlers.ts | app:*, shell:*, ping | (electron APIs) |\n\n### Handler Registration\n\nAll handlers are registered in `main.ts`:\n\n```typescript\nregisterNotesHandlers(deps);\nregisterSearchHandlers(deps);\nregisterGraphHandlers(deps);\n// ... etc\n```\n\n### Handler Dependencies Type\n\n```typescript\ninterface HandlerDependencies {\n  mainWindow: BrowserWindow | null;\n  vault: FileSystemVault | null;\n  graphEngine: GraphEngine | null;\n  searchEngine: SearchEngine | null;\n  taskIndex: TaskIndex | null;\n}\n```\n\nEach handler file exports a `register*Handlers(deps)` function that:\n1. Accesses needed dependencies\n2. Registers `ipcMain.handle()` for each channel\n3. Returns early if required dependencies are null\n```\n\n### Why This Pattern\n\n1. **Separation of concerns**: Each domain in its own file\n2. **Testability**: Handlers can be tested with mock dependencies\n3. **Consistency**: All handlers follow same signature\n4. **Discoverability**: File name matches channel prefix\n\n### Implementation Notes\n\n1. Add as subsection in Section 6\n2. Include the handler-to-channel mapping table\n3. Show the HandlerDependencies interface\n4. Explain the registration pattern","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-22T19:08:37.557681-06:00","updated_at":"2025-12-22T19:13:18.166347-06:00","dependencies":[{"issue_id":"scribe-bw0.19","depends_on_id":"scribe-bw0","type":"parent-child","created_at":"2025-12-22T19:08:37.558028-06:00","created_by":"daemon"}]}
{"id":"scribe-bw0.2","title":"Update package names in Decision 2 (project structure)","description":"## Update Package Names in Decision 2\n\n**File**: `architecture/decision_2_project_structure.md`\n**Lines to update**: ~45-48 (directory structure diagram)\n\n### Current State (Incorrect)\n\n```\n/packages\n  /search\n  /graph\n  /ui\n```\n\n### Target State (Correct)\n\n```\n/packages\n  /engine-search    # Full-text search with FlexSearch\n  /engine-graph     # Knowledge graph, backlinks, tags\n  /engine-core      # Note operations, metadata, tasks\n  /design-system    # UI tokens, themes, primitives\n  /shared           # Types, IPC contracts, utilities\n  /storage-fs       # Filesystem vault operations\n  /test-utils       # Test factories and fixtures\n```\n\n### Why This Naming Convention\n\nThe `engine-*` prefix emerged organically to:\n1. **Signal reusability**: These packages are app-agnostic; the CLI proves they work outside Electron\n2. **Namespace clarity**: Distinguishes engine logic from infrastructure (`storage-fs`) and UI (`design-system`)\n3. **Import readability**: `@scribe/engine-search` is more descriptive than `@scribe/search`\n\n### Implementation Notes\n\n- Update the ASCII directory tree in Section 2\n- Ensure all package references throughout the document use correct names\n- Add brief descriptions of each package's purpose (as shown above)\n- Reference the actual `package.json` files as source of truth\n\n### Verification\n\nAfter update, grep the document for `/packages/search`, `/packages/graph`, `/packages/ui` ‚Äî should return zero matches.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T19:08:36.205255-06:00","updated_at":"2025-12-22T19:33:41.125309-06:00","closed_at":"2025-12-22T19:33:41.125309-06:00","dependencies":[{"issue_id":"scribe-bw0.2","depends_on_id":"scribe-bw0","type":"parent-child","created_at":"2025-12-22T19:08:36.205634-06:00","created_by":"daemon"}]}
{"id":"scribe-bw0.20","title":"Document note type details in Decision 3","description":"## Document Note Type Details in Decision 3\n\n**File**: `architecture/decision_3_internal_architecture.md`\n**Section**: 2 (Foundations) - expand note type descriptions\n**Source of truth**: `packages/shared/src/types/note-types.ts`\n\n### Current State\n\nThe document mentions the Note discriminated union but doesn't explain each variant.\n\n### Target State\n\nAdd detailed note type documentation:\n\n```markdown\n### Note Type Variants\n\nThe `Note` type is a discriminated union with these variants:\n\n#### RegularNote\nThe default note type for general content.\n```typescript\n{\n  type: 'regular',\n  title: string,\n  content: EditorContent,\n  metadata: { tags: string[], links: string[] }\n}\n```\n\n#### DailyNote\nDate-based notes, one per day. Title format: `MM-dd-yyyy`.\n```typescript\n{\n  type: 'daily',\n  date: string,  // ISO date\n  content: EditorContent,\n  // No title‚Äîderived from date\n}\n```\n- Created via `daily:getOrCreate` IPC\n- Linked from MeetingNotes via date\n\n#### MeetingNote\nNotes for meetings with attendee tracking.\n```typescript\n{\n  type: 'meeting',\n  title: string,\n  date: string,  // Links to DailyNote\n  attendees: NoteId[],  // Links to PersonNotes\n  content: EditorContent,\n}\n```\n- Attendees are PersonNote references\n- Appears in DailyNote for that date\n\n#### PersonNote\nNotes about people, used for @mentions.\n```typescript\n{\n  type: 'person',\n  name: string,\n  content: EditorContent,\n}\n```\n- Referenced by `@name` mentions in editor\n- PersonMentionPlugin handles autocomplete\n\n#### ProjectNote\nNotes for project organization.\n```typescript\n{\n  type: 'project',\n  title: string,\n  content: EditorContent,\n}\n```\n\n#### TemplateNote\nReusable templates for note creation.\n```typescript\n{\n  type: 'template',\n  title: string,\n  content: EditorContent,\n}\n```\n\n#### SystemNote\nVirtual notes for system UI (not persisted to files).\n```typescript\n{\n  type: 'system',\n  id: 'system:tasks' | 'system:graph' | ...,\n  // No content‚Äîrendered by special components\n}\n```\n- `system:tasks`: Tasks list screen\n- Not saved to vault‚Äîpurely UI state\n```\n\n### Implementation Notes\n\n1. Expand Section 2 with variant documentation\n2. Include TypeScript interfaces for each\n3. Explain relationships (Meeting ‚Üí Daily, Meeting ‚Üí Person)\n4. Note which types are persisted vs virtual\n\n### Relationship to scribe-bw0.17\n\nscribe-bw0.17 documents the types/ directory structure. This task documents the CONTENT of note-types.ts specifically.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-22T19:08:37.644024-06:00","updated_at":"2025-12-22T19:13:33.021267-06:00","dependencies":[{"issue_id":"scribe-bw0.20","depends_on_id":"scribe-bw0","type":"parent-child","created_at":"2025-12-22T19:08:37.64439-06:00","created_by":"daemon"},{"issue_id":"scribe-bw0.20","depends_on_id":"scribe-bw0.17","type":"blocks","created_at":"2025-12-22T19:14:17.295732-06:00","created_by":"daemon"}]}
{"id":"scribe-bw0.21","title":"Add test-utils package to Decision 2","description":"## Add Test Utils Package to Decision 2\n\n**File**: `architecture/decision_2_project_structure.md`\n**Section**: 2 (Monorepo Structure)\n**Source of truth**: `packages/test-utils/src/`\n\n### Current State\n\nThe project structure in Decision 2 doesn't list the test-utils package.\n\n### Target State\n\nAdd test-utils to the packages list:\n\n```markdown\n/packages\n  /engine-core     # Core engine operations\n  /engine-graph    # Knowledge graph\n  /engine-search   # Full-text search\n  /storage-fs      # Filesystem storage\n  /shared          # Types, contracts, utilities\n  /design-system   # UI tokens, themes, primitives\n  /test-utils      # Test factories and fixtures  ‚Üê NEW\n```\n\n### Package Contents\n\n```\npackages/test-utils/src/\n  index.ts            # Barrel exports\n  content-factory.ts  # EditorContent factory\n  note-factory.ts     # Note factories (all variants)\n  vault-factory.ts    # In-memory vault for tests\n```\n\n### Factory Functions\n\n| Factory | Purpose | Output |\n|---------|---------|--------|\n| `createEditorContent()` | Rich text content | `EditorContent` |\n| `createNote()` | Any note variant | `Note` |\n| `createRegularNote()` | Regular note | `RegularNote` |\n| `createDailyNote()` | Daily note | `DailyNote` |\n| `createPersonNote()` | Person note | `PersonNote` |\n| `createMeetingNote()` | Meeting note | `MeetingNote` |\n| `createTestVault()` | In-memory vault | `Vault` (mock) |\n\n### Usage Pattern\n\n```typescript\nimport { createNote, createEditorContent } from '@scribe/test-utils';\n\nconst note = createNote({\n  type: 'regular',\n  title: 'Test Note',\n  content: createEditorContent('Hello world'),\n});\n```\n\n### Implementation Notes\n\n1. Add test-utils to the package list in Section 2\n2. Briefly describe its purpose (test helpers)\n3. Note that it's a devDependency for other packages\n4. Reference the testing_strategy_and_design.md for test patterns\n\n### Why This Package Exists\n\n1. **Consistency**: All tests use same factory patterns\n2. **DRY**: Avoid duplicating test setup code\n3. **Realistic data**: Factories produce valid note structures\n4. **Type safety**: Factories are typed, catch errors early","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-22T19:08:37.734073-06:00","updated_at":"2025-12-22T19:13:44.618614-06:00","dependencies":[{"issue_id":"scribe-bw0.21","depends_on_id":"scribe-bw0","type":"parent-child","created_at":"2025-12-22T19:08:37.734465-06:00","created_by":"daemon"}]}
{"id":"scribe-bw0.22","title":"Update README.md index with new decision documents","description":"## Update README.md Index with New Decision Documents\n\n**File**: `architecture/README.md`\n**Source of truth**: All files in `architecture/`\n\n### Why This Must Be Last\n\nThis task updates the index/table of contents for the architecture folder. It must be done AFTER all other tasks because:\n1. New documents (Decision 9, 10, 11) must exist first\n2. Reading times need to be estimated for new content\n3. The document status table needs updating\n\n### Current State\n\nREADME.md lists Decisions 1-8 plus CI/CD and Testing docs.\n\n### Target State\n\nUpdate to include:\n- Decision 9: CLI Architecture (~5 min)\n- Decision 10: Task System Architecture (~7 min)\n- Decision 11: Design System Architecture (~5 min)\n- Updated reading times if documents grew\n\n### Sections to Update\n\n**1. Reading Order / TOC**\n```markdown\n| Document | Purpose | Read Time |\n|----------|---------|-----------|\n| ... existing 1-8 ... |\n| decision_9_cli_architecture.md | CLI \u0026 Engine Reusability | ~5 min |\n| decision_10_task_system.md | Task Extraction \u0026 Index | ~7 min |\n| decision_11_design_system.md | Tokens, Themes, Primitives | ~5 min |\n```\n\n**2. Document Status**\nAdd new documents to the canonical list.\n\n**3. Visual Architecture Map**\nConsider updating the ASCII diagram if significant systems were added.\n\n**4. Common Questions**\nAdd any relevant Q\u0026A for new systems:\n- \"How do I add a CLI command?\" ‚Üí Decision 9\n- \"How do tasks get extracted?\" ‚Üí Decision 10\n- \"How do I add a theme?\" ‚Üí Decision 11\n\n### Implementation Notes\n\n1. Add new documents to the TOC table\n2. Update total reading time estimate\n3. Add new documents to status section\n4. Add relevant FAQ entries\n5. Update \"Key Files Referenced\" if needed\n\n### Verification\n\nAfter update:\n- All 11 decision documents are listed\n- Total reading time reflects new content\n- Links to new documents are valid\n\n### Dependencies\n\nThis task depends on ALL other tasks completing first. It is the capstone of the documentation sync effort.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-22T19:08:37.835761-06:00","updated_at":"2025-12-22T19:13:56.32823-06:00","dependencies":[{"issue_id":"scribe-bw0.22","depends_on_id":"scribe-bw0","type":"parent-child","created_at":"2025-12-22T19:08:37.83614-06:00","created_by":"daemon"},{"issue_id":"scribe-bw0.22","depends_on_id":"scribe-bw0.10","type":"blocks","created_at":"2025-12-22T19:14:17.382157-06:00","created_by":"daemon"},{"issue_id":"scribe-bw0.22","depends_on_id":"scribe-bw0.11","type":"blocks","created_at":"2025-12-22T19:14:17.467264-06:00","created_by":"daemon"},{"issue_id":"scribe-bw0.22","depends_on_id":"scribe-bw0.14","type":"blocks","created_at":"2025-12-22T19:14:17.552423-06:00","created_by":"daemon"}]}
{"id":"scribe-bw0.3","title":"Update package names in Decision 3 (internal architecture)","description":"## Update Package Names in Decision 3\n\n**File**: `architecture/decision_3_internal_architecture.md`\n**Sections affected**: 3.1-3.4 (Engine Layer subsections)\n\n### Current State\n\nDecision 3 defines the four-layer architecture:\n1. Foundations (shared types)\n2. Engine Layer\n3. Bridge Layer (preload)\n4. UI Layer (renderer)\n\nThe Engine Layer section references packages that don't match actual names.\n\n### Required Changes\n\n1. **Section 3.1 (engine-core)**: Already correct in concept, but may reference wrong import paths\n2. **Section 3.2 (storage-fs)**: Verify name matches\n3. **Section 3.3 (engine-graph)**: Update from any `/packages/graph` references\n4. **Section 3.4 (engine-search)**: Update from any `/packages/search` references\n\n### Additional Context to Add\n\nThe Engine Layer now includes:\n- **Task system** (in engine-core): Task extraction, indexing, reconciliation, persistence\n- **Browser-safe exports**: engine-core carefully separates browser-safe code (extractors) from Node-only code (persistence)\n\n### Import Path Examples\n\n```typescript\n// Correct\nimport { extractMetadata } from '@scribe/engine-core';\nimport { SearchEngine } from '@scribe/engine-search';\nimport { GraphEngine } from '@scribe/engine-graph';\nimport { FileSystemVault } from '@scribe/storage-fs';\n\n// Incorrect (old)\nimport { SearchEngine } from '@scribe/search';\n```\n\n### Parallelizable\n\nThis task can run in parallel with scribe-bw0.2 - both use the same package naming.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T19:08:36.28407-06:00","updated_at":"2025-12-22T19:34:33.076763-06:00","closed_at":"2025-12-22T19:34:33.076763-06:00","dependencies":[{"issue_id":"scribe-bw0.3","depends_on_id":"scribe-bw0","type":"parent-child","created_at":"2025-12-22T19:08:36.284428-06:00","created_by":"daemon"}]}
{"id":"scribe-bw0.4","title":"Fix electron-builder config location in Decision 2","description":"## Fix Electron-Builder Config Location in Decision 2\n\n**File**: `architecture/decision_2_project_structure.md`\n**Lines to update**: ~32-34 (documented builder directory)\n\n### Current State (Incorrect)\n\n```\n/apps/desktop/electron/builder/\n  electron-builder.yml\n```\n\nThis directory and file do not exist.\n\n### Target State (Correct)\n\nThe electron-builder configuration is embedded in `/apps/desktop/package.json` under the `\"build\"` key:\n\n```json\n{\n  \"build\": {\n    \"appId\": \"com.scribe.app\",\n    \"productName\": \"Scribe\",\n    \"mac\": {\n      \"target\": [\"dmg\", \"zip\"],\n      \"icon\": \"build/icon.icns\"\n    },\n    // ... additional config\n  }\n}\n```\n\n### Why This Pattern\n\nelectron-builder supports both external YAML files and inline package.json config. The inline approach:\n1. **Reduces file count**: One less config file to maintain\n2. **Co-locates concerns**: Build config lives with the app it builds\n3. **Simpler CI**: No need to specify config file path in build scripts\n\n### Implementation Notes\n\n1. Remove the documented `/builder` directory from the structure diagram\n2. Add a note explaining that build config lives in package.json\n3. Reference the actual config location: `/apps/desktop/package.json` ‚Üí `\"build\"` key\n4. Mention that this follows electron-builder's recommended \"simple project\" pattern\n\n### Verification\n\n- Confirm `/apps/desktop/electron/builder/` does not exist: `ls apps/desktop/electron/`\n- Confirm build config exists in package.json: `jq '.build' apps/desktop/package.json`","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T19:08:36.364585-06:00","updated_at":"2025-12-22T19:35:26.731787-06:00","closed_at":"2025-12-22T19:35:26.731787-06:00","dependencies":[{"issue_id":"scribe-bw0.4","depends_on_id":"scribe-bw0","type":"parent-child","created_at":"2025-12-22T19:08:36.364966-06:00","created_by":"daemon"}]}
{"id":"scribe-bw0.5","title":"Update preload API documentation in Decision 3","description":"## Update Preload API Documentation in Decision 3\n\n**File**: `architecture/decision_3_internal_architecture.md`\n**Section**: 4 (Bridge Layer)\n**Source of truth**: `packages/shared/src/ipc-contract.ts`\n\n### Current State (Minimal)\n\n```typescript\nwindow.scribe = {\n  notes: { list, read, save, create },\n  search: { query },\n  graph: { forNote, backlinks },\n}\n```\n\nThis shows ~10 methods. Reality has 50+ methods across 13 API domains.\n\n### Target State (Complete)\n\n```typescript\nwindow.scribe = {\n  ping: () =\u003e Promise\u003c'pong'\u003e,\n  \n  notes: {\n    list, read, create, save, delete,\n    findByTitle, searchTitles, findByDate\n  },\n  \n  search: { query },\n  \n  graph: { forNote, backlinks, notesWithTag },\n  \n  shell: { openExternal },\n  \n  app: {\n    openDevTools, getLastOpenedNote, setLastOpenedNote,\n    getConfig, setConfig\n  },\n  \n  people: { list, create, search },\n  \n  daily: { getOrCreate, find },\n  \n  meeting: { create, addAttendee, removeAttendee },\n  \n  dictionary: {\n    addWord, removeWord, getLanguages,\n    setLanguages, getAvailableLanguages\n  },\n  \n  tasks: { list, toggle, reorder, get, onChange },\n  \n  update: {\n    check, install,\n    onChecking, onAvailable, onNotAvailable, onDownloaded, onError\n  },\n  \n  cli: { install, isInstalled, uninstall, getStatus },\n  \n  export: { toMarkdown }\n}\n```\n\n### API Domain Explanations\n\n| Domain | Purpose | Note Type Affinity |\n|--------|---------|-------------------|\n| notes | Core CRUD operations | All notes |\n| search | Full-text search | All notes |\n| graph | Relationship queries | All notes |\n| shell | System integration | N/A |\n| app | Application state | N/A |\n| people | Person management | PersonNote |\n| daily | Daily note creation | DailyNote |\n| meeting | Meeting management | MeetingNote |\n| dictionary | Spellcheck dictionary | N/A |\n| tasks | Task extraction/toggle | All notes with checklists |\n| update | Auto-update lifecycle | N/A |\n| cli | CLI tool management | N/A |\n| export | Export to external formats | All notes |\n\n### Implementation Notes\n\n1. Update the example code block with full API surface\n2. Add brief descriptions for each domain\n3. Note that the API is defined in `@scribe/shared` and implemented in preload\n4. Emphasize that this is a security boundary: renderer has no Node.js access\n\n### Cross-references\n\n- This API is INVOKED in Decision 6 (command palette) and Decision 7 (editor)\n- The IPC channels backing this API are documented in Decision 5","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T19:08:36.443963-06:00","updated_at":"2025-12-22T19:38:23.833791-06:00","closed_at":"2025-12-22T19:38:23.833791-06:00","dependencies":[{"issue_id":"scribe-bw0.5","depends_on_id":"scribe-bw0","type":"parent-child","created_at":"2025-12-22T19:08:36.444309-06:00","created_by":"daemon"}]}
{"id":"scribe-bw0.6","title":"Update IPC channels documentation in Decision 5","description":"## Update IPC Channels Documentation in Decision 5\n\n**File**: `architecture/decision_5_engine_lifecycle.md`\n**Section**: 6 (IPC Routing Architecture)\n**Source of truth**: `packages/shared/src/ipc-contract.ts` ‚Üí `IPC_CHANNELS`\n\n### Current State (Incomplete)\n\nDocumented channels (~7):\n- `notes:list`, `notes:read`, `notes:create`, `notes:save`\n- `search:query`\n- `graph:forNote`, `graph:backlinks`\n\n### Target State (Complete)\n\nThe `IPC_CHANNELS` constant defines ALL channels:\n\n```typescript\nIPC_CHANNELS = {\n  // Notes domain\n  notes: {\n    list: 'notes:list',\n    read: 'notes:read',\n    create: 'notes:create',\n    save: 'notes:save',\n    delete: 'notes:delete',\n    findByTitle: 'notes:findByTitle',\n    searchTitles: 'notes:searchTitles',\n    findByDate: 'notes:findByDate',\n  },\n  \n  // Search domain\n  search: { query: 'search:query' },\n  \n  // Graph domain\n  graph: {\n    forNote: 'graph:forNote',\n    backlinks: 'graph:backlinks',\n    notesWithTag: 'graph:notesWithTag',\n  },\n  \n  // ... and 10 more domains\n}\n```\n\n### Channel Naming Convention\n\nAll channels follow `{domain}:{action}` pattern:\n- Domain = API namespace (notes, search, graph, etc.)\n- Action = specific operation (list, create, query, etc.)\n\nThis enables:\n1. **Handler organization**: Each domain has its own handler file\n2. **Permission scoping** (future): Could restrict domains per window\n3. **Logging/debugging**: Easy to filter by domain\n\n### Handler File Mapping\n\n| Domain | Handler File | Location |\n|--------|-------------|----------|\n| notes | notesHandlers.ts | electron/main/src/handlers/ |\n| search | searchHandlers.ts | electron/main/src/handlers/ |\n| graph | graphHandlers.ts | electron/main/src/handlers/ |\n| people | peopleHandlers.ts | electron/main/src/handlers/ |\n| daily | dailyHandlers.ts | electron/main/src/handlers/ |\n| meeting | meetingHandlers.ts | electron/main/src/handlers/ |\n| dictionary | dictionaryHandlers.ts | electron/main/src/handlers/ |\n| tasks | tasksHandlers.ts | electron/main/src/handlers/ |\n| cli | cliHandlers.ts | electron/main/src/handlers/ |\n| export | exportHandlers.ts | electron/main/src/handlers/ |\n| app | appHandlers.ts | electron/main/src/handlers/ |\n\n### Implementation Notes\n\n1. Replace the incomplete channel list with reference to `IPC_CHANNELS`\n2. Add the handler file mapping table\n3. Explain the naming convention\n4. Note that channels are typed end-to-end via `@scribe/shared`\n\n### Relationship to scribe-bw0.5\n\nThis task documents the BACKEND of what scribe-bw0.5 documents as the FRONTEND API. They should be consistent.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T19:08:36.524143-06:00","updated_at":"2025-12-22T19:39:29.712648-06:00","closed_at":"2025-12-22T19:39:29.712648-06:00","dependencies":[{"issue_id":"scribe-bw0.6","depends_on_id":"scribe-bw0","type":"parent-child","created_at":"2025-12-22T19:08:36.524515-06:00","created_by":"daemon"}]}
{"id":"scribe-bw0.7","title":"Rewrite editor component structure in Decision 7","description":"## Rewrite Editor Component Structure in Decision 7\n\n**File**: `architecture/decision_7_editor_architecture.md`\n**Section**: 3 (Editor Component Structure)\n**Source of truth**: `apps/desktop/renderer/src/components/Editor/`\n\n### Current State (Incomplete/Incorrect)\n\n```\nEditor/\n  EditorRoot.tsx\n  useNoteState.ts           ‚ùå Does not exist\n  plugins/\n    AutosavePlugin.ts\n    MetadataExtractionPlugin.ts   ‚ùå Does not exist\n    CommandPaletteOverlay.tsx     ‚ùå Wrong location\n```\n\n### Target State (Accurate)\n\n```\nEditor/\n  EditorRoot.tsx              # LexicalComposer setup, node registration\n  index.ts                    # Barrel export\n  editor.css.ts               # Editor styles (vanilla-extract)\n  \n  plugins/\n    # Save plugins\n    AutosavePlugin.tsx        # Debounced auto-save on content change\n    ManualSavePlugin.tsx      # Cmd/Ctrl+S handler\n    \n    # Link plugins\n    WikiLinkPlugin.tsx        # [[wiki-link]] autocomplete\n    WikiLinkNode.ts           # Custom Lexical node for wiki links\n    LinkClickPlugin.tsx       # External link click handling\n    InlineLinkNode.ts         # Inline link node type\n    \n    # Mention plugins\n    PersonMentionPlugin.tsx   # @person mention autocomplete\n    PersonMentionNode.ts      # Custom node for person mentions\n    \n    # Table plugins\n    TablePlugin.tsx           # Base table support\n    TableKeyboardPlugin.tsx   # Tab/arrow navigation in tables\n    TableUIPlugin.tsx         # Table control UI\n    TableContentPlugin.tsx    # Table content management\n    \n    # Utility plugins\n    InitialStatePlugin.tsx    # Loads note content into editor\n    HorizontalRulePlugin.tsx  # --- horizontal rule insertion\n    FocusNodePlugin.tsx       # Navigate to specific node (for Tasks)\n    CheckListShortcutPlugin.tsx # Checklist keyboard shortcuts\n    \n  SelectionToolbar/\n    SelectionToolbarPlugin.tsx # Floating toolbar on text selection\n    \n  SlashMenu/\n    SlashMenuPlugin.tsx       # / command menu\n    commands.ts               # Available slash commands\n    \n  components/\n    TableControls.tsx         # Table manipulation UI\n    \n  hooks/\n    useTriggerableAutocomplete.ts # Shared autocomplete logic\n```\n\n### Plugin Architecture Patterns\n\n**1. Node + Plugin pairs**: Custom Lexical nodes (WikiLinkNode) are always paired with a Plugin that handles creation/interaction.\n\n**2. Domain grouping**: Table functionality is split across 4 plugins for separation of concerns:\n   - TablePlugin: Registration and basic setup\n   - TableKeyboardPlugin: Keyboard navigation\n   - TableUIPlugin: Visual controls\n   - TableContentPlugin: Content operations\n\n**3. Subdirectory components**: SelectionToolbar and SlashMenu are complex enough to warrant subdirectories.\n\n### Why This Structure Matters\n\n1. **Extensibility**: New features (e.g., code blocks, embeds) follow the same pattern\n2. **Testing**: Each plugin is independently testable\n3. **Performance**: Plugins can be lazy-loaded if needed\n4. **Maintenance**: Clear ownership of functionality\n\n### Registered Lexical Nodes\n\nEditorRoot registers these node types:\n- HeadingNode, QuoteNode, ListNode, ListItemNode\n- CodeNode, CodeHighlightNode\n- LinkNode, HorizontalRuleNode\n- WikiLinkNode (custom), PersonMentionNode (custom)\n- TableNode, TableRowNode, TableCellNode\n\n### Implementation Notes\n\n1. Replace Section 3 entirely with accurate structure\n2. Explain the plugin architecture patterns\n3. List all registered Lexical nodes\n4. Remove references to non-existent files (useNoteState.ts, MetadataExtractionPlugin.ts)\n5. Note that CommandPaletteOverlay is NOT a Lexical plugin‚Äîit's rendered above the editor","status":"in_progress","priority":1,"issue_type":"task","created_at":"2025-12-22T19:08:36.602585-06:00","updated_at":"2025-12-22T19:39:56.365428-06:00","dependencies":[{"issue_id":"scribe-bw0.7","depends_on_id":"scribe-bw0","type":"parent-child","created_at":"2025-12-22T19:08:36.602941-06:00","created_by":"daemon"}]}
{"id":"scribe-bw0.8","title":"Update command palette examples in Decision 6","description":"## Update Command Palette Documentation in Decision 6\n\n**File**: `architecture/decision_6_command_palette_architecture.md`\n**Section**: 4 (Core Commands)\n**Source of truth**: `apps/desktop/renderer/src/hooks/useAppCommands.tsx`\n\n### Scope (Merged from bw0.8 + bw0.18)\n\nThis task both:\n1. Updates examples that reference outdated APIs\n2. Expands the command list from 6 to the full inventory\n\n### Current State (Minimal)\n\nMVP commands listed (~6): New Note, Open Note, Search Notes, Show Backlinks, Save Note, Open Developer Tools\n\n### Target State (Complete)\n\nFull command inventory organized by group:\n\n**Notes Group**: Create Note (Cmd+N), Open Note (Cmd+O), Save Note (Cmd+S), Delete Note (Cmd+Backspace), Show Backlinks\n**Navigation Group**: Go to Tasks, Go to Today\n**People Group**: Create Person, Search People\n**Templates Group**: Create Daily Note, Create Meeting\n**View Group**: Toggle Theme\n**Developer Group**: Open DevTools (Cmd+Shift+I)\n\n### Implementation Notes\n\n1. Expand Section 4 with complete command table\n2. Group commands by their `group` property\n3. Include shortcuts where defined\n4. Update any examples that call outdated preload APIs\n\n### Priority\n\nP2 - The documented commands are accurate but incomplete. Not misleading, just underrepresenting.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-22T19:08:36.682692-06:00","updated_at":"2025-12-22T19:21:43.171467-06:00","dependencies":[{"issue_id":"scribe-bw0.8","depends_on_id":"scribe-bw0","type":"parent-child","created_at":"2025-12-22T19:08:36.683095-06:00","created_by":"daemon"}]}
{"id":"scribe-bw0.9","title":"Phase 2: Add Missing Documentation","description":"## Phase 2: Add Missing Documentation\n\nThis is a **milestone marker** for Phase 2 completion. It depends on Phase 1 completion and all Phase 2 tasks.\n\n### Why Phase 2 Matters\n\nPhase 2 addresses documentation GAPS‚Äîentire systems that exist but have no architectural documentation:\n\n1. **CLI Application**: Proves the engine is reusable (a core architectural goal) but this validation isn't captured anywhere\n2. **Task System**: A complete extraction/indexing/reconciliation system with sophisticated conflict resolution\n3. **Auto-Update**: Production-critical for desktop apps, completely undocumented\n4. **Quarantine System**: Data recovery mechanism for corrupt files‚Äîimportant for data integrity promises\n5. **Design System**: The UI foundation with tokens, themes, primitives\n\n### Scope for New Documents\n\nEach new Decision document should follow the established format:\n1. Overview (why this system exists)\n2. Core concepts and terminology\n3. Architecture/structure\n4. Data flow\n5. Extension points\n6. Rationale (why these choices)\n7. Final Definition (summary)\n\n### Completion Criteria\n\n- Decision 9 (CLI) created and complete\n- Decision 10 (Task System) created and complete\n- Decision 5 updated with auto-update section\n- Decision 4 updated with quarantine section\n- Decision 11 (Design System) created and complete\n\n### Dependencies\n\n- Depends on Phase 1 completion (scribe-bw0.1) to ensure new documents reference accurate information\n- Phase 3 depends on Phase 2 for cross-referencing","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-22T19:08:36.762895-06:00","updated_at":"2025-12-22T19:21:22.00314-06:00","closed_at":"2025-12-22T19:21:22.00314-06:00","dependencies":[{"issue_id":"scribe-bw0.9","depends_on_id":"scribe-bw0","type":"parent-child","created_at":"2025-12-22T19:08:36.763256-06:00","created_by":"daemon"},{"issue_id":"scribe-bw0.9","depends_on_id":"scribe-bw0.1","type":"blocks","created_at":"2025-12-22T19:14:05.777862-06:00","created_by":"daemon"},{"issue_id":"scribe-bw0.9","depends_on_id":"scribe-bw0.10","type":"blocks","created_at":"2025-12-22T19:14:05.865275-06:00","created_by":"daemon"},{"issue_id":"scribe-bw0.9","depends_on_id":"scribe-bw0.11","type":"blocks","created_at":"2025-12-22T19:14:05.950048-06:00","created_by":"daemon"},{"issue_id":"scribe-bw0.9","depends_on_id":"scribe-bw0.12","type":"blocks","created_at":"2025-12-22T19:14:06.032735-06:00","created_by":"daemon"},{"issue_id":"scribe-bw0.9","depends_on_id":"scribe-bw0.13","type":"blocks","created_at":"2025-12-22T19:14:06.116033-06:00","created_by":"daemon"},{"issue_id":"scribe-bw0.9","depends_on_id":"scribe-bw0.14","type":"blocks","created_at":"2025-12-22T19:14:06.19871-06:00","created_by":"daemon"}]}
{"id":"scribe-do7","title":"References Panel Improvements (GH-44)","description":"## Overview\n\nThis epic addresses three interconnected issues with the References Panel in the ContextPanel:\n\n1. **Bug: Incorrect display text for links** - The References panel shows raw URLs (e.g., \"google.com\") instead of the markdown link alias (e.g., \"My Link Text\"). This is a data extraction bug where we're reading `node.title` (HTML title attribute, usually null) instead of extracting text from `node.children` (where the actual link text lives as TextNodes).\n\n2. **Feature: Automatic URL detection** - Raw URLs typed or pasted into notes are not recognized as links. Users must manually write markdown syntax `[text](url)`. This requires adding Lexical's AutoLinkPlugin which watches for URL patterns and converts them to AutoLinkNodes.\n\n3. **Enhancement: Collapse/expand UI** - For notes with many references, the panel gets too long. Need to match the TasksWidget pattern with collapsed/expanded states and a \"Show X more\" button.\n\n## Technical Context\n\n### Lexical Link Node Structure\nUnderstanding this is critical for Bug 1. When you write `[My Link](https://example.com)` in markdown, Lexical serializes it as:\n```json\n{\n  \"type\": \"link\",\n  \"url\": \"https://example.com\",\n  \"title\": null,  // ‚Üê HTML title attribute, NOT the display text!\n  \"children\": [\n    { \"type\": \"text\", \"text\": \"My Link\" }  // ‚Üê Actual text lives HERE\n  ]\n}\n```\nThe current code incorrectly uses `node.title` for display text. It needs to recursively extract text from `node.children`.\n\n### AutoLinkNode vs LinkNode\n- `LinkNode` (type: \"link\"): Created from markdown syntax `[text](url)`\n- `AutoLinkNode` (type: \"autolink\"): Created by AutoLinkPlugin for raw URLs\nBoth need to be extracted by ReferencesWidget. AutoLinkNode will have empty children (the URL text IS the display text).\n\n### UI Consistency\nThe collapse/expand pattern already exists in TasksWidget and LinkedMentions. We should reuse:\n- `expandButton` style from ContextPanel.css.ts\n- Same state management pattern (isExpanded, COLLAPSED_LIMIT, EXPANDED_LIMIT)\n- ChevronDownIcon/ChevronUpIcon from design-system\n\n## Files Involved\n- `apps/desktop/renderer/src/components/ContextPanel/ReferencesWidget.tsx` (main changes)\n- `apps/desktop/renderer/src/components/ContextPanel/ReferencesWidget.test.tsx` (test additions)\n- `apps/desktop/renderer/src/components/ContextPanel/ReferencesWidget.css.ts` (scrollable style)\n- `apps/desktop/renderer/src/components/ContextPanel/ContextPanel.css.ts` (shared styles)\n- `apps/desktop/renderer/src/components/Editor/EditorRoot.tsx` (register AutoLinkNode, add plugin)\n- `apps/desktop/renderer/src/components/Editor/plugins/AutoLinkPlugin.tsx` (new file)\n\n## Dependencies\nAll required packages are already installed:\n- `@lexical/link` (v0.38.2) - provides AutoLinkNode\n- `@lexical/react` (v0.38.2) - provides AutoLinkPlugin, createLinkMatcherWithRegExp\n- `@scribe/design-system` - provides ChevronDownIcon, ChevronUpIcon\n\n## Success Criteria\n1. Links with markdown aliases show alias text, not URL\n2. Links with formatted text (bold/italic) show concatenated text\n3. Raw typed/pasted URLs auto-convert to clickable links\n4. AutoLinks appear in References panel with truncated URL display\n5. References panel collapses to 5 items with \"Show X more\" button\n6. Expanded state shows up to 15 items with scrolling\n7. All existing tests pass\n8. New tests cover all edge cases","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-22T19:35:32.682702-06:00","updated_at":"2025-12-22T19:35:32.682702-06:00"}
{"id":"scribe-do7.1","title":"Add extractChildrenText helper function for recursive text extraction","description":"## Purpose\nCreate a helper function that recursively extracts text content from a Lexical node's children. This is the foundation for fixing Bug 1 (link aliases not showing).\n\n## Why This Is Needed\nLexical stores link display text in children TextNodes, NOT in the `title` property:\n```typescript\n// Current (WRONG): node.title is the HTML title attribute, usually null\nconst displayText = (node.title as string) || truncateUrl(url);\n\n// Correct: Extract text from children array\n{\n  type: \"link\",\n  url: \"https://example.com\",\n  title: null,  // ‚Üê NOT the display text\n  children: [{ type: \"text\", text: \"My Link\" }]  // ‚Üê Text lives HERE\n}\n```\n\n## Implementation Details\n```typescript\n/**\n * Extract text content from a node's children recursively.\n * Handles nested structures like formatted text within links:\n * - [**bold** and plain](url) ‚Üí \"bold and plain\"\n * - [Part 1 Part 2](url) ‚Üí \"Part 1 Part 2\"\n */\nfunction extractChildrenText(node: Record\u003cstring, unknown\u003e): string {\n  const textParts: string[] = [];\n\n  function traverse(n: Record\u003cstring, unknown\u003e) {\n    if (n.type === 'text' \u0026\u0026 typeof n.text === 'string') {\n      textParts.push(n.text);\n    }\n    if (Array.isArray(n.children)) {\n      for (const child of n.children as Record\u003cstring, unknown\u003e[]) {\n        traverse(child);\n      }\n    }\n  }\n\n  if (Array.isArray(node.children)) {\n    for (const child of node.children as Record\u003cstring, unknown\u003e[]) {\n      traverse(child);\n    }\n  }\n\n  return textParts.join('');\n}\n```\n\n## Edge Cases to Handle\n1. **Empty children array**: Return empty string, fallback to URL\n2. **Multiple text nodes**: Concatenate them (e.g., \"bold and plain\")\n3. **Nested formatting**: `[**bold** text](url)` has nested children\n4. **Non-text children**: Skip them, only extract type=\"text\" nodes\n\n## Location\nAdd this function BEFORE `extractReferences` in ReferencesWidget.tsx (line ~28)\n\n## Testing\nWill be tested in scribe-do7.10","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-22T19:35:32.758747-06:00","updated_at":"2025-12-22T19:35:51.50497-06:00","dependencies":[{"issue_id":"scribe-do7.1","depends_on_id":"scribe-do7","type":"parent-child","created_at":"2025-12-22T19:35:32.759044-06:00","created_by":"daemon"}]}
{"id":"scribe-do7.10","title":"Add unit tests for extractChildrenText with various text node structures","description":"## Purpose\nAdd comprehensive unit tests for the new `extractChildrenText` helper function to ensure it handles all edge cases correctly.\n\n## Test Cases to Add\n\n```typescript\ndescribe('extractChildrenText', () =\u003e {\n  it('extracts text from single TextNode child', () =\u003e {\n    // Input: [My Link](url)\n    const node = {\n      type: 'link',\n      url: 'https://example.com',\n      children: [{ type: 'text', text: 'My Link' }],\n    };\n    // Expected: \"My Link\"\n  });\n\n  it('concatenates text from multiple TextNode children', () =\u003e {\n    // Input: [Part 1 Part 2](url) (two text nodes)\n    const node = {\n      type: 'link',\n      children: [\n        { type: 'text', text: 'Part 1 ' },\n        { type: 'text', text: 'Part 2' },\n      ],\n    };\n    // Expected: \"Part 1 Part 2\"\n  });\n\n  it('extracts text from nested formatting nodes', () =\u003e {\n    // Input: [**bold** and plain](url)\n    // Bold text is wrapped in a formatting node\n    const node = {\n      type: 'link',\n      children: [\n        {\n          type: 'format',\n          format: 1, // bold\n          children: [{ type: 'text', text: 'bold' }],\n        },\n        { type: 'text', text: ' and plain' },\n      ],\n    };\n    // Expected: \"bold and plain\"\n  });\n\n  it('returns empty string for empty children array', () =\u003e {\n    const node = { type: 'link', children: [] };\n    // Expected: \"\"\n  });\n\n  it('returns empty string for node without children', () =\u003e {\n    const node = { type: 'link' };\n    // Expected: \"\"\n  });\n\n  it('handles deeply nested children', () =\u003e {\n    // Input: [**_bold italic_** text](url)\n    const node = {\n      type: 'link',\n      children: [\n        {\n          type: 'format',\n          children: [\n            {\n              type: 'format',\n              children: [{ type: 'text', text: 'bold italic' }],\n            },\n          ],\n        },\n        { type: 'text', text: ' text' },\n      ],\n    };\n    // Expected: \"bold italic text\"\n  });\n\n  it('skips non-text nodes without children', () =\u003e {\n    const node = {\n      type: 'link',\n      children: [\n        { type: 'linebreak' }, // Should be skipped\n        { type: 'text', text: 'text' },\n      ],\n    };\n    // Expected: \"text\"\n  });\n});\n```\n\n## Test Structure\nAdd new describe block in ReferencesWidget.test.tsx, export the helper from main file for testing.\n\n## Why These Cases Matter\n1. **Single TextNode**: Most common case (simple link text)\n2. **Multiple TextNodes**: Can occur with inline code or spaces\n3. **Nested formatting**: Bold/italic links are common\n4. **Empty children**: AutoLinkNodes have this\n5. **Missing children**: Defensive against malformed data\n6. **Deep nesting**: Edge case but possible\n\n## Depends On\n- scribe-do7.1 (function must exist to test)\n\n## Location\napps/desktop/renderer/src/components/ContextPanel/ReferencesWidget.test.tsx","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-22T19:35:33.383639-06:00","updated_at":"2025-12-22T19:37:54.106468-06:00","dependencies":[{"issue_id":"scribe-do7.10","depends_on_id":"scribe-do7","type":"parent-child","created_at":"2025-12-22T19:35:33.383936-06:00","created_by":"daemon"},{"issue_id":"scribe-do7.10","depends_on_id":"scribe-do7.1","type":"blocks","created_at":"2025-12-22T19:39:20.091853-06:00","created_by":"daemon"}]}
{"id":"scribe-do7.11","title":"Add unit tests for autolink node extraction","description":"## Purpose\nAdd unit tests to verify that AutoLinkNodes (type: \"autolink\") are properly extracted and displayed in the References panel.\n\n## Test Cases to Add\n\n```typescript\ndescribe('extractReferences with autolink nodes', () =\u003e {\n  it('extracts autolink nodes with truncated URL display', () =\u003e {\n    const note = mockNote([\n      {\n        type: 'paragraph',\n        children: [\n          {\n            type: 'autolink',\n            url: 'https://example.com/page',\n            children: [], // AutoLinks have empty children\n          },\n        ],\n      },\n    ]);\n\n    render(\u003cReferencesWidget note={note} onNavigate={() =\u003e {}} /\u003e);\n    // Should show truncated URL since no alias\n    expect(screen.getByText('example.com/page')).toBeInTheDocument();\n  });\n\n  it('extracts both link and autolink nodes', () =\u003e {\n    const note = mockNote([\n      {\n        type: 'paragraph',\n        children: [\n          {\n            type: 'link',\n            url: 'https://example.com',\n            children: [{ type: 'text', text: 'Manual Link' }],\n          },\n          {\n            type: 'autolink',\n            url: 'https://auto.example.com',\n            children: [],\n          },\n        ],\n      },\n    ]);\n\n    render(\u003cReferencesWidget note={note} onNavigate={() =\u003e {}} /\u003e);\n    expect(screen.getByText('Manual Link')).toBeInTheDocument();\n    expect(screen.getByText('auto.example.com')).toBeInTheDocument();\n  });\n\n  it('deduplicates same URL across link and autolink types', () =\u003e {\n    const note = mockNote([\n      {\n        type: 'paragraph',\n        children: [\n          { type: 'link', url: 'https://example.com', children: [{ type: 'text', text: 'Link' }] },\n          { type: 'autolink', url: 'https://example.com', children: [] },\n        ],\n      },\n    ]);\n\n    render(\u003cReferencesWidget note={note} onNavigate={() =\u003e {}} /\u003e);\n    // Should only show first occurrence\n    expect(screen.getAllByRole('button')).toHaveLength(1);\n    expect(screen.getByText('Link')).toBeInTheDocument();\n  });\n\n  it('opens autolink URLs in new tab on click', () =\u003e {\n    const windowOpen = vi.spyOn(window, 'open').mockImplementation(() =\u003e null);\n    const note = mockNote([\n      {\n        type: 'paragraph',\n        children: [\n          { type: 'autolink', url: 'https://example.com', children: [] },\n        ],\n      },\n    ]);\n\n    render(\u003cReferencesWidget note={note} onNavigate={() =\u003e {}} /\u003e);\n    fireEvent.click(screen.getByRole('button'));\n\n    expect(windowOpen).toHaveBeenCalledWith(\n      'https://example.com',\n      '_blank',\n      'noopener,noreferrer'\n    );\n    windowOpen.mockRestore();\n  });\n});\n```\n\n## Why These Cases Matter\n1. **Basic extraction**: Verify autolink type is recognized\n2. **Mixed types**: Common scenario (manual + auto links)\n3. **Deduplication**: Same URL shouldn't appear twice\n4. **Click behavior**: AutoLinks should open like regular URLs\n\n## Depends On\n- scribe-do7.3 (autolink handling in extractReferences)\n\n## Location\napps/desktop/renderer/src/components/ContextPanel/ReferencesWidget.test.tsx","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-22T19:35:33.450194-06:00","updated_at":"2025-12-22T19:38:10.581901-06:00","dependencies":[{"issue_id":"scribe-do7.11","depends_on_id":"scribe-do7","type":"parent-child","created_at":"2025-12-22T19:35:33.450528-06:00","created_by":"daemon"},{"issue_id":"scribe-do7.11","depends_on_id":"scribe-do7.3","type":"blocks","created_at":"2025-12-22T19:39:20.140237-06:00","created_by":"daemon"}]}
{"id":"scribe-do7.12","title":"Add unit tests for collapse/expand functionality","description":"## Purpose\nAdd unit tests for the collapse/expand functionality to ensure proper state management and UI rendering.\n\n## Test Cases to Add\n\n```typescript\ndescribe('collapse/expand functionality', () =\u003e {\n  // Helper to create note with many references\n  function mockNoteWithRefs(count: number): Note {\n    const children = Array.from({ length: count }, (_, i) =\u003e ({\n      type: 'link',\n      url: `https://example${i}.com`,\n      children: [{ type: 'text', text: `Link ${i + 1}` }],\n    }));\n    return mockNote([{ type: 'paragraph', children }]);\n  }\n\n  it('shows all references when count is at or below COLLAPSED_LIMIT', () =\u003e {\n    const note = mockNoteWithRefs(5);\n    render(\u003cReferencesWidget note={note} onNavigate={() =\u003e {}} /\u003e);\n\n    // All 5 should be visible\n    expect(screen.getAllByRole('button')).toHaveLength(5);\n    // No expand button\n    expect(screen.queryByText(/Show \\d+ more/)).not.toBeInTheDocument();\n  });\n\n  it('shows COLLAPSED_LIMIT references with expand button when count exceeds limit', () =\u003e {\n    const note = mockNoteWithRefs(8);\n    render(\u003cReferencesWidget note={note} onNavigate={() =\u003e {}} /\u003e);\n\n    // Only 5 visible initially\n    expect(screen.getAllByRole('button').filter(b =\u003e b.textContent?.startsWith('Link'))).toHaveLength(5);\n    // Expand button shows correct count\n    expect(screen.getByText('Show 3 more')).toBeInTheDocument();\n  });\n\n  it('expands to show more references when expand button is clicked', () =\u003e {\n    const note = mockNoteWithRefs(8);\n    render(\u003cReferencesWidget note={note} onNavigate={() =\u003e {}} /\u003e);\n\n    fireEvent.click(screen.getByText('Show 3 more'));\n\n    // All 8 should now be visible\n    expect(screen.getAllByRole('button').filter(b =\u003e b.textContent?.startsWith('Link'))).toHaveLength(8);\n    // Button now shows \"Show less\"\n    expect(screen.getByText('Show less')).toBeInTheDocument();\n  });\n\n  it('collapses when \"Show less\" button is clicked', () =\u003e {\n    const note = mockNoteWithRefs(8);\n    render(\u003cReferencesWidget note={note} onNavigate={() =\u003e {}} /\u003e);\n\n    // Expand\n    fireEvent.click(screen.getByText('Show 3 more'));\n    // Collapse\n    fireEvent.click(screen.getByText('Show less'));\n\n    // Back to 5 visible\n    expect(screen.getAllByRole('button').filter(b =\u003e b.textContent?.startsWith('Link'))).toHaveLength(5);\n    expect(screen.getByText('Show 3 more')).toBeInTheDocument();\n  });\n\n  it('caps expanded view at EXPANDED_LIMIT references', () =\u003e {\n    const note = mockNoteWithRefs(20);\n    render(\u003cReferencesWidget note={note} onNavigate={() =\u003e {}} /\u003e);\n\n    // Button shows capped count (10 = 15 - 5)\n    expect(screen.getByText('Show 10 more')).toBeInTheDocument();\n\n    fireEvent.click(screen.getByText('Show 10 more'));\n\n    // Only 15 visible (not all 20)\n    expect(screen.getAllByRole('button').filter(b =\u003e b.textContent?.startsWith('Link'))).toHaveLength(15);\n  });\n\n  it('has correct accessibility attributes on expand button', () =\u003e {\n    const note = mockNoteWithRefs(8);\n    render(\u003cReferencesWidget note={note} onNavigate={() =\u003e {}} /\u003e);\n\n    const expandButton = screen.getByRole('button', { name: /Show 3 more references/ });\n    expect(expandButton).toHaveAttribute('aria-expanded', 'false');\n\n    fireEvent.click(expandButton);\n\n    const collapseButton = screen.getByRole('button', { name: /Show fewer references/ });\n    expect(collapseButton).toHaveAttribute('aria-expanded', 'true');\n  });\n});\n```\n\n## Why These Cases Matter\n1. **Below limit**: No expand button needed\n2. **At limit boundary**: Edge case for exactly 5 items\n3. **Above limit**: Expand button appears with correct count\n4. **Toggle behavior**: Expand and collapse work correctly\n5. **Upper cap**: Don't show infinite references\n6. **Accessibility**: Screen reader support\n\n## Depends On\n- scribe-do7.7 (state and constants)\n- scribe-do7.8 (expand button UI)\n\n## Location\napps/desktop/renderer/src/components/ContextPanel/ReferencesWidget.test.tsx","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-22T19:35:33.518973-06:00","updated_at":"2025-12-22T19:38:31.683911-06:00","dependencies":[{"issue_id":"scribe-do7.12","depends_on_id":"scribe-do7","type":"parent-child","created_at":"2025-12-22T19:35:33.519295-06:00","created_by":"daemon"},{"issue_id":"scribe-do7.12","depends_on_id":"scribe-do7.7","type":"blocks","created_at":"2025-12-22T19:39:20.189742-06:00","created_by":"daemon"},{"issue_id":"scribe-do7.12","depends_on_id":"scribe-do7.8","type":"blocks","created_at":"2025-12-22T19:39:20.23851-06:00","created_by":"daemon"}]}
{"id":"scribe-do7.13","title":"Run full test suite and verify no regressions","description":"## Purpose\nRun the full test suite to verify no regressions were introduced by the changes.\n\n## Commands to Run\n```bash\n# Run all tests\nbun test\n\n# Run specific test files for faster feedback\nbun test apps/desktop/renderer/src/components/ContextPanel/ReferencesWidget.test.tsx\nbun test apps/desktop/renderer/src/components/Editor\n\n# Run with coverage to check new code is tested\nbun test --coverage\n```\n\n## Expected Results\n1. All existing ReferencesWidget tests pass\n2. All existing EditorRoot tests pass (if any)\n3. New tests for extractChildrenText pass\n4. New tests for autolink extraction pass\n5. New tests for collapse/expand pass\n6. No TypeScript errors in modified files\n\n## Common Regression Points\n1. **Existing link tests**: May fail if display text logic changed incorrectly\n2. **Click handlers**: Ensure both wiki-links and URLs still work\n3. **Empty state**: Should still show \"No references\" when appropriate\n4. **Deduplication**: URLs should still be deduplicated\n\n## If Tests Fail\n1. Check if test expectations need updating (behavior change)\n2. Check if implementation has bugs\n3. Run single test with verbose output for debugging\n\n## Depends On\n- All implementation tasks (scribe-do7.1 through scribe-do7.9)\n- All test tasks (scribe-do7.10 through scribe-do7.12)\n\n## Location\nRun from repository root","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-22T19:35:33.589675-06:00","updated_at":"2025-12-22T19:38:41.230427-06:00","dependencies":[{"issue_id":"scribe-do7.13","depends_on_id":"scribe-do7","type":"parent-child","created_at":"2025-12-22T19:35:33.590023-06:00","created_by":"daemon"},{"issue_id":"scribe-do7.13","depends_on_id":"scribe-do7.1","type":"blocks","created_at":"2025-12-22T19:39:26.053537-06:00","created_by":"daemon"},{"issue_id":"scribe-do7.13","depends_on_id":"scribe-do7.2","type":"blocks","created_at":"2025-12-22T19:39:26.103174-06:00","created_by":"daemon"},{"issue_id":"scribe-do7.13","depends_on_id":"scribe-do7.3","type":"blocks","created_at":"2025-12-22T19:39:26.154069-06:00","created_by":"daemon"},{"issue_id":"scribe-do7.13","depends_on_id":"scribe-do7.4","type":"blocks","created_at":"2025-12-22T19:39:26.203874-06:00","created_by":"daemon"},{"issue_id":"scribe-do7.13","depends_on_id":"scribe-do7.5","type":"blocks","created_at":"2025-12-22T19:39:26.254322-06:00","created_by":"daemon"},{"issue_id":"scribe-do7.13","depends_on_id":"scribe-do7.6","type":"blocks","created_at":"2025-12-22T19:39:26.304221-06:00","created_by":"daemon"},{"issue_id":"scribe-do7.13","depends_on_id":"scribe-do7.7","type":"blocks","created_at":"2025-12-22T19:39:26.35366-06:00","created_by":"daemon"},{"issue_id":"scribe-do7.13","depends_on_id":"scribe-do7.8","type":"blocks","created_at":"2025-12-22T19:39:26.403205-06:00","created_by":"daemon"},{"issue_id":"scribe-do7.13","depends_on_id":"scribe-do7.9","type":"blocks","created_at":"2025-12-22T19:39:26.453466-06:00","created_by":"daemon"},{"issue_id":"scribe-do7.13","depends_on_id":"scribe-do7.10","type":"blocks","created_at":"2025-12-22T19:39:26.505662-06:00","created_by":"daemon"},{"issue_id":"scribe-do7.13","depends_on_id":"scribe-do7.11","type":"blocks","created_at":"2025-12-22T19:39:26.555595-06:00","created_by":"daemon"},{"issue_id":"scribe-do7.13","depends_on_id":"scribe-do7.12","type":"blocks","created_at":"2025-12-22T19:39:26.605266-06:00","created_by":"daemon"}]}
{"id":"scribe-do7.14","title":"Manual QA: Test link text extraction edge cases","description":"## Purpose\nManual QA testing of the link text extraction fix to catch edge cases that unit tests might miss.\n\n## Test Scenarios\n\n### Basic Link Text Extraction\n| Test | Steps | Expected |\n|------|-------|----------|\n| Simple alias | Create `[My Link](https://example.com)` | \"My Link\" in References |\n| Long alias | Create `[A very long link alias that should not be truncated](url)` | Full alias shown |\n| Empty alias | Create `[](https://example.com)` | \"example.com\" shown |\n| Bold in link | Create `[**bold text**](url)` | \"bold text\" shown |\n| Italic in link | Create `[_italic text_](url)` | \"italic text\" shown |\n| Mixed formatting | Create `[**bold** and _italic_](url)` | \"bold and italic\" shown |\n| Code in link | Create `[\\`code\\`](url)` | \"code\" shown |\n\n### Multiple Links\n| Test | Steps | Expected |\n|------|-------|----------|\n| Same URL, different aliases | Create two links to same URL | Only first appears |\n| Different URLs | Create 3 different links | All 3 appear in References |\n| Mixed wiki + URL links | Create wiki-link and URL | Both appear correctly |\n\n### Edge Cases\n| Test | Steps | Expected |\n|------|-------|----------|\n| Link in list item | Create `- [link](url)` | Extracted correctly |\n| Link in quote | Create `\u003e [link](url)` | Extracted correctly |\n| Link in heading | Create `# [link](url)` | Extracted correctly |\n| Multiple links same paragraph | Create sentence with 2 links | Both appear |\n\n## How to Test\n1. Start the app in dev mode: `bun run dev:desktop`\n2. Create a new note\n3. Type/paste test markdown\n4. Observe References panel on right\n\n## What to Look For\n- Link aliases display instead of URLs\n- Formatted text within links renders as plain text\n- No JavaScript errors in console\n- Performance is acceptable (no lag)\n\n## Depends On\n- scribe-do7.1 through scribe-do7.3 (implementation)\n- scribe-do7.13 (tests pass first)\n\n## Location\nManual testing in running application","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-22T19:35:33.657678-06:00","updated_at":"2025-12-22T19:38:54.277842-06:00","dependencies":[{"issue_id":"scribe-do7.14","depends_on_id":"scribe-do7","type":"parent-child","created_at":"2025-12-22T19:35:33.657978-06:00","created_by":"daemon"},{"issue_id":"scribe-do7.14","depends_on_id":"scribe-do7.13","type":"blocks","created_at":"2025-12-22T19:39:30.372377-06:00","created_by":"daemon"}]}
{"id":"scribe-do7.15","title":"Manual QA: Test auto-link detection for typed/pasted URLs","description":"## Purpose\nManual QA testing of the AutoLinkPlugin to verify URLs are automatically detected and converted to clickable links.\n\n## Test Scenarios\n\n### Typing URLs\n| Test | Steps | Expected |\n|------|-------|----------|\n| Type URL then space | Type `https://example.com ` | URL becomes clickable link |\n| Type URL then Enter | Type `https://example.com` + Enter | URL becomes clickable link |\n| HTTP URL | Type `http://example.com ` | Converts to link |\n| URL with path | Type `https://example.com/page/doc ` | Full URL linked |\n| URL with query params | Type `https://example.com?q=test ` | Full URL linked |\n| URL with fragment | Type `https://example.com#section ` | Full URL linked |\n| URL in sentence | Type `Check out https://example.com for info` | Only URL becomes link |\n\n### Pasting URLs\n| Test | Steps | Expected |\n|------|-------|----------|\n| Paste plain URL | Paste `https://example.com` | Converts to link |\n| Paste URL with text | Paste `See https://example.com` | URL portion linked |\n| Paste multiple URLs | Paste `https://a.com and https://b.com` | Both become links |\n\n### URLs That Should NOT Auto-Link\n| Test | Steps | Expected |\n|------|-------|----------|\n| mailto: | Type `mailto:test@example.com` | Stays as text |\n| ftp:// | Type `ftp://files.example.com` | Stays as text |\n| file:// | Type `file:///path/to/file` | Stays as text |\n| Domain without protocol | Type `example.com` | Stays as text |\n| URL in code block | Type URL inside \\`\\`\\` block | Stays as text |\n| URL in inline code | Type URL inside \\` \\` | Stays as text |\n\n### Auto-Link Behavior\n| Test | Steps | Expected |\n|------|-------|----------|\n| Undo auto-link | Type URL, then Cmd+Z | Reverts to plain text |\n| Click auto-link | Create auto-link, click it | Opens in browser |\n| Auto-link in References | Create auto-link | Appears in References panel |\n| Auto-link display | Check References panel | Shows truncated URL |\n\n### Conflict Avoidance\n| Test | Steps | Expected |\n|------|-------|----------|\n| Wiki-link not affected | Type `[[Note Title]]` | Normal wiki-link (not URL) |\n| Manual link preserved | Type `[text](url)` | Uses alias, not URL |\n\n## How to Test\n1. Start app: `bun run dev:desktop`\n2. Create new note\n3. Perform each test scenario\n4. Check References panel and link behavior\n\n## What to Look For\n- URLs convert as soon as you type space/Enter after them\n- Converted links are clickable (Cmd+click or click)\n- AutoLinks appear in References panel\n- No console errors during conversion\n- Undo/redo works correctly\n\n## Depends On\n- scribe-do7.4 through scribe-do7.6 (AutoLinkPlugin implementation)\n- scribe-do7.3 (References extraction for autolink)\n- scribe-do7.13 (tests pass first)\n\n## Location\nManual testing in running application","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-22T19:35:33.725691-06:00","updated_at":"2025-12-22T19:39:12.159444-06:00","dependencies":[{"issue_id":"scribe-do7.15","depends_on_id":"scribe-do7","type":"parent-child","created_at":"2025-12-22T19:35:33.726001-06:00","created_by":"daemon"},{"issue_id":"scribe-do7.15","depends_on_id":"scribe-do7.13","type":"blocks","created_at":"2025-12-22T19:39:30.42168-06:00","created_by":"daemon"}]}
{"id":"scribe-do7.2","title":"Update extractReferences to use children for link display text","description":"## Purpose\nUpdate the `extractReferences` function to use the new `extractChildrenText` helper for getting link display text instead of the incorrect `node.title` access.\n\n## Current Code (Bug Location)\n```typescript\n// Line 56 - WRONG\nconst displayText = (node.title as string) || truncateUrl(url);\n```\n\n## Fixed Code\n```typescript\n// Extract text from children first, then fall back to title attr, then truncated URL\nconst childrenText = extractChildrenText(node);\nconst displayText = childrenText || (node.title as string) || truncateUrl(url);\n```\n\n## Behavior Change\n| Input Markdown | Before (Bug) | After (Fixed) |\n|----------------|--------------|---------------|\n| `[My Link](url)` | \"example.com\" | \"My Link\" |\n| `[Google Search](url)` | \"google.com\" | \"Google Search\" |\n| `[**Bold** text](url)` | \"example.com\" | \"Bold text\" |\n| `[](url)` (empty alias) | \"example.com\" | \"example.com\" |\n\n## Fallback Chain\n1. `extractChildrenText(node)` - Primary: text from children\n2. `node.title` - Fallback: HTML title attribute (rare)\n3. `truncateUrl(url)` - Last resort: clean/truncated URL\n\n## Depends On\n- scribe-do7.1 (extractChildrenText helper)\n\n## Location\nModify line 56 in ReferencesWidget.tsx","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-22T19:35:32.829139-06:00","updated_at":"2025-12-22T19:35:59.05781-06:00","dependencies":[{"issue_id":"scribe-do7.2","depends_on_id":"scribe-do7","type":"parent-child","created_at":"2025-12-22T19:35:32.829466-06:00","created_by":"daemon"},{"issue_id":"scribe-do7.2","depends_on_id":"scribe-do7.1","type":"blocks","created_at":"2025-12-22T19:39:19.688835-06:00","created_by":"daemon"}]}
{"id":"scribe-do7.3","title":"Handle 'autolink' node type in extractReferences","description":"## Purpose\nExtend `extractReferences` to recognize AutoLinkNode (type: \"autolink\") in addition to regular LinkNode (type: \"link\"). This ensures auto-detected URLs appear in the References panel.\n\n## Why This Is Needed\nWhen AutoLinkPlugin (scribe-do7.5) converts raw URLs to links, it creates AutoLinkNode (not LinkNode). These serialize with `type: \"autolink\"`:\n```json\n// Regular markdown link [text](url)\n{ \"type\": \"link\", \"url\": \"...\", \"children\": [...] }\n\n// Auto-detected raw URL\n{ \"type\": \"autolink\", \"url\": \"...\", \"children\": [] }\n```\n\nWithout this change, auto-linked URLs won't appear in References.\n\n## Implementation\nChange the condition from:\n```typescript\nif (node.type === 'link' \u0026\u0026 typeof node.url === 'string') {\n```\nTo:\n```typescript\nif ((node.type === 'link' || node.type === 'autolink') \u0026\u0026 typeof node.url === 'string') {\n```\n\n## AutoLink Display Text Behavior\nAutoLinkNodes have empty children (the URL text becomes the link). So the fallback chain works:\n1. `extractChildrenText(node)` ‚Üí \"\" (empty)\n2. `node.title` ‚Üí null\n3. `truncateUrl(url)` ‚Üí \"example.com\" ‚Üê This is shown\n\nThis is correct behavior - auto-linked URLs should display the truncated URL since there's no alias.\n\n## Depends On\n- scribe-do7.1 (extractChildrenText helper)\n- scribe-do7.2 (updated display text logic)\n\n## Location\nModify line 51 condition in ReferencesWidget.tsx","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-22T19:35:32.899929-06:00","updated_at":"2025-12-22T19:36:07.988375-06:00","dependencies":[{"issue_id":"scribe-do7.3","depends_on_id":"scribe-do7","type":"parent-child","created_at":"2025-12-22T19:35:32.900275-06:00","created_by":"daemon"},{"issue_id":"scribe-do7.3","depends_on_id":"scribe-do7.1","type":"blocks","created_at":"2025-12-22T19:39:19.739072-06:00","created_by":"daemon"},{"issue_id":"scribe-do7.3","depends_on_id":"scribe-do7.2","type":"blocks","created_at":"2025-12-22T19:39:19.78995-06:00","created_by":"daemon"}]}
{"id":"scribe-do7.4","title":"Register AutoLinkNode in EditorRoot nodes array","description":"## Purpose\nRegister `AutoLinkNode` in the Lexical editor configuration so the editor can properly serialize/deserialize auto-detected links.\n\n## Why This Is Required\nLexical requires all node types to be registered in the editor config. Without registering AutoLinkNode:\n- AutoLinkPlugin won't work (it needs the node type)\n- Existing AutoLinkNodes in saved content won't load\n- Console errors about unknown node type\n\n## Implementation\n```typescript\n// Add import at top of EditorRoot.tsx\nimport { AutoLinkNode } from '@lexical/link';\n\n// In editorConfig.nodes array (around line 102-117)\nnodes: [\n  HeadingNode,\n  QuoteNode,\n  ListNode,\n  ListItemNode,\n  CodeNode,\n  CodeHighlightNode,\n  LinkNode,\n  AutoLinkNode,  // ‚Üê ADD THIS (after LinkNode, before HorizontalRuleNode)\n  HorizontalRuleNode,\n  WikiLinkNode,\n  PersonMentionNode,\n  TableNode,\n  TableRowNode,\n  TableCellNode,\n  MarkNode,\n],\n```\n\n## Package Already Installed\n`AutoLinkNode` is exported from `@lexical/link` which is already at v0.38.2 in package.json.\n\n## No New Dependencies\nThis just uses the existing `@lexical/link` package that already provides `LinkNode`.\n\n## Related Work\n- scribe-do7.5 creates the plugin that uses this node\n- scribe-do7.6 adds the plugin to the editor\n\n## Location\napps/desktop/renderer/src/components/Editor/EditorRoot.tsx, lines 13 and 102-117","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-22T19:35:32.97036-06:00","updated_at":"2025-12-22T19:36:17.8763-06:00","dependencies":[{"issue_id":"scribe-do7.4","depends_on_id":"scribe-do7","type":"parent-child","created_at":"2025-12-22T19:35:32.970678-06:00","created_by":"daemon"}]}
{"id":"scribe-do7.5","title":"Create AutoLinkPlugin wrapper with URL regex matcher","description":"## Purpose\nCreate a wrapper component for Lexical's AutoLinkPlugin that configures URL pattern matching. This enables automatic conversion of typed/pasted URLs into clickable links.\n\n## Why Create a Wrapper\n1. Keeps EditorRoot clean (no long regex constants)\n2. Encapsulates URL matching configuration\n3. Easy to extend later (add email pattern, etc.)\n4. Follows existing plugin organization pattern\n\n## New File: AutoLinkPlugin.tsx\n```typescript\n/**\n * AutoLinkPlugin wrapper\n *\n * Configures Lexical's AutoLinkPlugin with URL matchers for automatic\n * detection and conversion of typed/pasted URLs into clickable links.\n *\n * How it works:\n * - Plugin uses registerNodeTransform to watch text changes\n * - When text matches URL_REGEX, it's wrapped in AutoLinkNode\n * - Only matches http:// and https:// URLs (not mailto:, ftp:, etc.)\n *\n * Why not match other protocols:\n * - mailto: could be added but requires different UX (open email client)\n * - ftp://, file:// have security implications\n * - We want predictable, safe behavior\n */\n\nimport {\n  AutoLinkPlugin as LexicalAutoLinkPlugin,\n  createLinkMatcherWithRegExp,\n} from '@lexical/react/LexicalAutoLinkPlugin';\n\n// Regex for matching URLs (http:// and https://)\n// Adapted from Lexical playground examples\nconst URL_REGEX =\n  /https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?\u0026/=]*)/;\n\n// Optional: Email regex for future enhancement\n// const EMAIL_REGEX = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}/;\n\nconst MATCHERS = [\n  createLinkMatcherWithRegExp(URL_REGEX, (text) =\u003e text),\n  // Uncomment to enable email auto-linking:\n  // createLinkMatcherWithRegExp(EMAIL_REGEX, (email) =\u003e `mailto:${email}`),\n];\n\nexport function AutoLinkPlugin(): JSX.Element | null {\n  return \u003cLexicalAutoLinkPlugin matchers={MATCHERS} /\u003e;\n}\n```\n\n## URL Regex Explanation\n- `https?://` - Match http:// or https://\n- `(www\\.)?` - Optional www. prefix\n- `[-a-zA-Z0-9@:%._+~#=]{1,256}` - Domain characters (1-256 chars)\n- `\\.[a-zA-Z0-9()]{1,6}` - TLD like .com, .org, .io\n- `\\b` - Word boundary\n- `([-a-zA-Z0-9()@:%_+.~#?\u0026/=]*)` - Path, query, fragment\n\n## Packages Used (Already Installed)\n- `@lexical/react` v0.38.2 - provides AutoLinkPlugin, createLinkMatcherWithRegExp\n\n## Location\napps/desktop/renderer/src/components/Editor/plugins/AutoLinkPlugin.tsx (NEW FILE)\n\n## Depends On\n- scribe-do7.4 (AutoLinkNode must be registered first)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-22T19:35:33.039586-06:00","updated_at":"2025-12-22T19:36:37.226047-06:00","dependencies":[{"issue_id":"scribe-do7.5","depends_on_id":"scribe-do7","type":"parent-child","created_at":"2025-12-22T19:35:33.039895-06:00","created_by":"daemon"},{"issue_id":"scribe-do7.5","depends_on_id":"scribe-do7.4","type":"blocks","created_at":"2025-12-22T19:39:19.840118-06:00","created_by":"daemon"}]}
{"id":"scribe-do7.6","title":"Add AutoLinkPlugin to EditorRoot plugin composition","description":"## Purpose\nAdd the AutoLinkPlugin to the EditorRoot component so it's active during editing.\n\n## Implementation\n```typescript\n// Add import at top of EditorRoot.tsx\nimport { AutoLinkPlugin } from './plugins/AutoLinkPlugin';\n\n// Add plugin in JSX (after LinkClickPlugin, around line 174)\n\u003cLinkClickPlugin /\u003e\n\u003cAutoLinkPlugin /\u003e  // ‚Üê ADD THIS\n\u003cFocusNodePlugin /\u003e\n```\n\n## Plugin Ordering Rationale\nPlace AutoLinkPlugin after LinkClickPlugin because:\n1. LinkClickPlugin handles clicks on existing links\n2. AutoLinkPlugin transforms new text into links\n3. No dependency between them, but logical grouping (link-related plugins together)\n\n## How It Works at Runtime\n1. User types \"Check out https://example.com\"\n2. AutoLinkPlugin's transform sees \"https://example.com\" match URL_REGEX\n3. Text is converted to AutoLinkNode\n4. LinkClickPlugin will handle clicks on the new link\n5. ReferencesWidget will extract it (thanks to scribe-do7.3)\n\n## Undo/Redo Support\nLexical's HistoryPlugin automatically captures AutoLinkPlugin transforms. Users can undo URL detection if unwanted.\n\n## Performance Note\nAutoLinkPlugin uses registerNodeTransform which runs on text node changes. This is efficient for typical note sizes. No debouncing needed.\n\n## Depends On\n- scribe-do7.4 (AutoLinkNode registered)\n- scribe-do7.5 (AutoLinkPlugin wrapper created)\n\n## Location\napps/desktop/renderer/src/components/Editor/EditorRoot.tsx, lines 28 and 174","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-22T19:35:33.108859-06:00","updated_at":"2025-12-22T19:36:47.107015-06:00","dependencies":[{"issue_id":"scribe-do7.6","depends_on_id":"scribe-do7","type":"parent-child","created_at":"2025-12-22T19:35:33.109169-06:00","created_by":"daemon"},{"issue_id":"scribe-do7.6","depends_on_id":"scribe-do7.4","type":"blocks","created_at":"2025-12-22T19:39:19.891249-06:00","created_by":"daemon"},{"issue_id":"scribe-do7.6","depends_on_id":"scribe-do7.5","type":"blocks","created_at":"2025-12-22T19:39:19.942645-06:00","created_by":"daemon"}]}
{"id":"scribe-do7.7","title":"Add collapse/expand state and constants to ReferencesWidget","description":"## Purpose\nAdd React state and constants for collapse/expand functionality, matching the existing TasksWidget pattern.\n\n## Why Match TasksWidget Pattern\n1. **Consistency**: Same UX across all context panel widgets\n2. **Proven pattern**: Already works well for tasks\n3. **Reusable styles**: expandButton style already exists\n4. **Accessibility**: Same aria-* patterns\n\n## Implementation\nAdd to ReferencesWidget.tsx:\n\n```typescript\n// At top of file, update imports (line 9)\nimport { useState, useMemo, useCallback } from 'react';\nimport { ExternalLinkIcon, LinkIcon, ChevronDownIcon, ChevronUpIcon } from '@scribe/design-system';\n\n// Add constants after imports (around line 16)\n/** Number of references to show in collapsed state */\nconst COLLAPSED_LIMIT = 5;\n/** Maximum number of references to show in expanded state */\nconst EXPANDED_LIMIT = 15;\n\n// Inside ReferencesWidget function, add state and memos:\nexport function ReferencesWidget({ note, onNavigate }: ReferencesWidgetProps) {\n  const [isExpanded, setIsExpanded] = useState(false);\n\n  const references = useMemo(() =\u003e extractReferences(note.content), [note.content]);\n\n  // Determine which references to display based on expanded state\n  const visibleReferences = useMemo(() =\u003e {\n    const limit = isExpanded ? EXPANDED_LIMIT : COLLAPSED_LIMIT;\n    return references.slice(0, limit);\n  }, [references, isExpanded]);\n\n  // Show expand button if there are more than COLLAPSED_LIMIT references\n  const showExpandButton = references.length \u003e COLLAPSED_LIMIT;\n\n  // Calculate remaining references count for the button label\n  const remainingCount = Math.min(\n    references.length - COLLAPSED_LIMIT,\n    EXPANDED_LIMIT - COLLAPSED_LIMIT\n  );\n\n  const handleExpandToggle = useCallback(() =\u003e {\n    setIsExpanded((prev) =\u003e !prev);\n  }, []);\n\n  // ... rest of component\n}\n```\n\n## Why 5/15 Limits\n- **5 collapsed**: Matches TasksWidget, fits typical viewport without scrolling\n- **15 expanded**: Shows plenty of references without overwhelming, with scroll\n- **Math.min for remainingCount**: Caps button text at actual showable count\n\n## Depends On\n- Nothing (can be done in parallel with other subtasks)\n\n## Location\napps/desktop/renderer/src/components/ContextPanel/ReferencesWidget.tsx","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-22T19:35:33.177989-06:00","updated_at":"2025-12-22T19:37:01.867502-06:00","dependencies":[{"issue_id":"scribe-do7.7","depends_on_id":"scribe-do7","type":"parent-child","created_at":"2025-12-22T19:35:33.178283-06:00","created_by":"daemon"}]}
{"id":"scribe-do7.8","title":"Add expand button UI with ChevronDown/Up icons","description":"## Purpose\nUpdate the JSX render to use `visibleReferences` instead of `references` and add the expand/collapse button with proper icons and accessibility.\n\n## Implementation\nReplace the render section (starting around line 104):\n\n```typescript\nreturn (\n  \u003cdiv className={styles.card}\u003e\n    \u003cdiv className={styles.cardHeader}\u003e\n      \u003cLinkIcon size={14} className={clsx(styles.cardIcon, styles.cardIconTertiary)} /\u003e\n      \u003cspan className={styles.cardTitle}\u003eReferences\u003c/span\u003e\n    \u003c/div\u003e\n\n    {references.length === 0 ? (\n      \u003cdiv className={styles.emptyState}\u003eNo references\u003c/div\u003e\n    ) : (\n      \u003c\u003e\n        \u003cdiv className={isExpanded ? styles.referenceListScrollable : undefined}\u003e\n          \u003cdiv className={styles.list}\u003e\n            {visibleReferences.map((ref, index) =\u003e (\n              \u003cbutton\n                key={`${ref.type}-${ref.targetId || ref.url}-${index}`}\n                className={styles.referenceItem}\n                onClick={() =\u003e handleClick(ref)}\n                type=\"button\"\n              \u003e\n                {ref.type === 'url' \u0026\u0026 (\n                  \u003cspan className={styles.urlIcon}\u003e\n                    \u003cExternalLinkIcon size={12} /\u003e\n                  \u003c/span\u003e\n                )}\n                \u003cspan className={styles.referenceText}\u003e{ref.displayText}\u003c/span\u003e\n              \u003c/button\u003e\n            ))}\n          \u003c/div\u003e\n        \u003c/div\u003e\n        {showExpandButton \u0026\u0026 (\n          \u003cbutton\n            type=\"button\"\n            className={styles.expandButton}\n            onClick={handleExpandToggle}\n            aria-expanded={isExpanded}\n            aria-label={isExpanded ? 'Show fewer references' : `Show ${remainingCount} more references`}\n          \u003e\n            {isExpanded ? (\n              \u003c\u003e\n                \u003cChevronUpIcon size={12} /\u003e\n                Show less\n              \u003c/\u003e\n            ) : (\n              \u003c\u003e\n                \u003cChevronDownIcon size={12} /\u003e\n                Show {remainingCount} more\n              \u003c/\u003e\n            )}\n          \u003c/button\u003e\n        )}\n      \u003c/\u003e\n    )}\n  \u003c/div\u003e\n);\n```\n\n## Key Changes from Current Code\n1. Use `visibleReferences` instead of `references` in map\n2. Wrap list in conditional scrollable container\n3. Add expand button after list (same as TasksWidget)\n4. Import expandButton from ContextPanel.css (shared style)\n\n## Style Import Update\nNeed to import `expandButton` from ContextPanel.css.ts:\n```typescript\nimport * as styles from './ReferencesWidget.css';\nimport { expandButton } from './ContextPanel.css';\n// OR add referenceListScrollable to ReferencesWidget.css.ts (see scribe-do7.9)\n```\n\n## Accessibility\n- `aria-expanded`: Tells screen readers current state\n- `aria-label`: Describes action (\"Show X more references\")\n- Button semantics for keyboard navigation\n\n## Depends On\n- scribe-do7.7 (state and constants)\n- scribe-do7.9 (scrollable style)\n\n## Location\napps/desktop/renderer/src/components/ContextPanel/ReferencesWidget.tsx, lines 104-133","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-22T19:35:33.245927-06:00","updated_at":"2025-12-22T19:37:17.166595-06:00","dependencies":[{"issue_id":"scribe-do7.8","depends_on_id":"scribe-do7","type":"parent-child","created_at":"2025-12-22T19:35:33.246255-06:00","created_by":"daemon"},{"issue_id":"scribe-do7.8","depends_on_id":"scribe-do7.7","type":"blocks","created_at":"2025-12-22T19:39:19.993306-06:00","created_by":"daemon"},{"issue_id":"scribe-do7.8","depends_on_id":"scribe-do7.9","type":"blocks","created_at":"2025-12-22T19:39:20.042699-06:00","created_by":"daemon"}]}
{"id":"scribe-do7.9","title":"Add referenceListScrollable style to ReferencesWidget.css.ts","description":"## Purpose\nAdd styles for the scrollable reference list container (expanded state) and export the shared expandButton style.\n\n## Why Add to ReferencesWidget.css.ts\n1. Follows pattern of each widget having its own CSS file\n2. Avoids touching shared ContextPanel.css.ts\n3. Can import shared styles as needed\n\n## Implementation\nAdd to ReferencesWidget.css.ts:\n\n```typescript\nimport { style } from '@vanilla-extract/css';\nimport { vars, emptyStateInline } from '@scribe/design-system';\nimport { widgetCard, widgetCardHeader, widgetCardIcon, widgetCardTitle } from './shared.css';\n\n// ... existing styles ...\n\n/**\n * Scrollable reference list container for expanded state\n * Max height allows for ~15 reference items with scroll\n * Matches taskListScrollable from ContextPanel.css.ts\n */\nexport const referenceListScrollable = style({\n  maxHeight: '400px',\n  overflowY: 'auto',\n  overflowX: 'hidden',\n  marginRight: `calc(-1 * ${vars.spacing['2']})`,\n  paddingRight: vars.spacing['2'],\n\n  // Custom scrollbar styling\n  '::-webkit-scrollbar': {\n    width: '4px',\n  },\n  '::-webkit-scrollbar-track': {\n    background: 'transparent',\n  },\n  '::-webkit-scrollbar-thumb': {\n    backgroundColor: vars.color.border,\n    borderRadius: vars.radius.full,\n  },\n  selectors: {\n    '\u0026::-webkit-scrollbar-thumb:hover': {\n      backgroundColor: vars.color.foregroundMuted,\n    },\n  },\n});\n\n/**\n * Re-export expandButton from ContextPanel for use in ReferencesWidget\n * This maintains consistency with TasksWidget and LinkedMentions\n */\nexport { expandButton } from './ContextPanel.css';\n```\n\n## Style Details\n- **maxHeight: 400px**: Fits ~15 items (each ~26px with spacing)\n- **Negative margin + padding**: Prevents scrollbar from overlapping content\n- **Thin scrollbar (4px)**: Subtle, doesn't take visual space\n- **Hover state**: Slightly darker thumb on hover for feedback\n\n## Alternative: Import Directly\nCould also have ReferencesWidget.tsx import from ContextPanel.css.ts directly:\n```typescript\nimport { expandButton } from './ContextPanel.css';\n```\nThis avoids re-export but mixes imports. Chose re-export for cleaner imports in component.\n\n## Location\napps/desktop/renderer/src/components/ContextPanel/ReferencesWidget.css.ts","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-22T19:35:33.314857-06:00","updated_at":"2025-12-22T19:37:31.50126-06:00","dependencies":[{"issue_id":"scribe-do7.9","depends_on_id":"scribe-do7","type":"parent-child","created_at":"2025-12-22T19:35:33.315231-06:00","created_by":"daemon"}]}
{"id":"scribe-in3","title":"Collapsible Headings (GH-45)","description":"## Overview\n\nImplement collapsible/expandable sections in the Scribe editor, allowing users to fold content under headings. This is a highly-requested UX feature that improves navigation and focus in long documents.\n\n## Strategic Context\n\n**Why this matters for Scribe:**\n- Long-form note-taking is a core use case; users often have extensive meeting notes, documentation, or research notes\n- Collapsible sections reduce cognitive load by hiding irrelevant content while working\n- This is table-stakes for modern note-taking apps (Notion, Obsidian, Roam all have this)\n- Enables users to create \"executive summary\" views of their notes by collapsing detail sections\n\n## Technical Approach: Decorator-based Fold Controls + CSS Visibility\n\nAfter analysis, we chose this approach over alternatives because:\n\n1. **Preserves document semantics**: The heading hierarchy remains intact in the Lexical tree\n2. **Non-destructive**: Content is only visually hidden, not removed from the document\n3. **Markdown compatibility**: Export works identically to regular headings (collapsed state is view-only)\n4. **Extends existing patterns**: Similar to how WikiLinkNode and PersonMentionNode work in this codebase\n\n## Section Boundary Rules\n\nA \"section\" is defined as:\n- **Start**: The heading node itself\n- **End**: The next heading of **equal or higher level** (h1 ‚â• h2 ‚â• h3...), OR end of document\n\nThis is the standard outliner model used by Obsidian, Notion, and other tools.\n\n## Task Structure (Revised)\n\nThe epic has been consolidated from 16 over-fragmented tasks to 7 actionable tasks:\n\n| Task | Priority | Description |\n|------|----------|-------------|\n| scribe-in3.17 | P0 | Create CollapsibleHeadingNode with serialization |\n| scribe-in3.18 | P0 | Add fold icon and collapsed content CSS styles |\n| scribe-in3.19 | P1 | Implement CollapsibleHeadingPlugin with FoldIcon |\n| scribe-in3.20 | P1 | Register node and plugin in EditorRoot |\n| scribe-in3.21 | P1 | Unit tests for CollapsibleHeadingNode |\n| scribe-in3.22 | P2 | Integration tests for CollapsibleHeadingPlugin |\n| scribe-in3.23 | P2 | Handle migration of existing HeadingNode content |\n\n**Dependency Graph:**\n```\nscribe-in3.17 (node) ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ\u003e scribe-in3.19 (plugin) ‚îÄ‚îÄ\u003e scribe-in3.20 (integration) ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ\u003e scribe-in3.22 (int tests)\n                       ‚îÇ                                                              ‚îî‚îÄ‚îÄ\u003e scribe-in3.23 (migration)\nscribe-in3.18 (CSS) ‚îÄ‚îÄ‚îÄ‚îò\n                       \nscribe-in3.17 (node) ‚îÄ‚îÄ\u003e scribe-in3.21 (unit tests)  [can run parallel with plugin work]\n```\n\n**Parallelization opportunities:**\n- scribe-in3.17 and scribe-in3.18 can be done in parallel (no deps)\n- scribe-in3.21 can be done in parallel with scribe-in3.19/20 (only needs the node)\n- scribe-in3.22 and scribe-in3.23 can be done in parallel (both depend only on integration)\n\n## Acceptance Criteria\n\n- [ ] Hovering over any heading shows a fold/expand icon to the left\n- [ ] Clicking the icon collapses content until next same-or-higher-level heading\n- [ ] Collapsed sections show a visual indicator (e.g., \"...\" or chevron)\n- [ ] Collapse state persists when note is saved and reopened\n- [ ] Markdown export includes all content regardless of collapse state\n- [ ] Works with all heading levels (h1-h6)\n- [ ] Fold icons are keyboard accessible\n- [ ] Fold icons have appropriate ARIA attributes\n- [ ] Touch devices show always-visible fold icons\n- [ ] Existing notes with HeadingNode content migrate seamlessly\n\n## References\n\n- GitHub Issue: #45\n- Similar implementations: Obsidian folding, Notion toggle headings, VS Code editor folding","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-22T19:12:43.884345-06:00","updated_at":"2025-12-22T19:25:14.550607-06:00"}
{"id":"scribe-in3.1","title":"Create CollapsibleHeadingNode class extending HeadingNode","description":"## Purpose\n\nCreate a custom Lexical node that extends `HeadingNode` from `@lexical/rich-text` to add collapse state tracking. This is the foundational data model for the entire feature.\n\n## Why extend HeadingNode (not DecoratorNode)?\n\nLooking at the existing codebase patterns:\n- `WikiLinkNode` extends `DecoratorNode` because it needs custom React rendering\n- `PersonMentionNode` extends `DecoratorNode` for the same reason\n\nHowever, `CollapsibleHeadingNode` should extend `HeadingNode` because:\n1. We want to preserve ALL heading semantics (level, markdown shortcuts, etc.)\n2. Headings are block-level elements, not inline decorators\n3. We only need to ADD a collapse state, not change how the heading renders its content\n4. The fold icon will be rendered by the plugin via a portal, not by the node's `decorate()` method\n\n## Implementation Details\n\n```typescript\n// Key properties to add:\n__collapsed: boolean;  // Track whether this section is collapsed\n\n// Key methods to implement:\nconstructor(tag: HeadingTagType, collapsed: boolean = false, key?: NodeKey)\nstatic getType(): string  // Return 'collapsible-heading'\nstatic clone(node: CollapsibleHeadingNode): CollapsibleHeadingNode\ncreateDOM(config: EditorConfig): HTMLElement  // Add data-collapsed attribute\nupdateDOM(prevNode, dom, config): boolean  // Update data-collapsed on change\nisCollapsed(): boolean  // Getter for current state\nsetCollapsed(collapsed: boolean): void  // Setter (uses getWritable())\ntoggleCollapsed(): void  // Convenience method\n```\n\n## DOM Output\n\nThe `createDOM` should:\n1. Call `super.createDOM(config)` to get the standard heading element (h1-h6)\n2. Add `data-collapsed=\"true/false\"` attribute for CSS targeting\n3. Add `collapsible-heading` class for styling hooks\n\n## Files to Create\n\n- `apps/desktop/renderer/src/components/Editor/plugins/CollapsibleHeadingNode.ts`\n\n## Factory Functions\n\nFollowing the codebase pattern (see WikiLinkNode.ts lines 159-175):\n- `$createCollapsibleHeadingNode(tag: HeadingTagType): CollapsibleHeadingNode`\n- `$isCollapsibleHeadingNode(node): node is CollapsibleHeadingNode`\n\n## Edge Cases\n\n- Default collapsed state should be `false` (expanded)\n- Must handle all heading levels: h1, h2, h3, h4, h5, h6\n- Clone must preserve collapsed state\n\n## Dependencies\n\nNone - this is a foundational task","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-22T19:12:43.96818-06:00","updated_at":"2025-12-22T19:21:42.521556-06:00","closed_at":"2025-12-22T19:21:42.521556-06:00","dependencies":[{"issue_id":"scribe-in3.1","depends_on_id":"scribe-in3","type":"parent-child","created_at":"2025-12-22T19:12:43.968533-06:00","created_by":"daemon"}]}
{"id":"scribe-in3.10","title":"Add CollapsibleHeadingPlugin to EditorRoot component","description":"## Purpose\n\nAdd the `CollapsibleHeadingPlugin` component to the EditorRoot, activating the collapsible heading functionality.\n\n## Current Plugin List (EditorRoot.tsx lines 150-178)\n\n```typescript\n\u003cHistoryPlugin /\u003e\n\u003cListPlugin /\u003e\n\u003cCheckListPlugin /\u003e\n\u003cCheckListShortcutPlugin /\u003e\n\u003cTabIndentationPlugin /\u003e\n\u003cMarkdownShortcutPlugin transformers={EDITOR_TRANSFORMERS} /\u003e\n\u003cHorizontalRulePlugin /\u003e\n\u003cTablePlugin /\u003e\n\u003cTableKeyboardPlugin /\u003e\n\u003cTableUIPlugin /\u003e\n\u003cTableContentPlugin /\u003e\n\u003cInitialStatePlugin ... /\u003e\n\u003cAutosavePlugin ... /\u003e\n\u003cManualSavePlugin ... /\u003e\n\u003cWikiLinkPlugin ... /\u003e\n\u003cPersonMentionPlugin ... /\u003e\n\u003cLinkClickPlugin /\u003e\n\u003cFocusNodePlugin /\u003e\n\u003cSelectionToolbarPlugin /\u003e\n\u003cSlashMenuPlugin /\u003e\n```\n\n## Required Changes\n\n```typescript\n// Add import at top:\nimport { CollapsibleHeadingPlugin } from './plugins/CollapsibleHeadingPlugin';\n\n// Add plugin BEFORE MarkdownShortcutPlugin:\n\u003cCollapsibleHeadingPlugin /\u003e\n\u003cMarkdownShortcutPlugin transformers={EDITOR_TRANSFORMERS} /\u003e\n```\n\n## Plugin Ordering Consideration\n\nThe CollapsibleHeadingPlugin should be added **before** MarkdownShortcutPlugin because:\n1. We want the node transform to be registered before markdown shortcuts run\n2. This ensures `# ` shortcuts immediately produce CollapsibleHeadingNode\n3. Order matters for Lexical transforms - earlier registration = earlier execution\n\n## No Props Required\n\nUnlike `WikiLinkPlugin` which needs `currentNoteId`, the CollapsibleHeadingPlugin doesn't need any props:\n- It reads collapse state from the nodes themselves\n- It doesn't need context about the current note\n\n## Files to Modify\n\n- `apps/desktop/renderer/src/components/Editor/EditorRoot.tsx`\n\n## Dependencies\n\n- Requires scribe-in3.4 through scribe-in3.7 (plugin must be fully implemented)\n- Requires scribe-in3.9 (node must be registered)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T19:12:44.696159-06:00","updated_at":"2025-12-22T19:21:44.460479-06:00","closed_at":"2025-12-22T19:21:44.460479-06:00","dependencies":[{"issue_id":"scribe-in3.10","depends_on_id":"scribe-in3","type":"parent-child","created_at":"2025-12-22T19:12:44.696507-06:00","created_by":"daemon"},{"issue_id":"scribe-in3.10","depends_on_id":"scribe-in3.9","type":"blocks","created_at":"2025-12-22T19:16:43.831755-06:00","created_by":"daemon"},{"issue_id":"scribe-in3.10","depends_on_id":"scribe-in3.7","type":"blocks","created_at":"2025-12-22T19:16:43.890588-06:00","created_by":"daemon"}]}
{"id":"scribe-in3.11","title":"Update SlashMenu commands.ts to use $createCollapsibleHeadingNode","description":"## Purpose\n\nUpdate the SlashMenu heading commands to create `CollapsibleHeadingNode` instead of regular `HeadingNode`. This ensures headings created via slash commands are immediately collapsible.\n\n## Current Implementation (commands.ts lines 44-88)\n\n```typescript\n{\n  id: 'heading1',\n  label: 'Heading 1',\n  description: 'Big section heading',\n  keywords: ['heading', 'h1', 'title', '#', 'large'],\n  section: 'formatting',\n  execute: (editor) =\u003e {\n    editor.update(() =\u003e {\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        $setBlocksType(selection, () =\u003e $createHeadingNode('h1'));  // ‚Üê Change this\n      }\n    });\n  },\n},\n// Similar for heading2 and heading3\n```\n\n## Required Changes\n\n```typescript\n// Update import:\n// FROM: import { $createHeadingNode, $createQuoteNode } from '@lexical/rich-text';\n// TO:\nimport { $createQuoteNode } from '@lexical/rich-text';\nimport { $createCollapsibleHeadingNode } from '../plugins/CollapsibleHeadingNode';\n\n// Update each heading command:\nexecute: (editor) =\u003e {\n  editor.update(() =\u003e {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      $setBlocksType(selection, () =\u003e $createCollapsibleHeadingNode('h1'));\n    }\n  });\n},\n```\n\n## Why This Matters\n\nWithout this change:\n1. User types `/heading1`\n2. SlashMenu creates a regular `HeadingNode`\n3. The plugin's transform converts it to `CollapsibleHeadingNode`\n4. Extra work + potential flicker\n\nWith this change:\n1. User types `/heading1`\n2. SlashMenu creates `CollapsibleHeadingNode` directly\n3. No transform needed, no flicker\n\n## Commands to Update\n\n- `heading1` (line 44)\n- `heading2` (line 59)\n- `heading3` (line 74)\n\n## Files to Modify\n\n- `apps/desktop/renderer/src/components/Editor/SlashMenu/commands.ts`\n\n## Test Updates\n\nThe test file `commands.test.ts` may need updates if it:\n- Verifies the node type created\n- Imports `$createHeadingNode` for testing\n\n## Dependencies\n\n- Requires scribe-in3.1 and scribe-in3.2 (node must be implemented)\n- Can be done in parallel with scribe-in3.12","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T19:12:44.777179-06:00","updated_at":"2025-12-22T19:21:44.460952-06:00","closed_at":"2025-12-22T19:21:44.460952-06:00","dependencies":[{"issue_id":"scribe-in3.11","depends_on_id":"scribe-in3","type":"parent-child","created_at":"2025-12-22T19:12:44.777559-06:00","created_by":"daemon"},{"issue_id":"scribe-in3.11","depends_on_id":"scribe-in3.2","type":"blocks","created_at":"2025-12-22T19:16:43.949251-06:00","created_by":"daemon"}]}
{"id":"scribe-in3.12","title":"Update SelectionToolbarPlugin.tsx to use $createCollapsibleHeadingNode","description":"## Purpose\n\nUpdate the SelectionToolbar's heading formatting to use `CollapsibleHeadingNode`. This ensures headings created via the floating toolbar are immediately collapsible.\n\n## Current Implementation (SelectionToolbarPlugin.tsx lines 283-312)\n\n```typescript\nconst formatHeading = useCallback(\n  (tag: HeadingTagType) =\u003e {\n    editor.update(() =\u003e {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) return;\n\n      const anchorNode = selection.anchor.getNode();\n      const element = $getNearestBlockElementAncestorOrThrow(anchorNode);\n\n      if ($isHeadingNode(element) \u0026\u0026 element.getTag() === tag) {\n        // Toggle off: convert to paragraph\n        const paragraph = $createParagraphNode();\n        element.getChildren().forEach((child) =\u003e {\n          paragraph.append(child);\n        });\n        element.replace(paragraph);\n        paragraph.select();\n      } else {\n        // Convert to heading\n        const heading = $createHeadingNode(tag);  // ‚Üê Change this\n        element.getChildren().forEach((child) =\u003e {\n          heading.append(child);\n        });\n        element.replace(heading);\n        heading.select();\n      }\n    });\n  },\n  [editor]\n);\n```\n\n## Required Changes\n\n```typescript\n// Update imports (line 21):\n// FROM:\nimport { $isHeadingNode, $createHeadingNode, HeadingTagType } from '@lexical/rich-text';\n\n// TO:\nimport { $isHeadingNode, HeadingTagType } from '@lexical/rich-text';\nimport { \n  $createCollapsibleHeadingNode, \n  $isCollapsibleHeadingNode \n} from '../plugins/CollapsibleHeadingNode';\n\n// Update formatHeading function:\nconst heading = $createCollapsibleHeadingNode(tag);\n```\n\n## Type Guard Update\n\nThe toggle logic uses `$isHeadingNode` to check if we're already on a heading:\n\n```typescript\nif ($isHeadingNode(element) \u0026\u0026 element.getTag() === tag) {\n```\n\nThis should still work because `CollapsibleHeadingNode` extends `HeadingNode`, so `$isHeadingNode` returns true. But for clarity and future-proofing, consider:\n\n```typescript\nif (($isHeadingNode(element) || $isCollapsibleHeadingNode(element)) \u0026\u0026 element.getTag() === tag) {\n```\n\n## activeFormats Update\n\nThe `updateActiveFormats` function (lines 107-157) checks for headings:\n\n```typescript\nif ($isHeadingNode(element)) {\n  const tag = element.getTag();\n  h1 = tag === 'h1';\n  h2 = tag === 'h2';\n}\n```\n\nThis should continue to work because `$isHeadingNode` returns true for our extended node.\n\n## Files to Modify\n\n- `apps/desktop/renderer/src/components/Editor/SelectionToolbar/SelectionToolbarPlugin.tsx`\n\n## Test Updates\n\nThe test file `SelectionToolbarPlugin.test.tsx` may need updates if it:\n- Verifies node types created\n- Tests heading detection logic\n\n## Dependencies\n\n- Requires scribe-in3.1 and scribe-in3.2 (node must be implemented)\n- Can be done in parallel with scribe-in3.11","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T19:12:44.859497-06:00","updated_at":"2025-12-22T19:21:44.461483-06:00","closed_at":"2025-12-22T19:21:44.461483-06:00","dependencies":[{"issue_id":"scribe-in3.12","depends_on_id":"scribe-in3","type":"parent-child","created_at":"2025-12-22T19:12:44.859836-06:00","created_by":"daemon"},{"issue_id":"scribe-in3.12","depends_on_id":"scribe-in3.2","type":"blocks","created_at":"2025-12-22T19:16:44.009511-06:00","created_by":"daemon"}]}
{"id":"scribe-in3.13","title":"Create integration tests for CollapsibleHeadingPlugin","description":"## Purpose\n\nCreate comprehensive integration tests for the CollapsibleHeadingPlugin to verify the full user experience works correctly. These tests use React Testing Library and simulate real user interactions.\n\n## Testing Approach\n\nFollowing the patterns in `WikiLinkPlugin.test.tsx`:\n- Create a `TestEditor` wrapper with full Lexical setup\n- Use `@testing-library/react` with `render()`, `waitFor()`, `act()`\n- Capture editor reference via helper component\n- Simulate user interactions and verify outcomes\n\n## Test Cases\n\n### Node Transform Tests\n```typescript\ndescribe('HeadingNode transform', () =\u003e {\n  it('converts HeadingNode to CollapsibleHeadingNode on markdown input', async () =\u003e {\n    // Type \"# \" and verify node type\n  });\n  \n  it('preserves heading content during transform', async () =\u003e {});\n  \n  it('transforms pasted headings', async () =\u003e {});\n});\n```\n\n### Fold Icon Tests\n```typescript\ndescribe('FoldIcon', () =\u003e {\n  it('appears on heading hover', async () =\u003e {});\n  it('shows correct icon based on collapsed state', async () =\u003e {});\n  it('disappears when mouse leaves heading', async () =\u003e {});\n  it('updates position on scroll', async () =\u003e {});\n});\n```\n\n### Collapse Behavior Tests\n```typescript\ndescribe('collapse behavior', () =\u003e {\n  it('hides content until next same-level heading on collapse', async () =\u003e {});\n  it('hides content until next higher-level heading on collapse', async () =\u003e {});\n  it('does not hide content after lower-level heading', async () =\u003e {});\n  it('handles nested heading collapse correctly', async () =\u003e {});\n  it('handles collapse at end of document', async () =\u003e {});\n});\n```\n\n### Persistence Tests\n```typescript\ndescribe('state persistence', () =\u003e {\n  it('preserves collapsed state on save/reload', async () =\u003e {});\n  it('applies collapsed state on initial load', async () =\u003e {});\n});\n```\n\n### Edge Cases\n```typescript\ndescribe('edge cases', () =\u003e {\n  it('handles multiple consecutive headings', async () =\u003e {});\n  it('handles empty sections (heading followed by heading)', async () =\u003e {});\n  it('handles copy/paste of collapsed sections', async () =\u003e {});\n  it('handles undo/redo of collapse operations', async () =\u003e {});\n});\n```\n\n## Test Utilities Needed\n\n```typescript\n// Helper to create editor with test content\nfunction createTestContent(markdown: string) {\n  // Parse markdown and create Lexical state\n}\n\n// Helper to find heading by level and index\nfunction findHeading(container: HTMLElement, level: number, index: number) {\n  return container.querySelectorAll(`h${level}`)[index];\n}\n\n// Helper to simulate hover\nfunction hoverHeading(heading: HTMLElement) {\n  fireEvent.mouseMove(heading);\n}\n\n// Helper to click fold icon\nfunction clickFoldIcon() {\n  const icon = document.querySelector('.fold-icon');\n  fireEvent.click(icon);\n}\n```\n\n## Files to Create\n\n- `apps/desktop/renderer/src/components/Editor/plugins/CollapsibleHeadingPlugin.test.tsx`\n\n## Dependencies\n\n- Requires all plugin implementation tasks to be complete (scribe-in3.4 through scribe-in3.10)\n- Requires scribe-in3.3 (unit tests should pass first)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-22T19:12:44.941344-06:00","updated_at":"2025-12-22T19:21:44.462104-06:00","closed_at":"2025-12-22T19:21:44.462104-06:00","dependencies":[{"issue_id":"scribe-in3.13","depends_on_id":"scribe-in3","type":"parent-child","created_at":"2025-12-22T19:12:44.941674-06:00","created_by":"daemon"},{"issue_id":"scribe-in3.13","depends_on_id":"scribe-in3.10","type":"blocks","created_at":"2025-12-22T19:16:44.067947-06:00","created_by":"daemon"},{"issue_id":"scribe-in3.13","depends_on_id":"scribe-in3.3","type":"blocks","created_at":"2025-12-22T19:16:44.125404-06:00","created_by":"daemon"}]}
{"id":"scribe-in3.14","title":"Add accessibility attributes (aria-label, aria-expanded) to fold icons","description":"## Purpose\n\nAdd proper ARIA attributes to fold icons for screen reader accessibility. Users with visual impairments should be able to understand and operate the collapse functionality.\n\n## Required ARIA Attributes\n\n### 1. aria-label (Descriptive Label)\n\n```typescript\n\u003cbutton\n  aria-label={collapsed ? 'Expand section' : 'Collapse section'}\n  // ...\n\u003e\n```\n\nProvides a clear description of what the button does.\n\n### 2. aria-expanded (State Indicator)\n\n```typescript\n\u003cbutton\n  aria-expanded={!collapsed}\n  // ...\n\u003e\n```\n\nIndicates the current state:\n- `aria-expanded=\"true\"` when section is visible (not collapsed)\n- `aria-expanded=\"false\"` when section is hidden (collapsed)\n\n### 3. aria-controls (Optional, Future Enhancement)\n\n```typescript\n\u003cbutton\n  aria-controls=\"section-content-id\"\n  // ...\n\u003e\n```\n\nReferences the controlled content. This requires generating stable IDs for section content, which may be complex with Lexical's dynamic DOM.\n\n## Implementation\n\n```typescript\nfunction FoldIcon({ collapsed, position, onToggle }: FoldIconProps) {\n  return createPortal(\n    \u003cbutton\n      className=\"fold-icon\"\n      style={{ top: position.top, left: position.left }}\n      onClick={onToggle}\n      aria-label={collapsed ? 'Expand section' : 'Collapse section'}\n      aria-expanded={!collapsed}\n      type=\"button\"\n    \u003e\n      {collapsed ? '‚ñ∂' : '‚ñº'}\n    \u003c/button\u003e,\n    document.body\n  );\n}\n```\n\n## Screen Reader Announcements (Future Enhancement)\n\nConsider adding live region announcements:\n```typescript\n// When collapse state changes, announce to screen readers\nconst [announcement, setAnnouncement] = useState('');\n\nuseEffect(() =\u003e {\n  if (collapsed) {\n    setAnnouncement('Section collapsed');\n  } else {\n    setAnnouncement('Section expanded');\n  }\n}, [collapsed]);\n\nreturn (\n  \u003c\u003e\n    \u003cdiv role=\"status\" aria-live=\"polite\" className=\"sr-only\"\u003e\n      {announcement}\n    \u003c/div\u003e\n    {/* ... fold icon */}\n  \u003c/\u003e\n);\n```\n\n## Testing Requirements\n\n- Verify aria-label changes based on state\n- Verify aria-expanded reflects correct state\n- Test with screen reader (VoiceOver, NVDA) to confirm announcements\n\n## Files to Modify\n\n- `apps/desktop/renderer/src/components/Editor/plugins/CollapsibleHeadingPlugin.tsx`\n\n## Dependencies\n\n- Requires scribe-in3.5 (FoldIcon component must exist)\n- Part of accessibility polish phase","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-22T19:12:45.023956-06:00","updated_at":"2025-12-22T19:21:44.462627-06:00","closed_at":"2025-12-22T19:21:44.462627-06:00","dependencies":[{"issue_id":"scribe-in3.14","depends_on_id":"scribe-in3","type":"parent-child","created_at":"2025-12-22T19:12:45.024333-06:00","created_by":"daemon"},{"issue_id":"scribe-in3.14","depends_on_id":"scribe-in3.5","type":"blocks","created_at":"2025-12-22T19:16:44.186506-06:00","created_by":"daemon"}]}
{"id":"scribe-in3.15","title":"Add keyboard support (Enter/Space) for fold icon activation","description":"## Purpose\n\nEnable keyboard-only users to operate the fold icons using Enter and Space keys. This is a WCAG requirement and essential for accessibility.\n\n## Keyboard Behavior\n\n### Focus Navigation\n- Fold icons should be focusable with Tab key\n- Focus should be visible (already handled in styles via `:focus-visible`)\n\n### Activation Keys\n- **Enter**: Toggle collapse state\n- **Space**: Toggle collapse state\n\n## Implementation\n\n```typescript\nfunction FoldIcon({ collapsed, position, onToggle }: FoldIconProps) {\n  const handleKeyDown = (e: React.KeyboardEvent) =\u003e {\n    if (e.key === 'Enter' || e.key === ' ') {\n      e.preventDefault();  // Prevent scroll on Space\n      onToggle();\n    }\n  };\n\n  return createPortal(\n    \u003cbutton\n      className=\"fold-icon\"\n      style={{ top: position.top, left: position.left }}\n      onClick={onToggle}\n      onKeyDown={handleKeyDown}\n      aria-label={collapsed ? 'Expand section' : 'Collapse section'}\n      aria-expanded={!collapsed}\n      type=\"button\"\n      tabIndex={0}  // Ensure focusable\n    \u003e\n      {collapsed ? '‚ñ∂' : '‚ñº'}\n    \u003c/button\u003e,\n    document.body\n  );\n}\n```\n\n## Note on Button Element\n\nSince we're using a `\u003cbutton\u003e` element (not a `\u003cdiv\u003e` or `\u003cspan\u003e`), Enter and Space activation should work by default. However, explicit handling ensures:\n1. Consistent behavior across browsers\n2. Prevents default Space scroll behavior\n3. Makes behavior explicit and testable\n\n## Focus Management Considerations\n\nWhen using a portal:\n- The button is rendered in `document.body`, outside the editor\n- Tab order follows DOM order, so the fold icon may be tabbed to unexpectedly\n- Consider: Should fold icons be in tab order at all?\n\n### Alternative: Remove from Tab Order, Add Keyboard Shortcut\n\nSome implementations (like VS Code) don't make fold icons focusable. Instead:\n- Icons are visible on hover only\n- Keyboard users use shortcuts like `Cmd+Shift+[` to collapse\n\nThis is addressed in the future enhancement scope (keyboard shortcuts).\n\n## Testing Requirements\n\n- Tab to fold icon, verify focus visible\n- Press Enter, verify collapse toggles\n- Press Space, verify collapse toggles\n- Verify Space doesn't scroll the page\n\n## Files to Modify\n\n- `apps/desktop/renderer/src/components/Editor/plugins/CollapsibleHeadingPlugin.tsx`\n\n## Dependencies\n\n- Requires scribe-in3.5 (FoldIcon component must exist)\n- Part of accessibility polish phase\n- Related to scribe-in3.14 (ARIA attributes)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-22T19:12:45.108059-06:00","updated_at":"2025-12-22T19:21:44.463163-06:00","closed_at":"2025-12-22T19:21:44.463163-06:00","dependencies":[{"issue_id":"scribe-in3.15","depends_on_id":"scribe-in3","type":"parent-child","created_at":"2025-12-22T19:12:45.108494-06:00","created_by":"daemon"},{"issue_id":"scribe-in3.15","depends_on_id":"scribe-in3.5","type":"blocks","created_at":"2025-12-22T19:16:44.247034-06:00","created_by":"daemon"}]}
{"id":"scribe-in3.16","title":"Implement touch device support (always-visible fold icons)","description":"## Purpose\n\nMake fold icons work on touch devices (iPad, mobile) where hover interactions don't exist. Touch users need a way to discover and activate the collapse functionality.\n\n## The Problem\n\nCurrent implementation shows fold icons on hover. On touch devices:\n- There is no hover state\n- First tap is treated as hover, second tap as click (non-intuitive)\n- Users may never discover the feature\n\n## Solution: Always-Visible Fold Icons on Touch\n\nUse CSS media queries to detect touch capability and always show icons:\n\n```typescript\n// In EditorRoot.css.ts\n\n// Fold icon base - hidden by default (desktop)\nexport const foldIcon = style({\n  // ... existing styles\n  opacity: 0,\n  transition: 'opacity 150ms ease',\n  '@media': {\n    // Always visible on touch devices\n    '(hover: none) and (pointer: coarse)': {\n      opacity: 1,\n    },\n  },\n});\n\n// Visible on hover (desktop only)\nexport const foldIconVisible = style({\n  '@media': {\n    '(hover: hover)': {\n      opacity: 1,\n    },\n  },\n});\n```\n\n## Media Query Explanation\n\n- `(hover: none)`: Device doesn't support hover\n- `(pointer: coarse)`: Device has imprecise pointer (touch)\n- Combined: Targets touch devices\n\n## Alternative Approaches Considered\n\n### 1. Tap-and-Hold Gesture\n- Pros: Clean interface, no always-visible icons\n- Cons: Not discoverable, conflicts with text selection\n\n### 2. Swipe Gesture on Heading\n- Pros: Could be intuitive\n- Cons: Conflicts with scrolling, hard to implement in Lexical\n\n### 3. Toolbar Button for \"Fold All\"\n- Pros: Single access point\n- Cons: Doesn't allow individual section control\n\n**Chosen: Always-visible icons** because:\n- Simple to implement\n- Consistent with desktop behavior\n- Doesn't require learning new gestures\n\n## Touch Considerations\n\n### Icon Size\nTouch targets should be at least 44x44 pixels (Apple HIG):\n```typescript\n'@media': {\n  '(hover: none) and (pointer: coarse)': {\n    width: '44px',\n    height: '44px',\n    // Adjust position to center on heading\n  },\n}\n```\n\n### Icon Position\nMay need adjustment on narrow mobile screens to avoid overlapping with heading text.\n\n## Plugin Updates\n\nThe plugin may need to:\n1. Detect touch capability\n2. Adjust positioning logic for always-visible icons\n3. Handle touch events (may already work with click events)\n\n## Files to Modify\n\n- `apps/desktop/renderer/src/components/Editor/EditorRoot.css.ts`\n- `apps/desktop/renderer/src/components/Editor/plugins/CollapsibleHeadingPlugin.tsx`\n\n## Dependencies\n\n- Requires scribe-in3.8 (base styles must exist)\n- Requires scribe-in3.5 (fold icon component must exist)\n- Lower priority - can be done after core functionality works","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-22T19:12:45.187597-06:00","updated_at":"2025-12-22T19:21:44.463699-06:00","closed_at":"2025-12-22T19:21:44.463699-06:00","dependencies":[{"issue_id":"scribe-in3.16","depends_on_id":"scribe-in3","type":"parent-child","created_at":"2025-12-22T19:12:45.188093-06:00","created_by":"daemon"},{"issue_id":"scribe-in3.16","depends_on_id":"scribe-in3.8","type":"blocks","created_at":"2025-12-22T19:16:44.306739-06:00","created_by":"daemon"},{"issue_id":"scribe-in3.16","depends_on_id":"scribe-in3.5","type":"blocks","created_at":"2025-12-22T19:16:44.364102-06:00","created_by":"daemon"}]}
{"id":"scribe-in3.17","title":"Create CollapsibleHeadingNode with serialization","description":"## Purpose\n\nCreate a complete, production-ready `CollapsibleHeadingNode` that extends `HeadingNode` from `@lexical/rich-text` with collapse state tracking and full JSON serialization.\n\n## Why One Task?\n\nThe node class and its serialization are inseparable:\n- You cannot meaningfully test a node without save/load capability\n- You cannot verify persistence without the complete implementation\n- These were previously split (scribe-in3.1 + scribe-in3.2) but that created artificial dependencies\n\n## Implementation\n\n### File to Create\n`apps/desktop/renderer/src/components/Editor/plugins/CollapsibleHeadingNode.ts`\n\n### Core Class Structure\n\n```typescript\nimport { HeadingNode, SerializedHeadingNode, HeadingTagType } from \"@lexical/rich-text\";\nimport { NodeKey, Spread, LexicalNode, EditorConfig } from \"lexical\";\n\ntype SerializedCollapsibleHeadingNode = Spread\u003c\n  { collapsed: boolean },\n  SerializedHeadingNode\n\u003e;\n\nexport class CollapsibleHeadingNode extends HeadingNode {\n  __collapsed: boolean;\n\n  static getType(): string {\n    return \"collapsible-heading\";\n  }\n\n  static clone(node: CollapsibleHeadingNode): CollapsibleHeadingNode {\n    return new CollapsibleHeadingNode(node.__tag, node.__collapsed, node.__key);\n  }\n\n  constructor(tag: HeadingTagType, collapsed: boolean = false, key?: NodeKey) {\n    super(tag, key);\n    this.__collapsed = collapsed;\n  }\n\n  // DOM creation with data attributes for CSS targeting\n  createDOM(config: EditorConfig): HTMLElement {\n    const dom = super.createDOM(config);\n    dom.setAttribute(\"data-collapsed\", String(this.__collapsed));\n    dom.classList.add(\"collapsible-heading\");\n    return dom;\n  }\n\n  updateDOM(prevNode: this, dom: HTMLElement, config: EditorConfig): boolean {\n    const updated = super.updateDOM(prevNode, dom, config);\n    if (prevNode.__collapsed !== this.__collapsed) {\n      dom.setAttribute(\"data-collapsed\", String(this.__collapsed));\n    }\n    return updated;\n  }\n\n  // State accessors\n  isCollapsed(): boolean {\n    return this.getLatest().__collapsed;\n  }\n\n  setCollapsed(collapsed: boolean): void {\n    const writable = this.getWritable();\n    writable.__collapsed = collapsed;\n  }\n\n  toggleCollapsed(): void {\n    this.setCollapsed(!this.isCollapsed());\n  }\n\n  // JSON serialization for persistence\n  exportJSON(): SerializedCollapsibleHeadingNode {\n    return {\n      ...super.exportJSON(),\n      type: \"collapsible-heading\",\n      collapsed: this.__collapsed,\n    };\n  }\n\n  static importJSON(json: SerializedCollapsibleHeadingNode): CollapsibleHeadingNode {\n    const node = $createCollapsibleHeadingNode(json.tag);\n    node.setCollapsed(json.collapsed);\n    return node;\n  }\n}\n\n// Factory functions following codebase patterns\nexport function $createCollapsibleHeadingNode(tag: HeadingTagType): CollapsibleHeadingNode {\n  return new CollapsibleHeadingNode(tag);\n}\n\nexport function $isCollapsibleHeadingNode(\n  node: LexicalNode | null | undefined\n): node is CollapsibleHeadingNode {\n  return node instanceof CollapsibleHeadingNode;\n}\n```\n\n## Key Design Decisions\n\n1. **Extend HeadingNode, not DecoratorNode**: Preserves all heading semantics (levels, markdown shortcuts)\n2. **Default collapsed=false**: New headings are expanded by default\n3. **data-collapsed attribute**: Enables CSS-based visibility control\n4. **collapsible-heading class**: Styling hook for fold icon positioning\n\n## Acceptance Criteria\n\n- [ ] Node can be created for all heading levels (h1-h6)\n- [ ] Collapsed state can be toggled via setCollapsed/toggleCollapsed\n- [ ] exportJSON includes collapsed state\n- [ ] importJSON restores collapsed state correctly\n- [ ] createDOM adds data-collapsed attribute and collapsible-heading class\n- [ ] updateDOM updates data-collapsed when state changes\n- [ ] clone preserves both tag and collapsed state\n\n## No Dependencies\n\nThis is a foundational task with no blockers.","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-22T19:22:19.149134-06:00","updated_at":"2025-12-22T19:30:24.705291-06:00","closed_at":"2025-12-22T19:30:24.705291-06:00","dependencies":[{"issue_id":"scribe-in3.17","depends_on_id":"scribe-in3","type":"parent-child","created_at":"2025-12-22T19:22:19.14955-06:00","created_by":"daemon"}]}
{"id":"scribe-in3.18","title":"Add fold icon and collapsed content CSS styles","description":"## Purpose\n\nAdd CSS styles for the fold icon and collapsed content visibility. These styles MUST exist before the plugin can function, making this a foundational task.\n\n## Why P0?\n\nThe plugin depends on these CSS classes:\n- `.fold-icon` - Styles the collapse/expand button\n- `.collapsed-content` - Hides content under collapsed headings\n- `.collapsible-heading` - Positions the heading for fold icon placement\n\nWithout these styles, the feature is non-functional even if the code is complete.\n\n## File to Modify\n`apps/desktop/renderer/src/components/Editor/EditorRoot.css.ts`\n\n## Styles to Add\n\n```typescript\nimport { style, globalStyle } from \"@vanilla-extract/css\";\nimport { vars } from \"@scribe/design-system\";\n\n// Fold icon - positioned via JS portal, hidden by default\nexport const foldIcon = style({\n  position: \"fixed\",\n  width: \"24px\",\n  height: \"24px\",\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  cursor: \"pointer\",\n  opacity: 0,\n  transition: \"opacity 150ms ease\",\n  color: vars.color.foregroundMuted,\n  border: \"none\",\n  background: \"transparent\",\n  padding: 0,\n  fontSize: \"12px\",\n  zIndex: 10,\n  \":hover\": {\n    color: vars.color.foreground,\n  },\n  \":focus-visible\": {\n    outline: `2px solid ${vars.color.accent}`,\n    outlineOffset: \"2px\",\n  },\n  // Touch device support: always visible\n  \"@media\": {\n    \"(hover: none) and (pointer: coarse)\": {\n      opacity: 1,\n      width: \"44px\",\n      height: \"44px\",\n    },\n  },\n});\n\n// Class to show fold icon (applied on heading hover)\nexport const foldIconVisible = style({\n  opacity: 1,\n});\n\n// Visual indicator on collapsed headings\nglobalStyle(\".collapsible-heading[data-collapsed=\\\"true\\\"]::after\", {\n  content: \"\\\"...\\\"\",\n  color: vars.color.foregroundMuted,\n  marginLeft: vars.spacing[\"2\"],\n  fontSize: \"0.8em\",\n});\n\n// Content hidden under collapsed headings\nglobalStyle(\".collapsed-content\", {\n  display: \"none\",\n});\n\n// Base styling for collapsible headings\nglobalStyle(\".collapsible-heading\", {\n  position: \"relative\",\n});\n```\n\n## Design Decisions\n\n1. **Touch support included**: The `@media (hover: none)` query makes icons always visible on touch devices, with larger 44px touch targets per Apple HIG\n2. **Fixed positioning**: Icons are rendered via portal and positioned with JS\n3. **Design token usage**: Uses `vars.color.*` and `vars.spacing.*` for consistency\n4. **Focus-visible**: Keyboard focus is clearly visible for accessibility\n\n## Acceptance Criteria\n\n- [ ] foldIcon style class exported\n- [ ] foldIconVisible style class exported\n- [ ] collapsed-content global style hides elements\n- [ ] collapsible-heading global style sets position: relative\n- [ ] Collapsed heading shows \"...\" indicator\n- [ ] Touch devices get larger, always-visible fold icons\n\n## No Dependencies\n\nThis is a foundational task with no blockers.","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-22T19:22:40.869357-06:00","updated_at":"2025-12-22T19:32:36.375672-06:00","closed_at":"2025-12-22T19:32:36.375672-06:00","dependencies":[{"issue_id":"scribe-in3.18","depends_on_id":"scribe-in3","type":"parent-child","created_at":"2025-12-22T19:22:40.869739-06:00","created_by":"daemon"}]}
{"id":"scribe-in3.19","title":"Implement CollapsibleHeadingPlugin with FoldIcon","description":"## Purpose\n\nCreate the complete Lexical plugin that provides collapsible heading functionality. This includes:\n- HeadingNode ‚Üí CollapsibleHeadingNode transform\n- FoldIcon component with hover positioning\n- TOGGLE_COLLAPSE_COMMAND handler\n- CSS class application for hiding collapsed sections\n- Full accessibility (ARIA attributes, keyboard support)\n\n## Why One Task?\n\nThese components are tightly coupled and exist in a single file. You cannot meaningfully test or verify any piece in isolation:\n- FoldIcon needs the command handler to work\n- Command handler needs updateCollapsedSections to have visible effect\n- Transform needs the node registered to function\n\nPreviously this was 6 separate tasks (scribe-in3.4-7, scribe-in3.14-15) which created unnecessary serialization.\n\n## File to Create\n`apps/desktop/renderer/src/components/Editor/plugins/CollapsibleHeadingPlugin.tsx`\n\n## Implementation\n\n### 1. HeadingNode Transform\n\n```typescript\nuseEffect(() =\u003e {\n  return editor.registerNodeTransform(HeadingNode, (node) =\u003e {\n    if (node.getType() === \"heading\") {\n      const collapsed = $createCollapsibleHeadingNode(node.getTag());\n      collapsed.append(...node.getChildren());\n      node.replace(collapsed);\n    }\n  });\n}, [editor]);\n```\n\n### 2. FoldIcon Component (with accessibility)\n\n```typescript\ninterface FoldIconProps {\n  collapsed: boolean;\n  position: { top: number; left: number };\n  onToggle: () =\u003e void;\n}\n\nfunction FoldIcon({ collapsed, position, onToggle }: FoldIconProps) {\n  const handleKeyDown = (e: React.KeyboardEvent) =\u003e {\n    if (e.key === \"Enter\" || e.key === \" \") {\n      e.preventDefault();\n      onToggle();\n    }\n  };\n\n  return createPortal(\n    \u003cbutton\n      className={foldIconVisible}  // From CSS\n      style={{ top: position.top, left: position.left }}\n      onClick={onToggle}\n      onKeyDown={handleKeyDown}\n      aria-label={collapsed ? \"Expand section\" : \"Collapse section\"}\n      aria-expanded={!collapsed}\n      type=\"button\"\n    \u003e\n      {collapsed ? \"‚ñ∂\" : \"‚ñº\"}\n    \u003c/button\u003e,\n    document.body\n  );\n}\n```\n\n### 3. Command Handler\n\n```typescript\nexport const TOGGLE_COLLAPSE_COMMAND: LexicalCommand\u003cstring\u003e = createCommand();\n\nuseEffect(() =\u003e {\n  return editor.registerCommand(\n    TOGGLE_COLLAPSE_COMMAND,\n    (nodeKey: string) =\u003e {\n      editor.update(() =\u003e {\n        const node = $getNodeByKey(nodeKey);\n        if ($isCollapsibleHeadingNode(node)) {\n          node.toggleCollapsed();\n          updateCollapsedSections();\n        }\n      });\n      return true;\n    },\n    COMMAND_PRIORITY_LOW\n  );\n}, [editor]);\n```\n\n### 4. Section Boundary Logic\n\n```typescript\nfunction updateCollapsedSections() {\n  editor.getEditorState().read(() =\u003e {\n    const root = $getRoot();\n    const children = root.getChildren();\n    let currentCollapsed: { level: number } | null = null;\n\n    children.forEach((child) =\u003e {\n      if ($isCollapsibleHeadingNode(child)) {\n        const level = parseInt(child.getTag().replace(\"h\", \"\"), 10);\n        \n        // End collapsed section if same or higher level heading\n        if (currentCollapsed \u0026\u0026 level \u003c= currentCollapsed.level) {\n          currentCollapsed = null;\n        }\n        \n        // Start collapsed section\n        if (child.isCollapsed()) {\n          currentCollapsed = { level };\n        }\n\n        // Headings are never hidden\n        editor.getElementByKey(child.getKey())?.classList.remove(\"collapsed-content\");\n      } else if (currentCollapsed) {\n        editor.getElementByKey(child.getKey())?.classList.add(\"collapsed-content\");\n      } else {\n        editor.getElementByKey(child.getKey())?.classList.remove(\"collapsed-content\");\n      }\n    });\n  });\n}\n```\n\n### 5. Hover Detection\n\n```typescript\nuseEffect(() =\u003e {\n  const rootElement = editor.getRootElement();\n  if (!rootElement) return;\n\n  const handleMouseMove = (e: MouseEvent) =\u003e {\n    const heading = (e.target as HTMLElement).closest(\".collapsible-heading\");\n    if (heading) {\n      const rect = heading.getBoundingClientRect();\n      // Resolve node key and set hoveredHeading state\n      // ...\n    } else {\n      setHoveredHeading(null);\n    }\n  };\n\n  rootElement.addEventListener(\"mousemove\", handleMouseMove);\n  return () =\u003e rootElement.removeEventListener(\"mousemove\", handleMouseMove);\n}, [editor]);\n```\n\n## Acceptance Criteria\n\n- [ ] HeadingNode instances are automatically transformed to CollapsibleHeadingNode\n- [ ] Fold icon appears on heading hover (desktop) or always (touch)\n- [ ] Clicking fold icon toggles collapse state\n- [ ] Enter/Space keys activate fold icon\n- [ ] Collapsed sections are hidden via CSS class\n- [ ] Section boundaries respect heading hierarchy (h1 \u003e h2 \u003e h3...)\n- [ ] aria-label and aria-expanded attributes are present and correct\n- [ ] Focus is visible on fold icon\n\n## Dependencies\n\n- Requires scribe-in3.17 (CollapsibleHeadingNode)\n- Requires scribe-in3.18 (CSS styles)","status":"in_progress","priority":1,"issue_type":"task","created_at":"2025-12-22T19:23:08.473585-06:00","updated_at":"2025-12-22T19:38:01.46087-06:00","dependencies":[{"issue_id":"scribe-in3.19","depends_on_id":"scribe-in3","type":"parent-child","created_at":"2025-12-22T19:23:08.473931-06:00","created_by":"daemon"},{"issue_id":"scribe-in3.19","depends_on_id":"scribe-in3.17","type":"blocks","created_at":"2025-12-22T19:24:45.605616-06:00","created_by":"daemon"},{"issue_id":"scribe-in3.19","depends_on_id":"scribe-in3.18","type":"blocks","created_at":"2025-12-22T19:24:45.650084-06:00","created_by":"daemon"}]}
{"id":"scribe-in3.2","title":"Implement CollapsibleHeadingNode JSON serialization (exportJSON/importJSON)","description":"## Purpose\n\nImplement JSON serialization so that collapse state persists when notes are saved and reopened. This is critical for UX - users expect their collapsed sections to stay collapsed.\n\n## Why persist in note JSON?\n\nDecision rationale:\n- **Pro**: State is per-note and travels with the note (export, sync, etc.)\n- **Pro**: No need for a separate state management system\n- **Con**: Slightly increases note file size (one boolean per heading)\n- **Alternative rejected**: localStorage keyed by note ID would require managing a separate store and wouldn't work across devices\n\n## Implementation Details\n\n### SerializedCollapsibleHeadingNode Type\n\n```typescript\ntype SerializedCollapsibleHeadingNode = Spread\u003c\n  { collapsed: boolean },\n  SerializedHeadingNode  // Inherits type, version, tag, etc.\n\u003e;\n```\n\n### exportJSON()\n\n```typescript\nexportJSON(): SerializedCollapsibleHeadingNode {\n  return {\n    ...super.exportJSON(),  // Get base heading serialization\n    type: 'collapsible-heading',  // Override type\n    collapsed: this.__collapsed,  // Add our state\n  };\n}\n```\n\n### static importJSON()\n\n```typescript\nstatic importJSON(json: SerializedCollapsibleHeadingNode): CollapsibleHeadingNode {\n  const node = $createCollapsibleHeadingNode(json.tag);\n  node.setCollapsed(json.collapsed);\n  // Lexical handles format, indent, direction from base\n  return node;\n}\n```\n\n## Markdown Export Consideration\n\nThe collapse state is VIEW-ONLY:\n- `exportJSON()` includes collapsed state (for Scribe persistence)\n- Markdown export (handled elsewhere) should export headings normally, ignoring collapse\n- This means collapsed content IS included in markdown exports (correct behavior)\n\n## Testing Requirements\n\n- Round-trip test: create node ‚Üí exportJSON ‚Üí importJSON ‚Üí verify collapsed state\n- Test with collapsed=true and collapsed=false\n- Test all heading levels (h1-h6)\n\n## Dependencies\n\n- Requires scribe-in3.1 (CollapsibleHeadingNode class must exist first)","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-22T19:12:44.047925-06:00","updated_at":"2025-12-22T19:21:42.522289-06:00","closed_at":"2025-12-22T19:21:42.522289-06:00","dependencies":[{"issue_id":"scribe-in3.2","depends_on_id":"scribe-in3","type":"parent-child","created_at":"2025-12-22T19:12:44.048282-06:00","created_by":"daemon"},{"issue_id":"scribe-in3.2","depends_on_id":"scribe-in3.1","type":"blocks","created_at":"2025-12-22T19:16:43.305512-06:00","created_by":"daemon"}]}
{"id":"scribe-in3.20","title":"Register node and plugin in EditorRoot","description":"## Purpose\n\nWire up the CollapsibleHeadingNode and CollapsibleHeadingPlugin into the main editor configuration. This includes:\n- Registering CollapsibleHeadingNode in the nodes array (replacing HeadingNode)\n- Adding CollapsibleHeadingPlugin to the component tree\n- Updating SlashMenu commands to use $createCollapsibleHeadingNode\n- Updating SelectionToolbar to use $createCollapsibleHeadingNode\n\n## Why One Task?\n\nThese are all small integration changes across 3 files, totaling ~20 lines of code changes. Previously split into 4 tasks (scribe-in3.9-12), which was excessive.\n\n## Files to Modify\n\n### 1. EditorRoot.tsx\n\n**Import changes:**\n```typescript\n// Remove HeadingNode from @lexical/rich-text import\nimport { QuoteNode } from \"@lexical/rich-text\";\n\n// Add new imports\nimport { CollapsibleHeadingNode } from \"./plugins/CollapsibleHeadingNode\";\nimport { CollapsibleHeadingPlugin } from \"./plugins/CollapsibleHeadingPlugin\";\n```\n\n**Node registration (replace HeadingNode):**\n```typescript\nnodes: [\n  CollapsibleHeadingNode,  // Replaces HeadingNode\n  QuoteNode,\n  ListNode,\n  // ... rest unchanged\n],\n```\n\n**Plugin addition (before MarkdownShortcutPlugin for transform ordering):**\n```typescript\n\u003cCollapsibleHeadingPlugin /\u003e\n\u003cMarkdownShortcutPlugin transformers={EDITOR_TRANSFORMERS} /\u003e\n```\n\n### 2. SlashMenu/commands.ts\n\n**Import change:**\n```typescript\n// Remove $createHeadingNode from @lexical/rich-text\nimport { $createQuoteNode } from \"@lexical/rich-text\";\nimport { $createCollapsibleHeadingNode } from \"../plugins/CollapsibleHeadingNode\";\n```\n\n**Update heading commands (3 places):**\n```typescript\n// heading1, heading2, heading3 execute functions:\n$setBlocksType(selection, () =\u003e $createCollapsibleHeadingNode(\"h1\"));\n$setBlocksType(selection, () =\u003e $createCollapsibleHeadingNode(\"h2\"));\n$setBlocksType(selection, () =\u003e $createCollapsibleHeadingNode(\"h3\"));\n```\n\n### 3. SelectionToolbar/SelectionToolbarPlugin.tsx\n\n**Import change:**\n```typescript\nimport { $isHeadingNode, HeadingTagType } from \"@lexical/rich-text\";\nimport { $createCollapsibleHeadingNode } from \"../plugins/CollapsibleHeadingNode\";\n```\n\n**Update formatHeading function:**\n```typescript\nconst heading = $createCollapsibleHeadingNode(tag);\n```\n\n## Why Replace HeadingNode?\n\nThe node transform in the plugin handles conversion of any HeadingNode that gets created (e.g., from markdown shortcuts). By registering only CollapsibleHeadingNode:\n1. Simpler mental model - only one heading type exists\n2. No conflicts between node types\n3. Transform handles edge cases automatically\n\n## Acceptance Criteria\n\n- [ ] CollapsibleHeadingNode registered in EditorRoot nodes array\n- [ ] HeadingNode removed from nodes array\n- [ ] CollapsibleHeadingPlugin added before MarkdownShortcutPlugin\n- [ ] SlashMenu heading commands create CollapsibleHeadingNode\n- [ ] SelectionToolbar heading formatting creates CollapsibleHeadingNode\n- [ ] Editor loads without errors\n- [ ] Typing \"# \" creates a collapsible heading\n\n## Dependencies\n\n- Requires scribe-in3.17 (node must exist)\n- Requires scribe-in3.19 (plugin must exist)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-22T19:23:30.942656-06:00","updated_at":"2025-12-22T19:23:30.942656-06:00","dependencies":[{"issue_id":"scribe-in3.20","depends_on_id":"scribe-in3","type":"parent-child","created_at":"2025-12-22T19:23:30.943023-06:00","created_by":"daemon"},{"issue_id":"scribe-in3.20","depends_on_id":"scribe-in3.17","type":"blocks","created_at":"2025-12-22T19:24:46.355403-06:00","created_by":"daemon"},{"issue_id":"scribe-in3.20","depends_on_id":"scribe-in3.19","type":"blocks","created_at":"2025-12-22T19:24:46.403708-06:00","created_by":"daemon"}]}
{"id":"scribe-in3.21","title":"Unit tests for CollapsibleHeadingNode","description":"## Purpose\n\nCreate comprehensive unit tests for CollapsibleHeadingNode following the testing patterns established in WikiLinkNode.test.ts.\n\n## File to Create\n`apps/desktop/renderer/src/components/Editor/plugins/CollapsibleHeadingNode.test.ts`\n\n## Test Structure\n\n```typescript\nimport { createEditor, $getRoot } from \"lexical\";\nimport {\n  CollapsibleHeadingNode,\n  $createCollapsibleHeadingNode,\n  $isCollapsibleHeadingNode,\n} from \"./CollapsibleHeadingNode\";\nimport { HeadingNode } from \"@lexical/rich-text\";\nimport { ParagraphNode, $createParagraphNode } from \"lexical\";\n\ndescribe(\"CollapsibleHeadingNode\", () =\u003e {\n  let editor: LexicalEditor;\n\n  beforeEach(() =\u003e {\n    editor = createEditor({\n      namespace: \"test\",\n      nodes: [CollapsibleHeadingNode],\n    });\n  });\n\n  describe(\"$createCollapsibleHeadingNode\", () =\u003e {\n    it(\"creates a heading with default collapsed=false\", async () =\u003e {});\n    it(\"creates headings for all levels (h1-h6)\", async () =\u003e {});\n  });\n\n  describe(\"$isCollapsibleHeadingNode\", () =\u003e {\n    it(\"returns true for CollapsibleHeadingNode\", async () =\u003e {});\n    it(\"returns false for regular HeadingNode\", async () =\u003e {});\n    it(\"returns false for ParagraphNode\", async () =\u003e {});\n    it(\"returns false for null/undefined\", () =\u003e {});\n  });\n\n  describe(\"collapse state\", () =\u003e {\n    it(\"isCollapsed() returns current state\", async () =\u003e {});\n    it(\"setCollapsed(true) sets collapsed state\", async () =\u003e {});\n    it(\"setCollapsed(false) clears collapsed state\", async () =\u003e {});\n    it(\"toggleCollapsed() inverts state\", async () =\u003e {});\n  });\n\n  describe(\"clone\", () =\u003e {\n    it(\"preserves tag when cloning\", async () =\u003e {});\n    it(\"preserves collapsed state when cloning\", async () =\u003e {});\n    it(\"creates new node key\", async () =\u003e {});\n  });\n\n  describe(\"JSON serialization\", () =\u003e {\n    it(\"exportJSON includes collapsed state\", async () =\u003e {});\n    it(\"exportJSON includes correct type\", async () =\u003e {});\n    it(\"importJSON restores collapsed state\", async () =\u003e {});\n    it(\"importJSON restores heading tag\", async () =\u003e {});\n    it(\"round-trip preserves all properties\", async () =\u003e {});\n  });\n\n  describe(\"createDOM\", () =\u003e {\n    it(\"creates correct heading element (h1-h6)\", async () =\u003e {});\n    it(\"adds data-collapsed attribute\", async () =\u003e {});\n    it(\"adds collapsible-heading class\", async () =\u003e {});\n  });\n\n  describe(\"updateDOM\", () =\u003e {\n    it(\"updates data-collapsed when state changes\", async () =\u003e {});\n  });\n});\n```\n\n## Example Test Implementation\n\n```typescript\nit(\"round-trip preserves all properties\", async () =\u003e {\n  await editor.update(() =\u003e {\n    const node = $createCollapsibleHeadingNode(\"h2\");\n    node.setCollapsed(true);\n    \n    const json = node.exportJSON();\n    const restored = CollapsibleHeadingNode.importJSON(json);\n    \n    expect(restored.getTag()).toBe(\"h2\");\n    expect(restored.isCollapsed()).toBe(true);\n  });\n});\n\nit(\"toggleCollapsed() inverts state\", async () =\u003e {\n  await editor.update(() =\u003e {\n    const node = $createCollapsibleHeadingNode(\"h1\");\n    expect(node.isCollapsed()).toBe(false);\n    \n    node.toggleCollapsed();\n    expect(node.isCollapsed()).toBe(true);\n    \n    node.toggleCollapsed();\n    expect(node.isCollapsed()).toBe(false);\n  });\n});\n```\n\n## Acceptance Criteria\n\n- [ ] All factory function tests pass\n- [ ] All type guard tests pass\n- [ ] All state management tests pass\n- [ ] All clone tests pass\n- [ ] All serialization tests pass\n- [ ] All DOM tests pass\n- [ ] Test coverage \u003e 90% for the node file\n\n## Dependencies\n\n- Requires scribe-in3.17 (node must be implemented to test)\n\n## Can Run in Parallel With\n\n- scribe-in3.22 (integration tests) - different scope, no conflicts","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-22T19:23:54.217311-06:00","updated_at":"2025-12-22T19:23:54.217311-06:00","dependencies":[{"issue_id":"scribe-in3.21","depends_on_id":"scribe-in3","type":"parent-child","created_at":"2025-12-22T19:23:54.217691-06:00","created_by":"daemon"},{"issue_id":"scribe-in3.21","depends_on_id":"scribe-in3.17","type":"blocks","created_at":"2025-12-22T19:24:47.057045-06:00","created_by":"daemon"}]}
{"id":"scribe-in3.22","title":"Integration tests for CollapsibleHeadingPlugin","description":"## Purpose\n\nCreate integration tests that verify the complete user experience of collapsible headings. These tests use React Testing Library and simulate real user interactions.\n\n## File to Create\n`apps/desktop/renderer/src/components/Editor/plugins/CollapsibleHeadingPlugin.test.tsx`\n\n## Test Structure\n\n```typescript\nimport { render, waitFor, fireEvent, act } from \"@testing-library/react\";\nimport { LexicalComposer } from \"@lexical/react/LexicalComposer\";\nimport { RichTextPlugin } from \"@lexical/react/LexicalRichTextPlugin\";\nimport { ContentEditable } from \"@lexical/react/LexicalContentEditable\";\nimport { CollapsibleHeadingNode } from \"./CollapsibleHeadingNode\";\nimport { CollapsibleHeadingPlugin } from \"./CollapsibleHeadingPlugin\";\n\n// Test editor wrapper\nfunction TestEditor({ children }: { children?: React.ReactNode }) {\n  const config = {\n    namespace: \"test\",\n    nodes: [CollapsibleHeadingNode],\n    onError: console.error,\n  };\n\n  return (\n    \u003cLexicalComposer initialConfig={config}\u003e\n      \u003cRichTextPlugin\n        contentEditable={\u003cContentEditable /\u003e}\n        placeholder={null}\n      /\u003e\n      \u003cCollapsibleHeadingPlugin /\u003e\n      {children}\n    \u003c/LexicalComposer\u003e\n  );\n}\n\ndescribe(\"CollapsibleHeadingPlugin\", () =\u003e {\n  describe(\"HeadingNode transform\", () =\u003e {\n    it(\"converts HeadingNode to CollapsibleHeadingNode on markdown input\", async () =\u003e {});\n    it(\"preserves heading content during transform\", async () =\u003e {});\n    it(\"transforms pasted headings\", async () =\u003e {});\n  });\n\n  describe(\"FoldIcon\", () =\u003e {\n    it(\"appears on heading hover\", async () =\u003e {});\n    it(\"shows ‚ñº when expanded\", async () =\u003e {});\n    it(\"shows ‚ñ∂ when collapsed\", async () =\u003e {});\n    it(\"disappears when mouse leaves heading\", async () =\u003e {});\n  });\n\n  describe(\"collapse behavior\", () =\u003e {\n    it(\"hides content until next same-level heading on collapse\", async () =\u003e {});\n    it(\"hides content until next higher-level heading on collapse\", async () =\u003e {});\n    it(\"shows nested headings when parent is collapsed\", async () =\u003e {\n      // h1 collapsed should hide h2 under it\n    });\n    it(\"handles collapse at end of document\", async () =\u003e {});\n    it(\"handles multiple consecutive headings\", async () =\u003e {});\n    it(\"handles empty sections\", async () =\u003e {});\n  });\n\n  describe(\"state persistence\", () =\u003e {\n    it(\"preserves collapsed state on save/reload\", async () =\u003e {});\n    it(\"applies collapsed state on initial load\", async () =\u003e {});\n  });\n\n  describe(\"accessibility\", () =\u003e {\n    it(\"fold icon has aria-label\", async () =\u003e {});\n    it(\"fold icon has aria-expanded\", async () =\u003e {});\n    it(\"fold icon is keyboard focusable\", async () =\u003e {});\n    it(\"Enter key toggles collapse\", async () =\u003e {});\n    it(\"Space key toggles collapse\", async () =\u003e {});\n  });\n\n  describe(\"undo/redo\", () =\u003e {\n    it(\"collapse can be undone\", async () =\u003e {});\n    it(\"collapse can be redone\", async () =\u003e {});\n  });\n});\n```\n\n## Key Test Scenarios\n\n### Section Boundary Test\n```typescript\nit(\"hides content until next same-level heading\", async () =\u003e {\n  // Create: h1, p, p, h1\n  // Collapse first h1\n  // Verify: both p elements are hidden\n  // Verify: second h1 is visible\n});\n```\n\n### Nested Heading Test\n```typescript\nit(\"hides nested headings when parent is collapsed\", async () =\u003e {\n  // Create: h1, p, h2, p, h1\n  // Collapse first h1\n  // Verify: first p, h2, second p are all hidden\n  // Verify: second h1 is visible\n});\n```\n\n## Acceptance Criteria\n\n- [ ] Transform tests verify HeadingNode conversion\n- [ ] FoldIcon tests verify hover behavior\n- [ ] Collapse behavior tests verify section boundaries\n- [ ] Persistence tests verify save/load\n- [ ] Accessibility tests verify ARIA and keyboard\n- [ ] Undo/redo tests verify history integration\n\n## Dependencies\n\n- Requires scribe-in3.20 (full integration must be complete)\n\n## Can Run in Parallel With\n\n- scribe-in3.21 (unit tests) - different scope, no conflicts","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-22T19:24:17.245469-06:00","updated_at":"2025-12-22T19:24:17.245469-06:00","dependencies":[{"issue_id":"scribe-in3.22","depends_on_id":"scribe-in3","type":"parent-child","created_at":"2025-12-22T19:24:17.245831-06:00","created_by":"daemon"},{"issue_id":"scribe-in3.22","depends_on_id":"scribe-in3.20","type":"blocks","created_at":"2025-12-22T19:24:47.556778-06:00","created_by":"daemon"}]}
{"id":"scribe-in3.23","title":"Handle migration of existing HeadingNode content","description":"## Purpose\n\nEnsure that notes created before the collapsible headings feature (containing regular `HeadingNode` JSON) are properly upgraded to `CollapsibleHeadingNode` when opened.\n\n## The Problem\n\nExisting notes in users vaults contain headings serialized as:\n```json\n{\n  \"type\": \"heading\",\n  \"tag\": \"h1\",\n  \"children\": [...]\n}\n```\n\nAfter this feature ships, the editor expects:\n```json\n{\n  \"type\": \"collapsible-heading\",\n  \"tag\": \"h1\",\n  \"collapsed\": false,\n  \"children\": [...]\n}\n```\n\nWithout migration handling, existing notes could:\n1. Fail to load (if Lexical doesnt recognize \"heading\" type)\n2. Load without collapse functionality\n3. Corrupt data on save\n\n## Solution: Node Replacement Registration\n\nLexical supports `editor.registerNodeReplacement()` which tells the editor to substitute one node type for another during deserialization:\n\n```typescript\n// In EditorRoot.tsx or CollapsibleHeadingPlugin.tsx\nuseEffect(() =\u003e {\n  return editor.registerNodeReplacement(\n    HeadingNode,\n    (node: HeadingNode) =\u003e {\n      const collapsible = $createCollapsibleHeadingNode(node.getTag());\n      // Default collapsed to false for migrated content\n      return collapsible;\n    }\n  );\n}, [editor]);\n```\n\n**Note:** This is different from `registerNodeTransform`. Node replacement happens during initial state parsing, while transforms happen on mutations.\n\n## Alternative: Keep HeadingNode Registered\n\nAnother approach is to keep HeadingNode in the nodes array alongside CollapsibleHeadingNode, and let the transform handle conversion:\n\n```typescript\nnodes: [\n  HeadingNode,  // For reading old content\n  CollapsibleHeadingNode,  // Primary type\n  // ...\n],\n```\n\nThe transform would convert any HeadingNode to CollapsibleHeadingNode immediately after load.\n\n## Testing Requirements\n\n1. **Load old note**: Create a note JSON with type \"heading\", verify it loads\n2. **Preserve content**: Verify heading text is preserved during migration\n3. **Default state**: Verify migrated headings have collapsed=false\n4. **Save format**: Verify re-saved notes use \"collapsible-heading\" type\n5. **Round-trip**: Load old format ‚Üí edit ‚Üí save ‚Üí reload ‚Üí verify\n\n## Test File\nAdd to `apps/desktop/renderer/src/components/Editor/plugins/CollapsibleHeadingPlugin.test.tsx`:\n\n```typescript\ndescribe(\"migration\", () =\u003e {\n  it(\"loads notes with old HeadingNode format\", async () =\u003e {\n    const oldFormatState = {\n      root: {\n        children: [{\n          type: \"heading\",\n          tag: \"h1\",\n          children: [{ type: \"text\", text: \"Old Heading\" }]\n        }]\n      }\n    };\n    \n    // Parse and verify CollapsibleHeadingNode is created\n  });\n  \n  it(\"preserves heading content during migration\", async () =\u003e {});\n  \n  it(\"sets collapsed=false for migrated headings\", async () =\u003e {});\n  \n  it(\"re-saves in new format\", async () =\u003e {});\n});\n```\n\n## Acceptance Criteria\n\n- [ ] Notes with \"heading\" type load successfully\n- [ ] Heading text content is preserved\n- [ ] Migrated headings have collapsed=false\n- [ ] Re-saved notes use \"collapsible-heading\" type\n- [ ] No data loss during migration\n- [ ] Migration is transparent to users\n\n## Dependencies\n\n- Requires scribe-in3.17 (node must exist)\n- Requires scribe-in3.20 (integration must be complete)\n\n## Risk\n\n**Medium** - If migration fails silently, users could lose heading formatting in their notes. Must be thoroughly tested.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-22T19:24:39.262805-06:00","updated_at":"2025-12-22T19:24:39.262805-06:00","dependencies":[{"issue_id":"scribe-in3.23","depends_on_id":"scribe-in3","type":"parent-child","created_at":"2025-12-22T19:24:39.26318-06:00","created_by":"daemon"},{"issue_id":"scribe-in3.23","depends_on_id":"scribe-in3.20","type":"blocks","created_at":"2025-12-22T19:24:48.075962-06:00","created_by":"daemon"}]}
{"id":"scribe-in3.3","title":"Create unit tests for CollapsibleHeadingNode","description":"## Purpose\n\nCreate comprehensive unit tests for `CollapsibleHeadingNode` to ensure correctness before integrating with the larger editor system. Following the testing patterns established in `WikiLinkNode.test.ts`.\n\n## Testing Approach\n\nBased on the existing test patterns in this codebase (see `WikiLinkNode.test.ts`):\n- Create editor with `createEditor({ namespace: 'test', nodes: [CollapsibleHeadingNode] })`\n- Use `editor.update()` + `await` for mutations\n- Test in isolation without React rendering\n\n## Test Cases\n\n### Factory Function Tests\n```typescript\ndescribe('$createCollapsibleHeadingNode', () =\u003e {\n  it('creates a heading with default collapsed=false', () =\u003e {});\n  it('creates headings for all levels (h1-h6)', () =\u003e {});\n});\n```\n\n### Type Guard Tests\n```typescript\ndescribe('$isCollapsibleHeadingNode', () =\u003e {\n  it('returns true for CollapsibleHeadingNode', () =\u003e {});\n  it('returns false for regular HeadingNode', () =\u003e {});\n  it('returns false for ParagraphNode', () =\u003e {});\n  it('returns false for null/undefined', () =\u003e {});\n});\n```\n\n### State Management Tests\n```typescript\ndescribe('collapse state', () =\u003e {\n  it('isCollapsed() returns current state', () =\u003e {});\n  it('setCollapsed() updates state', () =\u003e {});\n  it('toggleCollapsed() inverts state', () =\u003e {});\n});\n```\n\n### Clone Tests\n```typescript\ndescribe('clone', () =\u003e {\n  it('preserves tag when cloning', () =\u003e {});\n  it('preserves collapsed state when cloning', () =\u003e {});\n  it('creates new node key', () =\u003e {});\n});\n```\n\n### Serialization Tests\n```typescript\ndescribe('JSON serialization', () =\u003e {\n  it('exportJSON includes collapsed state', () =\u003e {});\n  it('exportJSON includes correct type', () =\u003e {});\n  it('importJSON restores collapsed state', () =\u003e {});\n  it('importJSON restores heading tag', () =\u003e {});\n  it('round-trip preserves all properties', () =\u003e {});\n});\n```\n\n### DOM Tests\n```typescript\ndescribe('createDOM', () =\u003e {\n  it('creates correct heading element (h1-h6)', () =\u003e {});\n  it('adds data-collapsed attribute', () =\u003e {});\n  it('adds collapsible-heading class', () =\u003e {});\n});\n\ndescribe('updateDOM', () =\u003e {\n  it('updates data-collapsed when state changes', () =\u003e {});\n  it('returns false (decorator handles updates)', () =\u003e {});\n});\n```\n\n## Files to Create\n\n- `apps/desktop/renderer/src/components/Editor/plugins/CollapsibleHeadingNode.test.ts`\n\n## Dependencies\n\n- Requires scribe-in3.1 and scribe-in3.2 (node must be fully implemented)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T19:12:44.127629-06:00","updated_at":"2025-12-22T19:21:42.522907-06:00","closed_at":"2025-12-22T19:21:42.522907-06:00","dependencies":[{"issue_id":"scribe-in3.3","depends_on_id":"scribe-in3","type":"parent-child","created_at":"2025-12-22T19:12:44.127978-06:00","created_by":"daemon"},{"issue_id":"scribe-in3.3","depends_on_id":"scribe-in3.2","type":"blocks","created_at":"2025-12-22T19:16:43.363274-06:00","created_by":"daemon"}]}
{"id":"scribe-in3.4","title":"Create CollapsibleHeadingPlugin with HeadingNode transform","description":"## Purpose\n\nCreate the Lexical plugin that orchestrates the collapsible heading behavior. This plugin's most critical responsibility is the **HeadingNode transform** that automatically converts any `HeadingNode` to our `CollapsibleHeadingNode`.\n\n## Why a Node Transform?\n\nWhen users type `# ` or `## ` to create headings via markdown shortcuts, Lexical's built-in `MarkdownShortcutPlugin` creates standard `HeadingNode` instances. We need to intercept these and convert them to `CollapsibleHeadingNode`:\n\n```typescript\neditor.registerNodeTransform(HeadingNode, (node) =\u003e {\n  if (node.getType() === 'heading') {\n    const collapsed = $createCollapsibleHeadingNode(node.getTag());\n    collapsed.append(...node.getChildren());\n    node.replace(collapsed);\n  }\n});\n```\n\nThis ensures:\n1. Markdown shortcuts (`# `, `## `, etc.) create collapsible headings\n2. Pasted content with headings gets converted\n3. Any other mechanism creating HeadingNode is handled\n\n## Plugin Structure\n\n```typescript\nexport function CollapsibleHeadingPlugin(): JSX.Element | null {\n  const [editor] = useLexicalComposerContext();\n  \n  // 1. Node transform registration\n  useEffect(() =\u003e {\n    return editor.registerNodeTransform(HeadingNode, transformFn);\n  }, [editor]);\n  \n  // 2. State for hover tracking (added in later subtasks)\n  // 3. Command registration (added in later subtasks)\n  // 4. Event listeners (added in later subtasks)\n  \n  return null;  // Or portal content for fold icons\n}\n```\n\n## Files to Create\n\n- `apps/desktop/renderer/src/components/Editor/plugins/CollapsibleHeadingPlugin.tsx`\n\n## Initial Implementation Scope\n\nFor this subtask, implement ONLY:\n1. Basic plugin component structure\n2. HeadingNode ‚Üí CollapsibleHeadingNode transform\n3. Export the plugin component\n\nLater subtasks will add:\n- FoldIcon rendering (scribe-in3.5)\n- Command handling (scribe-in3.6)\n- CSS class application (scribe-in3.7)\n\n## Dependencies\n\n- Requires scribe-in3.1 and scribe-in3.2 (node must be complete)","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-22T19:12:44.209754-06:00","updated_at":"2025-12-22T19:21:42.523606-06:00","closed_at":"2025-12-22T19:21:42.523606-06:00","dependencies":[{"issue_id":"scribe-in3.4","depends_on_id":"scribe-in3","type":"parent-child","created_at":"2025-12-22T19:12:44.210118-06:00","created_by":"daemon"},{"issue_id":"scribe-in3.4","depends_on_id":"scribe-in3.2","type":"blocks","created_at":"2025-12-22T19:16:43.420626-06:00","created_by":"daemon"}]}
{"id":"scribe-in3.5","title":"Implement FoldIcon component with hover positioning","description":"## Purpose\n\nImplement the visual fold icon (‚ñ∂/‚ñº) that appears when hovering over a heading. This provides the primary user interaction point for collapsing sections.\n\n## Design Decisions\n\n### Why hover-based (desktop)?\n- Clean interface - icons don't clutter the document\n- Follows established patterns (VS Code, Obsidian)\n- Touch support will be handled separately (scribe-in3.16)\n\n### Icon Position\n- Appears to the LEFT of the heading text\n- Positioned absolutely relative to the heading element\n- Uses a React portal to render outside the Lexical content tree (avoids editor focus issues)\n\n## Implementation Details\n\n### FoldIcon Component\n\n```typescript\ninterface FoldIconProps {\n  collapsed: boolean;\n  position: { top: number; left: number };\n  onToggle: () =\u003e void;\n}\n\nfunction FoldIcon({ collapsed, position, onToggle }: FoldIconProps) {\n  return createPortal(\n    \u003cbutton\n      className=\"fold-icon\"\n      style={{ top: position.top, left: position.left }}\n      onClick={onToggle}\n      type=\"button\"\n    \u003e\n      {collapsed ? '‚ñ∂' : '‚ñº'}\n    \u003c/button\u003e,\n    document.body\n  );\n}\n```\n\n### Hover Detection\n\n```typescript\nconst handleMouseMove = (e: MouseEvent) =\u003e {\n  const target = e.target as HTMLElement;\n  const heading = target.closest('.collapsible-heading');\n  \n  if (heading) {\n    const rect = heading.getBoundingClientRect();\n    const key = /* resolve node key from DOM element */;\n    const collapsed = heading.getAttribute('data-collapsed') === 'true';\n    \n    setHoveredHeading({\n      key,\n      collapsed,\n      position: { top: rect.top, left: rect.left - 24 }\n    });\n  } else {\n    setHoveredHeading(null);\n  }\n};\n```\n\n### Node Key Resolution\n\nWe need to map the hovered DOM element back to its Lexical node key:\n```typescript\neditor.getEditorState().read(() =\u003e {\n  const root = $getRoot();\n  for (const child of root.getChildren()) {\n    if ($isCollapsibleHeadingNode(child)) {\n      const element = editor.getElementByKey(child.getKey());\n      if (element === heading) {\n        return child.getKey();\n      }\n    }\n  }\n  return null;\n});\n```\n\n## UI/UX Considerations\n\n- Icon should appear smoothly (CSS transition on opacity)\n- Icon position updates as heading scrolls\n- Click should NOT focus the heading (use e.preventDefault on mousedown)\n- Icon color should match `foregroundMuted` and brighten on hover\n\n## Files to Modify\n\n- `apps/desktop/renderer/src/components/Editor/plugins/CollapsibleHeadingPlugin.tsx`\n\n## Dependencies\n\n- Requires scribe-in3.4 (plugin must exist)\n- Related to scribe-in3.8 (styles must be added)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T19:12:44.289743-06:00","updated_at":"2025-12-22T19:21:42.524148-06:00","closed_at":"2025-12-22T19:21:42.524148-06:00","dependencies":[{"issue_id":"scribe-in3.5","depends_on_id":"scribe-in3","type":"parent-child","created_at":"2025-12-22T19:12:44.290118-06:00","created_by":"daemon"},{"issue_id":"scribe-in3.5","depends_on_id":"scribe-in3.4","type":"blocks","created_at":"2025-12-22T19:16:43.477661-06:00","created_by":"daemon"},{"issue_id":"scribe-in3.5","depends_on_id":"scribe-in3.8","type":"blocks","created_at":"2025-12-22T19:16:43.538114-06:00","created_by":"daemon"}]}
{"id":"scribe-in3.6","title":"Implement TOGGLE_COLLAPSE_COMMAND handler","description":"## Purpose\n\nImplement the Lexical command that toggles a heading's collapsed state. Commands are the proper way to handle editor mutations in Lexical - they provide undo/redo support and can be dispatched from multiple sources (click, keyboard, etc.).\n\n## Command Design\n\n```typescript\nexport const TOGGLE_COLLAPSE_COMMAND: LexicalCommand\u003cstring\u003e = createCommand();\n```\n\nThe payload is the node key (string) of the heading to toggle.\n\n## Command Handler\n\n```typescript\nuseEffect(() =\u003e {\n  return editor.registerCommand(\n    TOGGLE_COLLAPSE_COMMAND,\n    (nodeKey: string) =\u003e {\n      editor.update(() =\u003e {\n        const node = $getNodeByKey(nodeKey);\n        if ($isCollapsibleHeadingNode(node)) {\n          node.toggleCollapsed();\n          // Trigger CSS update (handled in scribe-in3.7)\n          updateCollapsedSectionsRef.current?.();\n        }\n      });\n      return true;  // Command handled\n    },\n    COMMAND_PRIORITY_LOW\n  );\n}, [editor]);\n```\n\n## Integration Points\n\n1. **FoldIcon click**: `editor.dispatchCommand(TOGGLE_COLLAPSE_COMMAND, nodeKey)`\n2. **Future keyboard shortcuts**: Same dispatch mechanism\n3. **Future context menu**: Same dispatch mechanism\n\n## Why COMMAND_PRIORITY_LOW?\n\nWe use LOW priority because:\n- We don't need to intercept or prevent other handlers\n- We're not modifying how the editor handles user input\n- We just want to react after other processing is done\n\n## Undo/Redo Behavior\n\nBecause we modify the node state via `editor.update()`, Lexical's history plugin will automatically:\n- Add the collapse toggle to the undo stack\n- Allow users to undo/redo collapse operations\n- Group rapid toggles appropriately\n\n## Files to Modify\n\n- `apps/desktop/renderer/src/components/Editor/plugins/CollapsibleHeadingPlugin.tsx`\n\n## Dependencies\n\n- Requires scribe-in3.4 and scribe-in3.5 (plugin and fold icon must exist)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T19:12:44.368019-06:00","updated_at":"2025-12-22T19:21:42.524644-06:00","closed_at":"2025-12-22T19:21:42.524644-06:00","dependencies":[{"issue_id":"scribe-in3.6","depends_on_id":"scribe-in3","type":"parent-child","created_at":"2025-12-22T19:12:44.368376-06:00","created_by":"daemon"},{"issue_id":"scribe-in3.6","depends_on_id":"scribe-in3.5","type":"blocks","created_at":"2025-12-22T19:16:43.595132-06:00","created_by":"daemon"}]}
{"id":"scribe-in3.7","title":"Implement updateCollapsedSections for CSS-based hiding","description":"## Purpose\n\nImplement the core logic that applies CSS classes to hide content under collapsed headings. This is the mechanism that makes sections actually disappear when collapsed.\n\n## Section Boundary Algorithm\n\nThe algorithm must correctly identify which nodes belong to each heading's section:\n\n```typescript\nfunction updateCollapsedSections() {\n  editor.getEditorState().read(() =\u003e {\n    const root = $getRoot();\n    const children = root.getChildren();\n    let currentCollapsed: { level: number; active: boolean } | null = null;\n\n    children.forEach((child) =\u003e {\n      if ($isCollapsibleHeadingNode(child)) {\n        const level = getHeadingLevel(child.getTag());  // h1‚Üí1, h2‚Üí2, etc.\n        \n        // Check if this heading ends a collapsed section\n        // A heading of equal or higher level (smaller number) ends the section\n        if (currentCollapsed \u0026\u0026 level \u003c= currentCollapsed.level) {\n          currentCollapsed = null;\n        }\n        \n        // Start new collapsed section if this heading is collapsed\n        if (child.isCollapsed()) {\n          currentCollapsed = { level, active: true };\n        }\n\n        // Headings themselves are never hidden\n        const element = editor.getElementByKey(child.getKey());\n        element?.classList.remove('collapsed-content');\n      } else if (currentCollapsed?.active) {\n        // Non-heading content in collapsed section ‚Üí hide it\n        const element = editor.getElementByKey(child.getKey());\n        element?.classList.add('collapsed-content');\n      } else {\n        // Not in collapsed section ‚Üí ensure visible\n        const element = editor.getElementByKey(child.getKey());\n        element?.classList.remove('collapsed-content');\n      }\n    });\n  });\n}\n```\n\n## Helper Function\n\n```typescript\nfunction getHeadingLevel(tag: string): number {\n  return parseInt(tag.replace('h', ''), 10);\n}\n```\n\n## Example Document Behavior\n\n```\n# Heading 1 (collapsed)    ‚Üí VISIBLE (headings always visible)\nSome content               ‚Üí HIDDEN (inside h1 section)\n## Heading 2               ‚Üí HIDDEN (inside h1 section, h2 \u003c h1 level)\nMore content               ‚Üí HIDDEN (inside h1 section)\n# Another H1               ‚Üí VISIBLE (ends h1 section, not collapsed)\nContent here               ‚Üí VISIBLE (not in collapsed section)\n```\n\n## Performance Considerations\n\nThis function iterates ALL root children on every toggle. For large documents:\n- Consider memoizing section boundaries\n- Consider debouncing if multiple toggles happen quickly\n- Current implementation is O(n) which should be fine for typical documents\n\n## When to Call\n\n- After TOGGLE_COLLAPSE_COMMAND is dispatched\n- On initial editor load (to apply persisted collapsed states)\n- Use a ref to store the function so it can be called from command handler\n\n## Files to Modify\n\n- `apps/desktop/renderer/src/components/Editor/plugins/CollapsibleHeadingPlugin.tsx`\n\n## Dependencies\n\n- Requires scribe-in3.4 (plugin structure)\n- Requires scribe-in3.6 (command handler calls this)\n- Related to scribe-in3.8 (CSS class must be defined)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T19:12:44.453835-06:00","updated_at":"2025-12-22T19:21:42.525101-06:00","closed_at":"2025-12-22T19:21:42.525101-06:00","dependencies":[{"issue_id":"scribe-in3.7","depends_on_id":"scribe-in3","type":"parent-child","created_at":"2025-12-22T19:12:44.454233-06:00","created_by":"daemon"},{"issue_id":"scribe-in3.7","depends_on_id":"scribe-in3.6","type":"blocks","created_at":"2025-12-22T19:16:43.653291-06:00","created_by":"daemon"},{"issue_id":"scribe-in3.7","depends_on_id":"scribe-in3.8","type":"blocks","created_at":"2025-12-22T19:16:43.710524-06:00","created_by":"daemon"}]}
{"id":"scribe-in3.8","title":"Add fold icon and collapsed content styles to EditorRoot.css.ts","description":"## Purpose\n\nAdd CSS styles for the fold icon and collapsed content to `EditorRoot.css.ts`. Following the existing vanilla-extract patterns in the codebase.\n\n## Styles to Add\n\n### 1. Fold Icon Styles\n\n```typescript\n// Fold icon - appears on heading hover, positioned via portal\nexport const foldIcon = style({\n  position: 'fixed',  // Positioned by JS\n  width: '20px',\n  height: '20px',\n  display: 'flex',\n  alignItems: 'center',\n  justifyContent: 'center',\n  cursor: 'pointer',\n  opacity: 0,\n  transition: 'opacity 150ms ease',\n  color: vars.color.foregroundMuted,\n  border: 'none',\n  background: 'transparent',\n  padding: 0,\n  fontSize: '12px',\n  zIndex: 10,  // Above editor content\n  ':hover': {\n    color: vars.color.foreground,\n  },\n  ':focus-visible': {\n    outline: `2px solid ${vars.color.accent}`,\n    outlineOffset: '2px',\n  },\n});\n\n// Class added when fold icon should be visible\nexport const foldIconVisible = style({\n  opacity: 1,\n});\n```\n\n### 2. Collapsed Heading Indicator\n\n```typescript\n// Visual cue that a heading has hidden content\nglobalStyle('.collapsible-heading[data-collapsed=\"true\"]::after', {\n  content: '\"...\"',\n  color: vars.color.foregroundMuted,\n  marginLeft: vars.spacing['2'],\n  fontSize: '0.8em',\n});\n```\n\n### 3. Hidden Content\n\n```typescript\n// Content hidden under collapsed headings\nglobalStyle('.collapsed-content', {\n  display: 'none',\n});\n```\n\n### 4. Collapsible Heading Base\n\n```typescript\n// Base styling for collapsible headings\nglobalStyle('.collapsible-heading', {\n  position: 'relative',  // For potential future icon positioning\n});\n```\n\n## Design Token Usage\n\nFollowing existing patterns:\n- Use `vars.color.foregroundMuted` for muted elements\n- Use `vars.color.foreground` for interactive hover states\n- Use `vars.color.accent` for focus indicators\n- Use `vars.spacing['2']` for small spacing\n- Use `vars.radius.sm` for small border radii if needed\n\n## Integration\n\nThe plugin will:\n1. Import the `foldIcon` style class from this file\n2. Apply it to the FoldIcon button element\n3. Toggle `foldIconVisible` when hovering over headings\n\n## Files to Modify\n\n- `apps/desktop/renderer/src/components/Editor/EditorRoot.css.ts`\n\n## Dependencies\n\n- Can be done in parallel with other tasks\n- Required by scribe-in3.5 (FoldIcon needs styles)\n- Required by scribe-in3.7 (collapsed-content class needs to exist)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T19:12:44.535347-06:00","updated_at":"2025-12-22T19:21:42.525559-06:00","closed_at":"2025-12-22T19:21:42.525559-06:00","dependencies":[{"issue_id":"scribe-in3.8","depends_on_id":"scribe-in3","type":"parent-child","created_at":"2025-12-22T19:12:44.535708-06:00","created_by":"daemon"}]}
{"id":"scribe-in3.9","title":"Register CollapsibleHeadingNode in EditorRoot nodes array","description":"## Purpose\n\nRegister `CollapsibleHeadingNode` in the Lexical editor configuration so the editor knows how to handle this node type.\n\n## Current State (EditorRoot.tsx lines 101-115)\n\n```typescript\nnodes: [\n  HeadingNode,           // ‚Üê This will be REPLACED\n  QuoteNode,\n  ListNode,\n  ListItemNode,\n  CodeNode,\n  CodeHighlightNode,\n  LinkNode,\n  HorizontalRuleNode,\n  WikiLinkNode,\n  PersonMentionNode,\n  TableNode,\n  TableRowNode,\n  TableCellNode,\n],\n```\n\n## Required Change\n\n```typescript\nimport { CollapsibleHeadingNode } from './plugins/CollapsibleHeadingNode';\n\n// In editorConfig.nodes:\nnodes: [\n  CollapsibleHeadingNode,  // ‚Üê REPLACE HeadingNode with this\n  QuoteNode,\n  // ... rest unchanged\n],\n```\n\n## Important: HeadingNode Replacement Strategy\n\nWe have two options:\n\n### Option A: Keep Both (Not Recommended)\n```typescript\nnodes: [HeadingNode, CollapsibleHeadingNode, ...]\n```\nProblem: The node transform would need to handle both types, and there could be conflicts.\n\n### Option B: Replace HeadingNode (Recommended)\n```typescript\nnodes: [CollapsibleHeadingNode, ...]\n```\nThe `registerNodeTransform` in the plugin handles incoming HeadingNode instances from markdown shortcuts and converts them.\n\n**We're using Option B** because:\n1. Simpler mental model - only one heading type in the document\n2. The plugin's transform handles conversion automatically\n3. Avoids type confusion and potential bugs\n\n## Import Updates\n\n```typescript\n// Remove from imports:\nimport { HeadingNode, QuoteNode } from '@lexical/rich-text';\n\n// Change to:\nimport { QuoteNode } from '@lexical/rich-text';\nimport { CollapsibleHeadingNode } from './plugins/CollapsibleHeadingNode';\n```\n\n## Files to Modify\n\n- `apps/desktop/renderer/src/components/Editor/EditorRoot.tsx`\n\n## Dependencies\n\n- Requires scribe-in3.1 and scribe-in3.2 (node must be implemented)\n- Should be done before or with scribe-in3.10 (plugin registration)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T19:12:44.615043-06:00","updated_at":"2025-12-22T19:21:44.459824-06:00","closed_at":"2025-12-22T19:21:44.459824-06:00","dependencies":[{"issue_id":"scribe-in3.9","depends_on_id":"scribe-in3","type":"parent-child","created_at":"2025-12-22T19:12:44.615415-06:00","created_by":"daemon"},{"issue_id":"scribe-in3.9","depends_on_id":"scribe-in3.2","type":"blocks","created_at":"2025-12-22T19:16:43.770793-06:00","created_by":"daemon"}]}
{"id":"scribe-pzw","title":"Outline Widget for Context Panel (GH #47)","description":"## Epic: Add Outline Widget to Context Panel for In-Note Heading Navigation\n\n**GitHub Issue**: #47\n**Priority**: P1\n**Type**: Feature\n\n---\n\n### Overview\n\nThis epic implements an Outline widget in the ContextPanel that provides a table-of-contents view of the current note's headings. Users can click any heading in the outline to instantly navigate to that section in the editor. This addresses a key usability gap for users working with long, structured documents.\n\n### Strategic Value\n\n1. **Improved Navigation**: Long notes (meeting notes, project docs, daily journals) become significantly more navigable\n2. **Document Structure Visibility**: Users can see at-a-glance how their note is organized\n3. **Consistency with Industry Standards**: Matches behavior users expect from VS Code, Notion, Obsidian, and other modern note-taking tools\n4. **Foundation for Future Features**: Enables scroll-spy (active heading highlighting), section-level operations, and document outline export\n\n### Key Technical Challenges\n\n1. **Cross-Component Communication**: The EditorRoot and ContextPanel are React siblings, not parent-child. Solution: Create a shared `EditorCommandContext` that wraps both components.\n\n2. **Heading Extraction**: Need to traverse the Lexical AST to extract headings with their text, level (h1-h6), and node keys. Use existing `ast-utils.ts` utilities.\n\n3. **Template System Integration**: Extend the `ContextPanelSection` union type and update the template registry.\n\n### Architecture Decisions\n\n**Why EditorCommandContext instead of props drilling?**\n- ContextPanel receives callbacks like `onNavigate` for note-level navigation\n- For in-note navigation, we need to dispatch commands to the Lexical editor instance\n- A shared context cleanly solves sibling-to-sibling communication\n\n**Why heading-extractor in packages/shared?**\n- Reusable by CLI tools, search indexing, export features\n- Co-located with `ast-utils.ts`\n- Easy to unit test without React\n\n### Files Affected\n\n**New Files**:\n- `packages/shared/src/heading-extractor.ts`\n- `apps/desktop/renderer/src/components/Editor/EditorCommandContext.tsx`\n- `apps/desktop/renderer/src/components/ContextPanel/OutlineWidget.tsx`\n\n**Modified Files**:\n- `apps/desktop/renderer/src/templates/types.ts`\n- `apps/desktop/renderer/src/templates/registry.ts`\n- `apps/desktop/renderer/src/components/ContextPanel/ContextPanel.tsx`\n- `apps/desktop/renderer/src/components/ContextPanel/ContextPanel.css.ts`\n- `apps/desktop/renderer/src/components/Editor/EditorRoot.tsx`\n- `apps/desktop/renderer/src/App.tsx`\n- `packages/shared/src/index.ts`\n\n### Acceptance Criteria\n\n1. Outline widget appears in ContextPanel showing all headings (h1-h6)\n2. Clicking an outline item scrolls editor to that heading with visual highlight\n3. Outline updates when note content changes\n4. Empty state shown when note has no headings\n5. Keyboard navigation works (Tab, Enter, Space)\n6. All tests pass\n\n---\n\n### Subtask Dependency Graph (11 tasks)\n\n```\n[Foundation Layer - No Dependencies]\n‚îú‚îÄ‚îÄ 1. heading-extractor utility + tests (packages/shared)\n‚îú‚îÄ‚îÄ 2. EditorCommandContext + tests (React context)\n‚îú‚îÄ‚îÄ 3. ContextPanelSection type extension\n\n[Widget Layer - Depends on Foundation]\n‚îú‚îÄ‚îÄ 4. OutlineWidget styles \n‚îú‚îÄ‚îÄ 5. OutlineWidget component + tests ‚Üí depends on (1, 2, 4)\n\n[Integration Layer - Depends on Widget]\n‚îú‚îÄ‚îÄ 6. Template registry update ‚Üí depends on (3)\n‚îú‚îÄ‚îÄ 7. ContextPanel renderSection ‚Üí depends on (5, 6)\n‚îú‚îÄ‚îÄ 8. EditorRoot bridge plugin ‚Üí depends on (2)\n‚îú‚îÄ‚îÄ 9. App.tsx provider wrapping ‚Üí depends on (2, 8)\n\n[Testing \u0026 Finalization]\n‚îú‚îÄ‚îÄ 13. Integration tests ‚Üí depends on (9)\n‚îî‚îÄ‚îÄ 14. Documentation \u0026 cleanup ‚Üí depends on (13)\n```\n\n**Note**: Test beads 10, 11, 12 have been consolidated into their respective implementation beads (1, 2, 5).","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-22T19:09:06.974831-06:00","updated_at":"2025-12-22T19:23:03.431113-06:00"}
{"id":"scribe-pzw.1","title":"Create heading-extractor utility in packages/shared","description":"## Task: Create heading-extractor utility in packages/shared\n\n### Purpose\nCreate a utility function that extracts heading information from Lexical EditorContent for use by the OutlineWidget. This is a foundational piece that the OutlineWidget will depend on.\n\n### Why in packages/shared?\n- **Reusability**: Can be used by CLI tools (e.g., `scribe outline` command), search indexing, markdown export\n- **Co-location**: Lives alongside `ast-utils.ts` which provides the traversal utilities it uses\n- **Testability**: Pure function with no React dependencies makes unit testing straightforward\n\n### Interface Definition\n\n```typescript\n// packages/shared/src/heading-extractor.ts\n\nexport interface HeadingItem {\n  /** Lexical node key for scrolling/focusing (from node.__key) */\n  nodeKey: string;\n  /** Heading text content (extracted via extractTextFromNode) */\n  text: string;\n  /** Heading level (1-6, parsed from tag property h1-h6) */\n  level: number;\n  /** Visual indentation depth (0-based, calculated from relative levels) */\n  depth: number;\n}\n\n/**\n * Extract headings from EditorContent with hierarchy information.\n * \n * @param content - The EditorContent to extract headings from\n * @returns Array of HeadingItem objects in document order\n */\nexport function extractHeadings(content: EditorContent | null | undefined): HeadingItem[];\n```\n\n### Implementation Details\n\n1. **Use existing utilities**: \n   - `traverseNodesWithAncestors` from `ast-utils.ts` for tree traversal with context\n   - `extractTextFromNode` to get heading text content\n\n2. **Heading node identification**:\n   - Type check: `node.type === 'heading'`\n   - Level extraction: `parseInt(node.tag.replace('h', ''), 10)` where `tag` is 'h1'-'h6'\n   - Node key: `node.__key` (Lexical's internal identifier)\n\n3. **Skip headings in code blocks**:\n   - Use `ancestors` parameter to check if any ancestor has `type === 'code'`\n   - This prevents treating markdown in code blocks as actual headings\n\n4. **Depth calculation algorithm**:\n   - Track minimum level seen so far as we traverse\n   - `depth = level - minLevel` for relative indentation\n   - Example: h2, h3, h2 ‚Üí depths 0, 1, 0 (not 1, 2, 1)\n\n5. **Edge cases to handle**:\n   - `content` is null/undefined ‚Üí return `[]`\n   - No headings in content ‚Üí return `[]`\n   - Heading missing `__key` ‚Üí skip that heading (log warning in dev)\n   - Heading missing `tag` ‚Üí skip that heading\n   - Empty heading text ‚Üí include with empty string (user may add text later)\n\n### Files to Create/Modify\n\n- **Create**: `packages/shared/src/heading-extractor.ts`\n- **Modify**: `packages/shared/src/index.ts` (add export for `extractHeadings` and `HeadingItem`)\n\n### Testing Notes\n\nUnit tests should cover (included in this task):\n- Empty/null content\n- Single heading\n- Multiple headings at same level\n- Nested heading hierarchy (h1 \u003e h2 \u003e h3)\n- Non-sequential levels (h1 \u003e h3 \u003e h2)\n- Headings inside code blocks (should be skipped)\n- Missing __key or tag properties\n\nCreate test file: `packages/shared/src/heading-extractor.test.ts`\n\n### Definition of Done\n\n- [ ] `extractHeadings` function implemented with full edge case handling\n- [ ] `HeadingItem` interface exported\n- [ ] Added to `packages/shared/src/index.ts` exports  \n- [ ] Unit tests written and passing\n- [ ] JSDoc documentation complete\n- [ ] TypeScript compiles without errors","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T19:09:07.054508-06:00","updated_at":"2025-12-22T19:37:07.86428-06:00","closed_at":"2025-12-22T19:37:07.86428-06:00","dependencies":[{"issue_id":"scribe-pzw.1","depends_on_id":"scribe-pzw","type":"parent-child","created_at":"2025-12-22T19:09:07.054852-06:00","created_by":"daemon"}]}
{"id":"scribe-pzw.10","title":"Write unit tests for heading-extractor","description":"## Task: Write unit tests for heading-extractor\n\n### Purpose\nComprehensive unit tests for the `extractHeadings` function to ensure correct behavior across all edge cases.\n\n### Dependencies\n- scribe-pzw.1 (heading-extractor) - Need the function to test\n\n### Test File Location\n\n`packages/shared/src/heading-extractor.test.ts`\n\n### Test Cases\n\n```typescript\nimport { describe, it, expect } from 'vitest';\nimport { extractHeadings, type HeadingItem } from './heading-extractor';\nimport type { EditorContent } from './types';\n\ndescribe('extractHeadings', () =\u003e {\n  // Helper to create EditorContent with given nodes\n  function createContent(children: unknown[]): EditorContent {\n    return {\n      root: {\n        type: 'root',\n        children: children as EditorNode[],\n      },\n    };\n  }\n\n  // Helper to create a heading node\n  function createHeading(\n    tag: string,\n    text: string,\n    key: string\n  ): EditorNode {\n    return {\n      type: 'heading',\n      tag,\n      __key: key,\n      children: [{ type: 'text', text }],\n    };\n  }\n\n  describe('empty/null content', () =\u003e {\n    it('returns empty array for null content', () =\u003e {\n      expect(extractHeadings(null)).toEqual([]);\n    });\n\n    it('returns empty array for undefined content', () =\u003e {\n      expect(extractHeadings(undefined)).toEqual([]);\n    });\n\n    it('returns empty array for content with no headings', () =\u003e {\n      const content = createContent([\n        { type: 'paragraph', children: [{ type: 'text', text: 'Hello' }] },\n      ]);\n      expect(extractHeadings(content)).toEqual([]);\n    });\n  });\n\n  describe('single heading', () =\u003e {\n    it('extracts h1 heading with correct properties', () =\u003e {\n      const content = createContent([\n        createHeading('h1', 'Title', 'key1'),\n      ]);\n      \n      expect(extractHeadings(content)).toEqual([\n        { nodeKey: 'key1', text: 'Title', level: 1, depth: 0 },\n      ]);\n    });\n\n    it('extracts h6 heading with correct level', () =\u003e {\n      const content = createContent([\n        createHeading('h6', 'Deep heading', 'key1'),\n      ]);\n      \n      expect(extractHeadings(content)).toEqual([\n        { nodeKey: 'key1', text: 'Deep heading', level: 6, depth: 0 },\n      ]);\n    });\n  });\n\n  describe('multiple headings at same level', () =\u003e {\n    it('returns all headings with depth 0', () =\u003e {\n      const content = createContent([\n        createHeading('h2', 'First', 'key1'),\n        createHeading('h2', 'Second', 'key2'),\n        createHeading('h2', 'Third', 'key3'),\n      ]);\n      \n      const result = extractHeadings(content);\n      expect(result).toHaveLength(3);\n      expect(result.every(h =\u003e h.depth === 0)).toBe(true);\n    });\n  });\n\n  describe('nested heading hierarchy', () =\u003e {\n    it('calculates depth based on relative levels', () =\u003e {\n      const content = createContent([\n        createHeading('h1', 'Chapter', 'key1'),\n        createHeading('h2', 'Section', 'key2'),\n        createHeading('h3', 'Subsection', 'key3'),\n      ]);\n      \n      expect(extractHeadings(content)).toEqual([\n        { nodeKey: 'key1', text: 'Chapter', level: 1, depth: 0 },\n        { nodeKey: 'key2', text: 'Section', level: 2, depth: 1 },\n        { nodeKey: 'key3', text: 'Subsection', level: 3, depth: 2 },\n      ]);\n    });\n\n    it('handles depth reset when level decreases', () =\u003e {\n      const content = createContent([\n        createHeading('h1', 'Chapter 1', 'key1'),\n        createHeading('h2', 'Section 1.1', 'key2'),\n        createHeading('h1', 'Chapter 2', 'key3'),  // Back to h1\n        createHeading('h2', 'Section 2.1', 'key4'),\n      ]);\n      \n      expect(extractHeadings(content)).toEqual([\n        { nodeKey: 'key1', text: 'Chapter 1', level: 1, depth: 0 },\n        { nodeKey: 'key2', text: 'Section 1.1', level: 2, depth: 1 },\n        { nodeKey: 'key3', text: 'Chapter 2', level: 1, depth: 0 },\n        { nodeKey: 'key4', text: 'Section 2.1', level: 2, depth: 1 },\n      ]);\n    });\n  });\n\n  describe('non-sequential levels', () =\u003e {\n    it('handles skipped levels (h1 directly to h3)', () =\u003e {\n      const content = createContent([\n        createHeading('h1', 'Title', 'key1'),\n        createHeading('h3', 'Sub-subsection', 'key2'),\n      ]);\n      \n      expect(extractHeadings(content)).toEqual([\n        { nodeKey: 'key1', text: 'Title', level: 1, depth: 0 },\n        { nodeKey: 'key2', text: 'Sub-subsection', level: 3, depth: 2 },\n      ]);\n    });\n\n    it('handles document starting with h2', () =\u003e {\n      const content = createContent([\n        createHeading('h2', 'Section', 'key1'),\n        createHeading('h3', 'Subsection', 'key2'),\n      ]);\n      \n      expect(extractHeadings(content)).toEqual([\n        { nodeKey: 'key1', text: 'Section', level: 2, depth: 0 },\n        { nodeKey: 'key2', text: 'Subsection', level: 3, depth: 1 },\n      ]);\n    });\n  });\n\n  describe('headings inside code blocks', () =\u003e {\n    it('skips headings nested inside code nodes', () =\u003e {\n      const content = createContent([\n        createHeading('h1', 'Real heading', 'key1'),\n        {\n          type: 'code',\n          children: [\n            createHeading('h1', 'Fake heading in code', 'key2'),\n          ],\n        },\n        createHeading('h2', 'Another real heading', 'key3'),\n      ]);\n      \n      expect(extractHeadings(content)).toEqual([\n        { nodeKey: 'key1', text: 'Real heading', level: 1, depth: 0 },\n        { nodeKey: 'key3', text: 'Another real heading', level: 2, depth: 1 },\n      ]);\n    });\n  });\n\n  describe('edge cases', () =\u003e {\n    it('skips headings without __key', () =\u003e {\n      const content = createContent([\n        createHeading('h1', 'Has key', 'key1'),\n        { type: 'heading', tag: 'h2', children: [{ type: 'text', text: 'No key' }] },\n      ]);\n      \n      expect(extractHeadings(content)).toEqual([\n        { nodeKey: 'key1', text: 'Has key', level: 1, depth: 0 },\n      ]);\n    });\n\n    it('skips headings without tag property', () =\u003e {\n      const content = createContent([\n        createHeading('h1', 'Has tag', 'key1'),\n        { type: 'heading', __key: 'key2', children: [{ type: 'text', text: 'No tag' }] },\n      ]);\n      \n      expect(extractHeadings(content)).toEqual([\n        { nodeKey: 'key1', text: 'Has tag', level: 1, depth: 0 },\n      ]);\n    });\n\n    it('handles empty heading text', () =\u003e {\n      const content = createContent([\n        createHeading('h1', '', 'key1'),\n      ]);\n      \n      expect(extractHeadings(content)).toEqual([\n        { nodeKey: 'key1', text: '', level: 1, depth: 0 },\n      ]);\n    });\n\n    it('handles heading with only whitespace', () =\u003e {\n      const content = createContent([\n        createHeading('h1', '   ', 'key1'),\n      ]);\n      \n      expect(extractHeadings(content)).toEqual([\n        { nodeKey: 'key1', text: '   ', level: 1, depth: 0 },\n      ]);\n    });\n  });\n\n  describe('mixed content', () =\u003e {\n    it('extracts headings interspersed with other content', () =\u003e {\n      const content = createContent([\n        { type: 'paragraph', children: [{ type: 'text', text: 'Intro' }] },\n        createHeading('h1', 'Title', 'key1'),\n        { type: 'paragraph', children: [{ type: 'text', text: 'Content' }] },\n        { type: 'list', children: [{ type: 'listitem', children: [] }] },\n        createHeading('h2', 'Section', 'key2'),\n      ]);\n      \n      expect(extractHeadings(content)).toEqual([\n        { nodeKey: 'key1', text: 'Title', level: 1, depth: 0 },\n        { nodeKey: 'key2', text: 'Section', level: 2, depth: 1 },\n      ]);\n    });\n  });\n});\n```\n\n### Files to Create\n\n- `packages/shared/src/heading-extractor.test.ts`\n\n### Running Tests\n\n```bash\n# Run just this test file\ncd packages/shared \u0026\u0026 bun test heading-extractor\n\n# Run with coverage\nbun test --coverage\n```\n\n### Definition of Done\n\n- [ ] All test cases implemented\n- [ ] Tests pass\n- [ ] Coverage \u003e 95% for heading-extractor.ts\n- [ ] Edge cases documented in test descriptions","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-22T19:09:07.761938-06:00","updated_at":"2025-12-22T19:21:58.320503-06:00","closed_at":"2025-12-22T19:21:58.320503-06:00","dependencies":[{"issue_id":"scribe-pzw.10","depends_on_id":"scribe-pzw","type":"parent-child","created_at":"2025-12-22T19:09:07.762319-06:00","created_by":"daemon"},{"issue_id":"scribe-pzw.10","depends_on_id":"scribe-pzw.1","type":"blocks","created_at":"2025-12-22T19:16:54.797404-06:00","created_by":"daemon"}]}
{"id":"scribe-pzw.11","title":"Write unit tests for EditorCommandContext","description":"## Task: Write unit tests for EditorCommandContext\n\n### Purpose\nUnit tests for the EditorCommandContext to ensure proper context behavior, error handling, and command dispatch.\n\n### Dependencies\n- scribe-pzw.2 (EditorCommandContext) - Need the context to test\n\n### Test File Location\n\n`apps/desktop/renderer/src/components/Editor/EditorCommandContext.test.tsx`\n\n### Test Cases\n\n```typescript\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { render, renderHook, act } from '@testing-library/react';\nimport { \n  EditorCommandProvider, \n  useEditorCommand, \n  useEditorCommandSetter \n} from './EditorCommandContext';\nimport { FOCUS_NODE_COMMAND } from './plugins/FocusNodePlugin';\n\n// Mock Lexical editor\nconst mockDispatchCommand = vi.fn();\nconst createMockEditor = () =\u003e ({\n  dispatchCommand: mockDispatchCommand,\n  // Add other required LexicalEditor methods as needed\n});\n\ndescribe('EditorCommandContext', () =\u003e {\n  beforeEach(() =\u003e {\n    vi.clearAllMocks();\n  });\n\n  describe('useEditorCommand outside provider', () =\u003e {\n    it('throws error when used outside EditorCommandProvider', () =\u003e {\n      // Suppress console.error for expected error\n      const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() =\u003e {});\n      \n      expect(() =\u003e {\n        renderHook(() =\u003e useEditorCommand());\n      }).toThrow('useEditorCommand must be used within EditorCommandProvider');\n      \n      consoleSpy.mockRestore();\n    });\n  });\n\n  describe('useEditorCommandSetter outside provider', () =\u003e {\n    it('throws error when used outside EditorCommandProvider', () =\u003e {\n      const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() =\u003e {});\n      \n      expect(() =\u003e {\n        renderHook(() =\u003e useEditorCommandSetter());\n      }).toThrow();\n      \n      consoleSpy.mockRestore();\n    });\n  });\n\n  describe('focusNode without editor', () =\u003e {\n    it('logs warning and does not throw when editor is null', () =\u003e {\n      const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() =\u003e {});\n      \n      const { result } = renderHook(() =\u003e useEditorCommand(), {\n        wrapper: EditorCommandProvider,\n      });\n      \n      // Should not throw\n      expect(() =\u003e {\n        result.current.focusNode('some-key');\n      }).not.toThrow();\n      \n      expect(consoleSpy).toHaveBeenCalledWith(\n        expect.stringContaining('no editor available')\n      );\n      \n      consoleSpy.mockRestore();\n    });\n  });\n\n  describe('focusNode with editor', () =\u003e {\n    it('dispatches FOCUS_NODE_COMMAND with correct payload', () =\u003e {\n      const mockEditor = createMockEditor();\n      \n      const TestComponent = () =\u003e {\n        const { focusNode } = useEditorCommand();\n        const { setEditor } = useEditorCommandSetter();\n        \n        // Set editor on mount\n        React.useEffect(() =\u003e {\n          setEditor(mockEditor as any);\n        }, []);\n        \n        return (\n          \u003cbutton onClick={() =\u003e focusNode('node-123')}\u003e\n            Focus\n          \u003c/button\u003e\n        );\n      };\n      \n      const { getByText } = render(\n        \u003cEditorCommandProvider\u003e\n          \u003cTestComponent /\u003e\n        \u003c/EditorCommandProvider\u003e\n      );\n      \n      act(() =\u003e {\n        getByText('Focus').click();\n      });\n      \n      expect(mockDispatchCommand).toHaveBeenCalledWith(\n        FOCUS_NODE_COMMAND,\n        { nodeKey: 'node-123' }\n      );\n    });\n  });\n\n  describe('editor lifecycle', () =\u003e {\n    it('handles editor being set then cleared', () =\u003e {\n      const mockEditor = createMockEditor();\n      \n      const { result: commandResult } = renderHook(() =\u003e useEditorCommand(), {\n        wrapper: EditorCommandProvider,\n      });\n      \n      const { result: setterResult } = renderHook(() =\u003e useEditorCommandSetter(), {\n        wrapper: ({ children }) =\u003e (\n          \u003cEditorCommandProvider\u003e{children}\u003c/EditorCommandProvider\u003e\n        ),\n      });\n      \n      // Set editor\n      act(() =\u003e {\n        setterResult.current.setEditor(mockEditor as any);\n      });\n      \n      // focusNode should work\n      act(() =\u003e {\n        commandResult.current.focusNode('key1');\n      });\n      expect(mockDispatchCommand).toHaveBeenCalled();\n      \n      // Clear editor\n      mockDispatchCommand.mockClear();\n      act(() =\u003e {\n        setterResult.current.setEditor(null);\n      });\n      \n      // focusNode should gracefully no-op\n      const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() =\u003e {});\n      act(() =\u003e {\n        commandResult.current.focusNode('key2');\n      });\n      expect(mockDispatchCommand).not.toHaveBeenCalled();\n      expect(consoleSpy).toHaveBeenCalled();\n      consoleSpy.mockRestore();\n    });\n  });\n\n  describe('context value stability', () =\u003e {\n    it('focusNode function is stable across re-renders when editor unchanged', () =\u003e {\n      const { result, rerender } = renderHook(() =\u003e useEditorCommand(), {\n        wrapper: EditorCommandProvider,\n      });\n      \n      const firstFocusNode = result.current.focusNode;\n      \n      rerender();\n      \n      expect(result.current.focusNode).toBe(firstFocusNode);\n    });\n\n    it('focusNode function updates when editor changes', () =\u003e {\n      const mockEditor1 = createMockEditor();\n      const mockEditor2 = createMockEditor();\n      \n      let setEditorFn: (editor: any) =\u003e void;\n      \n      const CaptureSetEditor = () =\u003e {\n        const { setEditor } = useEditorCommandSetter();\n        setEditorFn = setEditor;\n        return null;\n      };\n      \n      const { result, rerender } = renderHook(() =\u003e useEditorCommand(), {\n        wrapper: ({ children }) =\u003e (\n          \u003cEditorCommandProvider\u003e\n            \u003cCaptureSetEditor /\u003e\n            {children}\n          \u003c/EditorCommandProvider\u003e\n        ),\n      });\n      \n      const firstFocusNode = result.current.focusNode;\n      \n      act(() =\u003e {\n        setEditorFn(mockEditor1);\n      });\n      \n      const secondFocusNode = result.current.focusNode;\n      \n      // focusNode should be different because editor changed\n      expect(secondFocusNode).not.toBe(firstFocusNode);\n    });\n  });\n});\n```\n\n### Files to Create\n\n- `apps/desktop/renderer/src/components/Editor/EditorCommandContext.test.tsx`\n\n### Testing Patterns\n\n1. **Isolation**: Tests use `renderHook` for hook testing without full component tree\n2. **Mocking**: Mock LexicalEditor with just the methods we need\n3. **Error handling**: Use `vi.spyOn(console, 'error/warn')` to verify logging\n4. **Act wrapper**: Use `act()` for state updates\n\n### Running Tests\n\n```bash\n# From apps/desktop\nbun test EditorCommandContext\n```\n\n### Definition of Done\n\n- [ ] All test cases implemented\n- [ ] Tests pass\n- [ ] Error cases covered (outside provider, null editor)\n- [ ] Context value stability verified","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-22T19:09:07.841444-06:00","updated_at":"2025-12-22T19:22:19.724189-06:00","closed_at":"2025-12-22T19:22:19.724189-06:00","dependencies":[{"issue_id":"scribe-pzw.11","depends_on_id":"scribe-pzw","type":"parent-child","created_at":"2025-12-22T19:09:07.841775-06:00","created_by":"daemon"},{"issue_id":"scribe-pzw.11","depends_on_id":"scribe-pzw.2","type":"blocks","created_at":"2025-12-22T19:16:54.866982-06:00","created_by":"daemon"}]}
{"id":"scribe-pzw.12","title":"Write component tests for OutlineWidget","description":"## Task: Write component tests for OutlineWidget\n\n### Purpose\nComponent tests for OutlineWidget using React Testing Library to verify rendering, interaction, and accessibility.\n\n### Dependencies\n- scribe-pzw.5 (OutlineWidget) - Need the component to test\n\n### Test File Location\n\n`apps/desktop/renderer/src/components/ContextPanel/OutlineWidget.test.tsx`\n\n### Test Cases\n\n```typescript\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { render, screen, fireEvent, within } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { OutlineWidget } from './OutlineWidget';\nimport { EditorCommandProvider } from '../Editor/EditorCommandContext';\nimport type { Note, EditorContent } from '@scribe/shared';\n\n// Mock the EditorCommandContext\nconst mockFocusNode = vi.fn();\nvi.mock('../Editor/EditorCommandContext', () =\u003e ({\n  useEditorCommand: () =\u003e ({ focusNode: mockFocusNode }),\n  EditorCommandProvider: ({ children }: { children: React.ReactNode }) =\u003e children,\n}));\n\n// Helper to create mock note with content\nfunction createMockNote(headings: Array\u003c{ tag: string; text: string; key: string }\u003e): Note {\n  const children = headings.map(h =\u003e ({\n    type: 'heading',\n    tag: h.tag,\n    __key: h.key,\n    children: [{ type: 'text', text: h.text }],\n  }));\n  \n  return {\n    id: 'note-1',\n    title: 'Test Note',\n    content: {\n      root: {\n        type: 'root',\n        children,\n      },\n    },\n    tags: [],\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString(),\n  } as Note;\n}\n\ndescribe('OutlineWidget', () =\u003e {\n  beforeEach(() =\u003e {\n    vi.clearAllMocks();\n  });\n\n  describe('empty states', () =\u003e {\n    it('renders \"No headings\" when note is null', () =\u003e {\n      render(\u003cOutlineWidget note={null} /\u003e);\n      \n      expect(screen.getByText('No headings')).toBeInTheDocument();\n    });\n\n    it('renders \"No headings\" when note is undefined', () =\u003e {\n      render(\u003cOutlineWidget note={undefined} /\u003e);\n      \n      expect(screen.getByText('No headings')).toBeInTheDocument();\n    });\n\n    it('renders \"No headings\" when note has no headings', () =\u003e {\n      const note = {\n        ...createMockNote([]),\n        content: {\n          root: {\n            type: 'root',\n            children: [\n              { type: 'paragraph', children: [{ type: 'text', text: 'Hello' }] },\n            ],\n          },\n        },\n      } as Note;\n      \n      render(\u003cOutlineWidget note={note} /\u003e);\n      \n      expect(screen.getByText('No headings')).toBeInTheDocument();\n    });\n  });\n\n  describe('heading rendering', () =\u003e {\n    it('renders all headings with correct text', () =\u003e {\n      const note = createMockNote([\n        { tag: 'h1', text: 'Introduction', key: 'k1' },\n        { tag: 'h2', text: 'Background', key: 'k2' },\n        { tag: 'h3', text: 'Details', key: 'k3' },\n      ]);\n      \n      render(\u003cOutlineWidget note={note} /\u003e);\n      \n      expect(screen.getByText('Introduction')).toBeInTheDocument();\n      expect(screen.getByText('Background')).toBeInTheDocument();\n      expect(screen.getByText('Details')).toBeInTheDocument();\n    });\n\n    it('renders \"(empty heading)\" for headings with no text', () =\u003e {\n      const note = createMockNote([\n        { tag: 'h1', text: '', key: 'k1' },\n      ]);\n      \n      render(\u003cOutlineWidget note={note} /\u003e);\n      \n      expect(screen.getByText('(empty heading)')).toBeInTheDocument();\n    });\n\n    it('applies correct indentation based on depth', () =\u003e {\n      const note = createMockNote([\n        { tag: 'h1', text: 'Level 1', key: 'k1' },\n        { tag: 'h2', text: 'Level 2', key: 'k2' },\n        { tag: 'h3', text: 'Level 3', key: 'k3' },\n      ]);\n      \n      render(\u003cOutlineWidget note={note} /\u003e);\n      \n      const level1 = screen.getByText('Level 1');\n      const level2 = screen.getByText('Level 2');\n      const level3 = screen.getByText('Level 3');\n      \n      // Check padding-left values (8px base + depth * 12px)\n      expect(level1).toHaveStyle({ paddingLeft: '8px' });    // depth 0\n      expect(level2).toHaveStyle({ paddingLeft: '20px' });   // depth 1\n      expect(level3).toHaveStyle({ paddingLeft: '32px' });   // depth 2\n    });\n  });\n\n  describe('click interaction', () =\u003e {\n    it('calls focusNode with correct nodeKey on click', async () =\u003e {\n      const user = userEvent.setup();\n      const note = createMockNote([\n        { tag: 'h1', text: 'Click Me', key: 'target-key' },\n      ]);\n      \n      render(\u003cOutlineWidget note={note} /\u003e);\n      \n      await user.click(screen.getByText('Click Me'));\n      \n      expect(mockFocusNode).toHaveBeenCalledTimes(1);\n      expect(mockFocusNode).toHaveBeenCalledWith('target-key');\n    });\n  });\n\n  describe('keyboard interaction', () =\u003e {\n    it('triggers focusNode on Enter key', async () =\u003e {\n      const user = userEvent.setup();\n      const note = createMockNote([\n        { tag: 'h1', text: 'Press Enter', key: 'enter-key' },\n      ]);\n      \n      render(\u003cOutlineWidget note={note} /\u003e);\n      \n      const item = screen.getByText('Press Enter');\n      item.focus();\n      await user.keyboard('{Enter}');\n      \n      expect(mockFocusNode).toHaveBeenCalledWith('enter-key');\n    });\n\n    it('triggers focusNode on Space key', async () =\u003e {\n      const user = userEvent.setup();\n      const note = createMockNote([\n        { tag: 'h1', text: 'Press Space', key: 'space-key' },\n      ]);\n      \n      render(\u003cOutlineWidget note={note} /\u003e);\n      \n      const item = screen.getByText('Press Space');\n      item.focus();\n      await user.keyboard(' ');\n      \n      expect(mockFocusNode).toHaveBeenCalledWith('space-key');\n    });\n\n    it('does not trigger on other keys', async () =\u003e {\n      const user = userEvent.setup();\n      const note = createMockNote([\n        { tag: 'h1', text: 'Other Key', key: 'other-key' },\n      ]);\n      \n      render(\u003cOutlineWidget note={note} /\u003e);\n      \n      const item = screen.getByText('Other Key');\n      item.focus();\n      await user.keyboard('{Tab}');\n      \n      expect(mockFocusNode).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('expand/collapse', () =\u003e {\n    it('shows only first 5 headings when collapsed', () =\u003e {\n      const headings = Array.from({ length: 8 }, (_, i) =\u003e ({\n        tag: 'h1' as const,\n        text: `Heading ${i + 1}`,\n        key: `k${i + 1}`,\n      }));\n      const note = createMockNote(headings);\n      \n      render(\u003cOutlineWidget note={note} /\u003e);\n      \n      // First 5 visible\n      expect(screen.getByText('Heading 1')).toBeInTheDocument();\n      expect(screen.getByText('Heading 5')).toBeInTheDocument();\n      \n      // 6-8 not visible\n      expect(screen.queryByText('Heading 6')).not.toBeInTheDocument();\n      expect(screen.queryByText('Heading 8')).not.toBeInTheDocument();\n    });\n\n    it('shows expand button with correct count', () =\u003e {\n      const headings = Array.from({ length: 8 }, (_, i) =\u003e ({\n        tag: 'h1' as const,\n        text: `Heading ${i + 1}`,\n        key: `k${i + 1}`,\n      }));\n      const note = createMockNote(headings);\n      \n      render(\u003cOutlineWidget note={note} /\u003e);\n      \n      expect(screen.getByRole('button', { name: /show 3 more/i })).toBeInTheDocument();\n    });\n\n    it('shows all headings when expanded', async () =\u003e {\n      const user = userEvent.setup();\n      const headings = Array.from({ length: 8 }, (_, i) =\u003e ({\n        tag: 'h1' as const,\n        text: `Heading ${i + 1}`,\n        key: `k${i + 1}`,\n      }));\n      const note = createMockNote(headings);\n      \n      render(\u003cOutlineWidget note={note} /\u003e);\n      \n      await user.click(screen.getByRole('button', { name: /show 3 more/i }));\n      \n      // All headings visible\n      expect(screen.getByText('Heading 6')).toBeInTheDocument();\n      expect(screen.getByText('Heading 8')).toBeInTheDocument();\n      \n      // Button text changed\n      expect(screen.getByRole('button', { name: /show less/i })).toBeInTheDocument();\n    });\n\n    it('does not show expand button when \u003c= 5 headings', () =\u003e {\n      const note = createMockNote([\n        { tag: 'h1', text: 'Heading 1', key: 'k1' },\n        { tag: 'h2', text: 'Heading 2', key: 'k2' },\n      ]);\n      \n      render(\u003cOutlineWidget note={note} /\u003e);\n      \n      expect(screen.queryByRole('button', { name: /show.*more/i })).not.toBeInTheDocument();\n    });\n  });\n\n  describe('accessibility', () =\u003e {\n    it('has navigation landmark with label', () =\u003e {\n      const note = createMockNote([\n        { tag: 'h1', text: 'Heading', key: 'k1' },\n      ]);\n      \n      render(\u003cOutlineWidget note={note} /\u003e);\n      \n      expect(screen.getByRole('navigation', { name: 'Document outline' })).toBeInTheDocument();\n    });\n\n    it('heading items have role=\"button\" and are focusable', () =\u003e {\n      const note = createMockNote([\n        { tag: 'h1', text: 'Focusable', key: 'k1' },\n      ]);\n      \n      render(\u003cOutlineWidget note={note} /\u003e);\n      \n      const item = screen.getByRole('button', { name: /heading level 1: focusable/i });\n      expect(item).toHaveAttribute('tabIndex', '0');\n    });\n\n    it('expand button has aria-expanded attribute', async () =\u003e {\n      const user = userEvent.setup();\n      const headings = Array.from({ length: 8 }, (_, i) =\u003e ({\n        tag: 'h1' as const,\n        text: `Heading ${i + 1}`,\n        key: `k${i + 1}`,\n      }));\n      const note = createMockNote(headings);\n      \n      render(\u003cOutlineWidget note={note} /\u003e);\n      \n      const button = screen.getByRole('button', { name: /show 3 more/i });\n      expect(button).toHaveAttribute('aria-expanded', 'false');\n      \n      await user.click(button);\n      \n      expect(screen.getByRole('button', { name: /show less/i }))\n        .toHaveAttribute('aria-expanded', 'true');\n    });\n  });\n\n  describe('updates on content change', () =\u003e {\n    it('re-renders when note content changes', () =\u003e {\n      const note1 = createMockNote([\n        { tag: 'h1', text: 'Original', key: 'k1' },\n      ]);\n      const note2 = createMockNote([\n        { tag: 'h1', text: 'Updated', key: 'k1' },\n      ]);\n      \n      const { rerender } = render(\u003cOutlineWidget note={note1} /\u003e);\n      \n      expect(screen.getByText('Original')).toBeInTheDocument();\n      \n      rerender(\u003cOutlineWidget note={note2} /\u003e);\n      \n      expect(screen.queryByText('Original')).not.toBeInTheDocument();\n      expect(screen.getByText('Updated')).toBeInTheDocument();\n    });\n  });\n});\n```\n\n### Files to Create\n\n- `apps/desktop/renderer/src/components/ContextPanel/OutlineWidget.test.tsx`\n\n### Testing Patterns\n\n1. **Mock the context**: Avoid full context setup by mocking `useEditorCommand`\n2. **User events**: Use `@testing-library/user-event` for realistic interactions\n3. **Accessibility**: Verify ARIA attributes and roles\n4. **Style assertions**: Check computed styles for indentation\n\n### Running Tests\n\n```bash\n# From apps/desktop\nbun test OutlineWidget\n```\n\n### Definition of Done\n\n- [ ] All test cases implemented\n- [ ] Tests pass\n- [ ] Good coverage of rendering, interaction, accessibility\n- [ ] Edge cases covered (null note, empty headings, expand/collapse)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-22T19:09:07.921425-06:00","updated_at":"2025-12-22T19:21:59.303783-06:00","closed_at":"2025-12-22T19:21:59.303783-06:00","dependencies":[{"issue_id":"scribe-pzw.12","depends_on_id":"scribe-pzw","type":"parent-child","created_at":"2025-12-22T19:09:07.921859-06:00","created_by":"daemon"},{"issue_id":"scribe-pzw.12","depends_on_id":"scribe-pzw.5","type":"blocks","created_at":"2025-12-22T19:16:54.927731-06:00","created_by":"daemon"}]}
{"id":"scribe-pzw.13","title":"Write integration tests for outline navigation","description":"## Task: Write integration tests for outline navigation\n\n### Purpose\nEnd-to-end integration tests that verify the complete flow from clicking an outline item to the editor scrolling to and highlighting the heading.\n\n### Dependencies\n- scribe-pzw.9 (App provider wrapping) - Need complete integration in place\n\n### Test File Location\n\n`apps/desktop/outline.integration.test.ts`\n\n### Test Scenarios\n\n1. **Outline appears in context panel**\n   - Shows outline widget for note with headings\n   - Shows empty state for note without headings\n\n2. **Click navigation**\n   - Scrolls editor to heading and highlights it\n   - Places cursor at beginning of heading\n   - Highlight fades after 1.5s\n\n3. **Content updates**\n   - Outline updates when heading is added\n   - Outline updates when heading is removed\n   - Outline updates when heading text changes\n\n4. **Keyboard navigation**\n   - Tab through outline items\n   - Enter/Space activates navigation\n   - Focus moves correctly\n\n### Testing Infrastructure Notes\n\nUses existing test utilities:\n- `setupIntegrationTest()` - Bootstraps the app in test mode\n- `createTestNote()` - Creates a note via the storage API\n- `getContextPanel()` / `getEditor()` - DOM query helpers\n- `waitForElement()` - Waits for element to appear\n\n### Definition of Done\n\n- [ ] Integration test file created\n- [ ] Tests cover: rendering, click navigation, scroll behavior, keyboard nav\n- [ ] All tests pass\n- [ ] Tests run in CI","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-22T19:09:08.002079-06:00","updated_at":"2025-12-22T19:22:32.209296-06:00","dependencies":[{"issue_id":"scribe-pzw.13","depends_on_id":"scribe-pzw","type":"parent-child","created_at":"2025-12-22T19:09:08.002425-06:00","created_by":"daemon"},{"issue_id":"scribe-pzw.13","depends_on_id":"scribe-pzw.9","type":"blocks","created_at":"2025-12-22T19:16:54.98432-06:00","created_by":"daemon"}]}
{"id":"scribe-pzw.14","title":"Final cleanup, documentation, and PR preparation","description":"## Task: Final cleanup, documentation, and PR preparation\n\n### Purpose\nFinal polish, documentation updates, and preparation for pull request submission.\n\n### Dependencies\n- scribe-pzw.13 (integration tests) - All implementation and tests must pass first\n\n### Checklist\n\n#### Code Quality\n- [ ] Run full lint: `bun lint` passes\n- [ ] Run type check: `bun typecheck` passes  \n- [ ] Run all tests: `bun test` passes\n- [ ] No `console.log` statements left in code (except intentional logging via `createLogger`)\n- [ ] All `TODO` comments addressed or converted to GitHub issues\n\n#### Documentation\n- [ ] JSDoc comments on all public exports\n- [ ] Update `CHANGELOG.md` with feature entry\n- [ ] Verify `README.md` doesn't need updates (likely not)\n\n#### Code Review Preparation\n- [ ] Self-review all changed files\n- [ ] Verify no unintended changes\n- [ ] Check for consistent code style\n- [ ] Ensure imports are organized\n\n#### PR Preparation\n- [ ] Create feature branch: `git checkout -b feature/outline-widget`\n- [ ] Stage all relevant files\n- [ ] Commit with descriptive message referencing issue:\n  ```\n  feat(context-panel): add Outline widget for in-note heading navigation\n\n  - Add heading-extractor utility in packages/shared\n  - Create EditorCommandContext for cross-component command dispatch\n  - Implement OutlineWidget component with expand/collapse\n  - Wire up context panel rendering and template registry\n  - Add comprehensive unit and integration tests\n\n  Closes #47\n  ```\n- [ ] Push branch and create PR\n\n#### PR Description Template\n\n```markdown\n## Summary\n\nAdds an Outline widget to the Context Panel that provides a table-of-contents view of headings in the current note. Clicking any heading scrolls the editor to that location with a brief highlight effect.\n\n## Changes\n\n### New Files\n- `packages/shared/src/heading-extractor.ts` - Utility to extract headings from EditorContent\n- `apps/desktop/renderer/src/components/Editor/EditorCommandContext.tsx` - Cross-component command dispatch\n- `apps/desktop/renderer/src/components/ContextPanel/OutlineWidget.tsx` - The widget component\n\n### Modified Files\n- `templates/types.ts` - Added 'outline' section type\n- `templates/registry.ts` - Added outline to default sections\n- `ContextPanel.tsx` - Render OutlineWidget\n- `ContextPanel.css.ts` - Added outline styles\n- `EditorRoot.tsx` - Added EditorCommandBridge plugin\n- `App.tsx` - Wrapped with EditorCommandProvider\n\n## Testing\n\n- Unit tests for heading-extractor (15 cases)\n- Unit tests for EditorCommandContext (8 cases)\n- Component tests for OutlineWidget (18 cases)\n- Integration tests for full navigation flow (6 cases)\n\n## Screenshots\n\n[Add before/after screenshots of Context Panel with Outline widget]\n\n## Accessibility\n\n- Keyboard navigation (Tab, Enter, Space)\n- ARIA labels with heading levels\n- Focus-visible states\n- Screen reader compatible\n\n## Future Enhancements (out of scope)\n\n- Scroll spy (highlight active heading based on scroll position)\n- Heading level badges (H1, H2 indicators)\n- Drag-to-reorder sections via outline\n- Collapsible nested sections\n\nCloses #47\n```\n\n### Files to Review\n\nAll files created/modified in this epic:\n- `packages/shared/src/heading-extractor.ts`\n- `packages/shared/src/heading-extractor.test.ts`\n- `packages/shared/src/index.ts`\n- `apps/desktop/renderer/src/components/Editor/EditorCommandContext.tsx`\n- `apps/desktop/renderer/src/components/Editor/EditorCommandContext.test.tsx`\n- `apps/desktop/renderer/src/components/Editor/EditorRoot.tsx`\n- `apps/desktop/renderer/src/components/ContextPanel/OutlineWidget.tsx`\n- `apps/desktop/renderer/src/components/ContextPanel/OutlineWidget.test.tsx`\n- `apps/desktop/renderer/src/components/ContextPanel/ContextPanel.tsx`\n- `apps/desktop/renderer/src/components/ContextPanel/ContextPanel.css.ts`\n- `apps/desktop/renderer/src/templates/types.ts`\n- `apps/desktop/renderer/src/templates/registry.ts`\n- `apps/desktop/renderer/src/App.tsx`\n- `apps/desktop/outline.integration.test.ts`\n\n### Definition of Done\n\n- [ ] All checks pass\n- [ ] PR created with full description\n- [ ] Screenshots added\n- [ ] Ready for code review","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-22T19:09:08.082147-06:00","updated_at":"2025-12-22T19:16:37.022565-06:00","dependencies":[{"issue_id":"scribe-pzw.14","depends_on_id":"scribe-pzw","type":"parent-child","created_at":"2025-12-22T19:09:08.082493-06:00","created_by":"daemon"},{"issue_id":"scribe-pzw.14","depends_on_id":"scribe-pzw.13","type":"blocks","created_at":"2025-12-22T19:16:58.901016-06:00","created_by":"daemon"}]}
{"id":"scribe-pzw.2","title":"Create EditorCommandContext for cross-component command dispatch","description":"## Task: Create EditorCommandContext for cross-component command dispatch\n\n### Purpose\nCreate a React context that allows the ContextPanel (and its widgets) to dispatch commands to the Lexical editor. This bridges the gap between the EditorRoot and ContextPanel which are siblings in the React tree.\n\n### The Problem\n\nCurrent architecture (in App.tsx):\n```tsx\n\u003cdiv className={styles.mainContent}\u003e\n  \u003cWikiLinkProvider\u003e\n    \u003cPersonMentionProvider\u003e\n      \u003cEditorRoot noteState={noteState} /\u003e  {/* Has Lexical editor */}\n    \u003c/PersonMentionProvider\u003e\n  \u003c/WikiLinkProvider\u003e\n\u003c/div\u003e\n\u003cContextPanel ... /\u003e  {/* Sibling - NO access to editor! */}\n```\n\nThe OutlineWidget needs to call `editor.dispatchCommand(FOCUS_NODE_COMMAND, { nodeKey })` but it's in ContextPanel which has no access to the Lexical editor instance.\n\n### Solution\n\nCreate a shared context with a two-context pattern (public consumer + internal setter).\n\n### Files to Create\n\n- `apps/desktop/renderer/src/components/Editor/EditorCommandContext.tsx`\n\n### Implementation\n\n```typescript\nimport { createContext, useContext, useState, useMemo, type ReactNode } from 'react';\nimport type { LexicalEditor } from 'lexical';\nimport { FOCUS_NODE_COMMAND } from './plugins/FocusNodePlugin';\n\ninterface EditorCommandContextValue {\n  focusNode: (nodeKey: string) =\u003e void;\n}\n\ninterface EditorCommandSetterValue {\n  setEditor: (editor: LexicalEditor | null) =\u003e void;\n}\n\nconst EditorCommandContext = createContext\u003cEditorCommandContextValue | null\u003e(null);\nconst EditorCommandSetterContext = createContext\u003cEditorCommandSetterValue | null\u003e(null);\n\nexport function EditorCommandProvider({ children }: { children: ReactNode }) {\n  const [editor, setEditor] = useState\u003cLexicalEditor | null\u003e(null);\n\n  const commandValue = useMemo\u003cEditorCommandContextValue\u003e(() =\u003e ({\n    focusNode: (nodeKey: string) =\u003e {\n      if (!editor) {\n        console.warn('EditorCommandContext: no editor available');\n        return;\n      }\n      editor.dispatchCommand(FOCUS_NODE_COMMAND, { nodeKey });\n    },\n  }), [editor]);\n\n  const setterValue = useMemo(() =\u003e ({ setEditor }), []);\n\n  return (\n    \u003cEditorCommandSetterContext.Provider value={setterValue}\u003e\n      \u003cEditorCommandContext.Provider value={commandValue}\u003e\n        {children}\n      \u003c/EditorCommandContext.Provider\u003e\n    \u003c/EditorCommandSetterContext.Provider\u003e\n  );\n}\n\nexport function useEditorCommand(): EditorCommandContextValue {\n  const context = useContext(EditorCommandContext);\n  if (!context) {\n    throw new Error('useEditorCommand must be used within EditorCommandProvider');\n  }\n  return context;\n}\n\nexport function useEditorCommandSetter(): EditorCommandSetterValue {\n  const context = useContext(EditorCommandSetterContext);\n  if (!context) {\n    throw new Error('useEditorCommandSetter must be used within EditorCommandProvider');\n  }\n  return context;\n}\n```\n\n### Testing Notes\n\nUnit tests should be included in this task. Create:\n- `apps/desktop/renderer/src/components/Editor/EditorCommandContext.test.tsx`\n\nTests should cover:\n- `useEditorCommand` throws when outside provider\n- `focusNode` dispatches command when editor is set\n- `focusNode` no-ops gracefully when editor is null\n- Context value is stable across re-renders (memoization)\n\n### Definition of Done\n\n- [ ] `EditorCommandProvider` implemented\n- [ ] `useEditorCommand` hook implemented\n- [ ] `useEditorCommandSetter` hook implemented (internal)\n- [ ] Unit tests written and passing\n- [ ] Proper error handling and console warnings\n- [ ] JSDoc documentation complete\n- [ ] TypeScript compiles without errors","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T19:09:07.132688-06:00","updated_at":"2025-12-22T19:34:07.890319-06:00","closed_at":"2025-12-22T19:34:07.890319-06:00","dependencies":[{"issue_id":"scribe-pzw.2","depends_on_id":"scribe-pzw","type":"parent-child","created_at":"2025-12-22T19:09:07.133047-06:00","created_by":"daemon"}]}
{"id":"scribe-pzw.3","title":"Extend ContextPanelSection type to include 'outline'","description":"## Task: Extend ContextPanelSection type to include 'outline'\n\n### Purpose\nAdd the 'outline' section type to the TypeScript union type that defines all possible ContextPanel sections. This enables type-safe configuration of the outline widget in templates.\n\n### Current State\n\n```typescript\n// apps/desktop/renderer/src/templates/types.ts (lines 46-51)\nexport type ContextPanelSection =\n  | { type: 'linked-mentions'; includeByDate?: boolean }\n  | { type: 'attendees' }\n  | { type: 'tasks'; placeholder?: boolean }\n  | { type: 'references' }\n  | { type: 'calendar' };\n```\n\n### Target State\n\n```typescript\nexport type ContextPanelSection =\n  | { type: 'linked-mentions'; includeByDate?: boolean }\n  | { type: 'attendees' }\n  | { type: 'tasks'; placeholder?: boolean }\n  | { type: 'references' }\n  | { type: 'calendar' }\n  | { type: 'outline' };  // NEW\n```\n\n### Implementation Details\n\n1. **Simple type extension**: Just add `| { type: 'outline' }` to the union\n2. **No additional properties needed initially**: The outline widget will read from `note.content` directly\n3. **Future extensibility**: Could later add options like `{ type: 'outline'; maxDepth?: number; showLevelBadges?: boolean }`\n\n### Why This is a Separate Task\n\n- Clean dependency chain: Types must exist before styles/components reference them\n- Enables parallel work: Once types are in, styles and registry can proceed independently\n- Type safety: TypeScript will now enforce exhaustive handling in `renderSection` switch\n\n### Files to Modify\n\n- `apps/desktop/renderer/src/templates/types.ts`\n\n### Testing Notes\n\n- No runtime tests needed (compile-time type checking)\n- After this change, `ContextPanel.tsx` will show a TypeScript error in the `renderSection` switch until we add the 'outline' case (scribe-pzw.7)\n\n### Definition of Done\n\n- [ ] Added `| { type: 'outline' }` to `ContextPanelSection` union\n- [ ] TypeScript compiles without errors\n- [ ] (Expected) TypeScript shows \"not exhaustive\" warning in ContextPanel until scribe-pzw.7 is done","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T19:09:07.212132-06:00","updated_at":"2025-12-22T19:35:38.309175-06:00","closed_at":"2025-12-22T19:35:38.309175-06:00","dependencies":[{"issue_id":"scribe-pzw.3","depends_on_id":"scribe-pzw","type":"parent-child","created_at":"2025-12-22T19:09:07.212531-06:00","created_by":"daemon"}]}
{"id":"scribe-pzw.4","title":"Add OutlineWidget styles to ContextPanel.css.ts","description":"## Task: Add OutlineWidget styles to ContextPanel.css.ts\n\n### Purpose\nAdd vanilla-extract styles for the OutlineWidget component, following existing widget patterns in the codebase.\n\n### Dependencies\n- scribe-pzw.3 (type extension) - Need `ContextPanelSection` type to reference 'outline'\n\n### Existing Patterns to Follow\n\nFrom `ContextPanel.css.ts`, we already have:\n- `backlinkList` / `backlinkItem` - Clickable list item pattern\n- `taskItem` / `taskText` - Content item styling  \n- `expandButton` - Expand/collapse toggle\n- `emptyState` - No content message\n- `card` / `cardHeader` / `cardIcon` / `cardTitle` - Widget container structure\n\n### Styles to Add\n\n```typescript\n// apps/desktop/renderer/src/components/ContextPanel/ContextPanel.css.ts\n\n/**\n * Outline list container\n * Unstyled list for outline items, similar to backlinkList\n */\nexport const outlineList = style({\n  listStyle: 'none',\n  margin: 0,\n  padding: 0,\n  display: 'flex',\n  flexDirection: 'column',\n});\n\n/**\n * Individual outline item\n * Clickable with hover state, truncation for long headings\n */\nexport const outlineItem = style({\n  display: 'block',\n  padding: `${vars.spacing['1']} ${vars.spacing['2']}`,\n  fontSize: vars.typography.size.sm,\n  color: vars.color.foreground,\n  cursor: 'pointer',\n  borderRadius: vars.radius.sm,\n  overflow: 'hidden',\n  textOverflow: 'ellipsis',\n  whiteSpace: 'nowrap',\n  transition: `background-color ${vars.animation.duration.fast} ${vars.animation.easing.default}`,\n\n  ':hover': {\n    backgroundColor: vars.color.surface,\n  },\n\n  ':focus': {\n    outline: 'none',\n  },\n\n  ':focus-visible': {\n    outline: `2px solid ${vars.color.accent}`,\n    outlineOffset: '-2px',\n  },\n});\n\n/**\n * Scrollable container for expanded outline (many headings)\n * Similar to taskListScrollable\n */\nexport const outlineListScrollable = style({\n  maxHeight: '280px',\n  overflowY: 'auto',\n  overflowX: 'hidden',\n  marginRight: `calc(-1 * ${vars.spacing['2']})`,\n  paddingRight: vars.spacing['2'],\n\n  // Custom scrollbar styling (matching taskListScrollable)\n  '::-webkit-scrollbar': {\n    width: '4px',\n  },\n  '::-webkit-scrollbar-track': {\n    background: 'transparent',\n  },\n  '::-webkit-scrollbar-thumb': {\n    backgroundColor: vars.color.border,\n    borderRadius: vars.radius.full,\n  },\n  selectors: {\n    '\u0026::-webkit-scrollbar-thumb:hover': {\n      backgroundColor: vars.color.foregroundMuted,\n    },\n  },\n});\n```\n\n### Design Considerations\n\n1. **Indentation**: Handled via inline `paddingLeft` style in component, not here\n   - `style={{ paddingLeft: `${depth * 12}px` }}`\n   - Maximum indent: 5 levels √ó 12px = 60px\n\n2. **Typography**: Uses `vars.typography.size.sm` (same as task items)\n   - Not too small to read, not too large for dense information\n\n3. **Interaction**: \n   - Hover background matches other clickable items\n   - Focus-visible for keyboard navigation accessibility\n   - No active state needed (navigation happens immediately)\n\n4. **Scrolling**: Matches `taskListScrollable` pattern for consistency\n\n### Files to Modify\n\n- `apps/desktop/renderer/src/components/ContextPanel/ContextPanel.css.ts`\n\n### Testing Notes\n\n- Visual testing: Verify styles look correct with various heading depths\n- Accessibility: Verify focus states are visible\n\n### Definition of Done\n\n- [ ] `outlineList` style added\n- [ ] `outlineItem` style added with hover/focus states\n- [ ] `outlineListScrollable` style added\n- [ ] Styles match existing widget patterns\n- [ ] TypeScript compiles without errors","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-22T19:09:07.290852-06:00","updated_at":"2025-12-22T19:10:51.378788-06:00","dependencies":[{"issue_id":"scribe-pzw.4","depends_on_id":"scribe-pzw","type":"parent-child","created_at":"2025-12-22T19:09:07.291243-06:00","created_by":"daemon"}]}
{"id":"scribe-pzw.5","title":"Create OutlineWidget component","description":"## Task: Create OutlineWidget component\n\n### Purpose\nCreate the main OutlineWidget React component that renders a table-of-contents view of headings from the current note and enables click-to-navigate functionality.\n\n### Dependencies\n- scribe-pzw.1 (heading-extractor) - For extracting headings from note content\n- scribe-pzw.2 (EditorCommandContext) - For dispatching focus commands to editor\n- scribe-pzw.4 (styles) - For styling the widget\n\n### Component Interface\n\n```typescript\n// apps/desktop/renderer/src/components/ContextPanel/OutlineWidget.tsx\n\nimport type { Note } from '@scribe/shared';\n\nexport interface OutlineWidgetProps {\n  /** Current note with content to extract headings from */\n  note?: Note | null;\n}\n\nexport function OutlineWidget({ note }: OutlineWidgetProps): JSX.Element;\n```\n\n### Key Implementation Details\n\n1. **Add data-testid**: The component MUST include `data-testid=\"outline-widget\"` on the root element for integration testing.\n\n2. **Use CSS classes for indentation**: Instead of inline styles, use CSS custom properties:\n   ```tsx\n   style={{ '--outline-depth': heading.depth } as React.CSSProperties}\n   ```\n   Then in CSS:\n   ```css\n   paddingLeft: calc(8px + var(--outline-depth) * 12px);\n   ```\n\n3. **Empty heading display**: Show \"(empty heading)\" for headings with empty text.\n\n4. **Expand/collapse**: Follow TasksWidget pattern with COLLAPSED_LIMIT = 5.\n\n5. **Accessibility**:\n   - `\u003cnav aria-label=\"Document outline\"\u003e` wrapper\n   - `role=\"button\"` + `tabIndex={0}` on items\n   - `aria-label` includes heading level: `Heading level {level}: {text}`\n   - `aria-expanded` on expand button\n\n### Files to Create\n\n- `apps/desktop/renderer/src/components/ContextPanel/OutlineWidget.tsx`\n\n### Testing Notes\n\nComponent tests should be included in this task. Create:\n- `apps/desktop/renderer/src/components/ContextPanel/OutlineWidget.test.tsx`\n\nTests should cover:\n- Renders empty state \"No headings\" when no headings\n- Renders heading list correctly with proper indentation\n- Click triggers focusNode with correct nodeKey\n- Keyboard navigation (Enter/Space)\n- Expand/collapse functionality\n- Handles null/undefined note\n\n### Definition of Done\n\n- [ ] Component renders correctly with headings\n- [ ] data-testid=\"outline-widget\" added\n- [ ] Empty state displays for notes without headings\n- [ ] Click navigation triggers focusNode\n- [ ] Keyboard navigation works (Enter/Space)\n- [ ] Expand/collapse works for \u003e5 headings\n- [ ] Accessibility attributes present\n- [ ] Component tests written and passing\n- [ ] JSDoc documentation complete\n- [ ] TypeScript compiles without errors","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-22T19:09:07.36914-06:00","updated_at":"2025-12-22T19:21:53.348637-06:00","dependencies":[{"issue_id":"scribe-pzw.5","depends_on_id":"scribe-pzw","type":"parent-child","created_at":"2025-12-22T19:09:07.369517-06:00","created_by":"daemon"},{"issue_id":"scribe-pzw.5","depends_on_id":"scribe-pzw.1","type":"blocks","created_at":"2025-12-22T19:16:44.644029-06:00","created_by":"daemon"},{"issue_id":"scribe-pzw.5","depends_on_id":"scribe-pzw.2","type":"blocks","created_at":"2025-12-22T19:16:44.707497-06:00","created_by":"daemon"},{"issue_id":"scribe-pzw.5","depends_on_id":"scribe-pzw.4","type":"blocks","created_at":"2025-12-22T19:16:44.76906-06:00","created_by":"daemon"}]}
{"id":"scribe-pzw.6","title":"Update defaultContextPanelSections in registry.ts","description":"## Task: Update defaultContextPanelSections in registry.ts\n\n### Purpose\nAdd the 'outline' section to the default context panel configuration so it appears for all notes that don't have a custom template.\n\n### Dependencies\n- scribe-pzw.3 (type extension) - Need 'outline' type to exist\n\n### Current State\n\n```typescript\n// apps/desktop/renderer/src/templates/registry.ts (lines 26-31)\nexport const defaultContextPanelSections: ContextPanelSection[] = [\n  { type: 'linked-mentions' },\n  { type: 'tasks', placeholder: true },\n  { type: 'references' },\n  { type: 'calendar' },\n];\n```\n\n### Target State\n\n```typescript\nexport const defaultContextPanelSections: ContextPanelSection[] = [\n  { type: 'outline' },        // NEW - at top for quick navigation\n  { type: 'linked-mentions' },\n  { type: 'tasks', placeholder: true },\n  { type: 'references' },\n  { type: 'calendar' },\n];\n```\n\n### Why Place Outline First?\n\n1. **Primary use case**: Outline is for in-note navigation, most useful when you first open a note\n2. **Immediate visibility**: Users working with long documents want quick access to structure\n3. **Complementary ordering**: \n   - Outline = navigate within THIS note\n   - Linked mentions = navigate TO other notes\n   - Tasks = cross-note task overview\n   - References = links FROM this note\n   - Calendar = temporal context\n\n### Alternative Consideration\n\nCould also place outline AFTER linked-mentions if we want to prioritize cross-note discovery over in-note navigation. However, the issue spec explicitly places it at the top. We can gather user feedback and adjust later.\n\n### Files to Modify\n\n- `apps/desktop/renderer/src/templates/registry.ts`\n\n### Impact on Templates\n\nThis only affects `defaultContextPanelSections`. Template-specific configurations (daily.ts, meeting.ts) are unchanged and won't automatically include outline. If we want outline in specific templates, those need separate updates (out of scope for this task).\n\nFuture consideration: Add outline to daily and meeting templates:\n```typescript\n// templates/daily.ts - future enhancement\ncontextPanelConfig: {\n  sections: [\n    { type: 'outline' },           // Quick navigation in daily journals\n    { type: 'linked-mentions', includeByDate: true },\n    { type: 'tasks' },\n    { type: 'calendar' },\n  ],\n},\n```\n\n### Testing Notes\n\n- After this change, opening any regular note should show Outline widget at top of ContextPanel\n- Template-based notes (daily, meeting) will NOT show outline (until templates are updated)\n\n### Definition of Done\n\n- [ ] Added `{ type: 'outline' }` as first item in `defaultContextPanelSections`\n- [ ] TypeScript compiles without errors\n- [ ] Manual testing: Outline appears in ContextPanel for regular notes","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-22T19:09:07.447549-06:00","updated_at":"2025-12-22T19:11:51.574383-06:00","dependencies":[{"issue_id":"scribe-pzw.6","depends_on_id":"scribe-pzw","type":"parent-child","created_at":"2025-12-22T19:09:07.447914-06:00","created_by":"daemon"},{"issue_id":"scribe-pzw.6","depends_on_id":"scribe-pzw.3","type":"blocks","created_at":"2025-12-22T19:16:44.827465-06:00","created_by":"daemon"}]}
{"id":"scribe-pzw.7","title":"Add OutlineWidget case to ContextPanel renderSection","description":"## Task: Add OutlineWidget case to ContextPanel renderSection\n\n### Purpose\nWire up the OutlineWidget component in the ContextPanel's `renderSection` switch statement so it renders when the section type is 'outline'.\n\n### Dependencies\n- scribe-pzw.5 (OutlineWidget component) - Need the component to import and render\n- scribe-pzw.6 (registry update) - Ensures outline appears in default sections\n\n### Current State\n\n```typescript\n// apps/desktop/renderer/src/components/ContextPanel/ContextPanel.tsx (lines 178-223)\nconst renderSection = (section: ContextPanelSection, index: number) =\u003e {\n  switch (section.type) {\n    case 'linked-mentions':\n      return \u003cLinkedMentions key={...} ... /\u003e;\n    case 'attendees':\n      return note?.type === 'meeting' ? \u003cAttendeesWidget key={...} ... /\u003e : null;\n    case 'tasks':\n      return \u003cTasksWidget key={...} ... /\u003e;\n    case 'references':\n      return note ? \u003cReferencesWidget key={...} ... /\u003e : null;\n    case 'calendar':\n      return \u003cCalendarWidget key={...} /\u003e;\n    default:\n      return null;\n  }\n};\n```\n\n### Changes Required\n\n1. **Add import** at top of file:\n```typescript\nimport { OutlineWidget } from './OutlineWidget';\n```\n\n2. **Add case** in `renderSection` switch (before default):\n```typescript\ncase 'outline':\n  // Only render if we have a note with content\n  if (note) {\n    return \u003cOutlineWidget key={`section-${index}`} note={note} /\u003e;\n  }\n  return null;\n```\n\n### Implementation Notes\n\n1. **Guard condition**: Only render when `note` is truthy (same pattern as ReferencesWidget)\n2. **Key prop**: Uses `section-${index}` pattern consistent with other widgets\n3. **Props**: Just passes `note` - OutlineWidget extracts content internally\n4. **No onNavigate needed**: OutlineWidget uses EditorCommandContext for in-note navigation\n\n### Comparison with Other Widgets\n\n| Widget | Renders when... | Uses onNavigate? |\n|--------|-----------------|------------------|\n| LinkedMentions | Always (handles empty state internally) | Yes (cross-note) |\n| AttendeesWidget | `note?.type === 'meeting'` | Yes (to person notes) |\n| TasksWidget | Always | Yes (to task source notes) |\n| ReferencesWidget | `note` truthy | Yes (to linked notes) |\n| CalendarWidget | Always | No |\n| **OutlineWidget** | `note` truthy | **No** (uses EditorCommandContext) |\n\n### TypeScript Exhaustiveness\n\nAfter adding this case, the switch statement will be exhaustive for `ContextPanelSection`. This means:\n- Adding a new section type will cause a TypeScript error\n- Forces developers to handle all section types\n\n### Files to Modify\n\n- `apps/desktop/renderer/src/components/ContextPanel/ContextPanel.tsx`\n  - Add import for OutlineWidget\n  - Add case in renderSection switch\n\n### Testing Notes\n\n- After this change + scribe-pzw.6, outline should render in ContextPanel\n- Verify it appears at correct position (first in list)\n- Verify it handles null note gracefully (no render)\n\n### Definition of Done\n\n- [ ] Import `OutlineWidget` added\n- [ ] Case `'outline'` added to switch with guard for null note\n- [ ] TypeScript compiles without errors (exhaustive switch)\n- [ ] OutlineWidget renders in correct position in ContextPanel","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-22T19:09:07.525965-06:00","updated_at":"2025-12-22T19:12:11.930501-06:00","dependencies":[{"issue_id":"scribe-pzw.7","depends_on_id":"scribe-pzw","type":"parent-child","created_at":"2025-12-22T19:09:07.526332-06:00","created_by":"daemon"},{"issue_id":"scribe-pzw.7","depends_on_id":"scribe-pzw.5","type":"blocks","created_at":"2025-12-22T19:16:50.101492-06:00","created_by":"daemon"},{"issue_id":"scribe-pzw.7","depends_on_id":"scribe-pzw.6","type":"blocks","created_at":"2025-12-22T19:16:50.151305-06:00","created_by":"daemon"}]}
{"id":"scribe-pzw.8","title":"Create EditorCommandBridge plugin in EditorRoot","description":"## Task: Create EditorCommandBridge plugin in EditorRoot\n\n### Purpose\nCreate a Lexical plugin that bridges the editor instance to the EditorCommandContext, enabling the ContextPanel to dispatch commands to the editor.\n\n### Dependencies\n- scribe-pzw.2 (EditorCommandContext) - Need `useEditorCommandSetter` hook\n\n### The Problem\n\nThe EditorCommandContext needs access to the Lexical editor instance, but:\n- The editor is created inside `LexicalComposer` in EditorRoot\n- The context provider must wrap BOTH EditorRoot and ContextPanel (siblings)\n- We need a way to \"export\" the editor instance to the context\n\n### Solution: EditorCommandBridge Plugin\n\nA plugin component inside `LexicalComposer` that:\n1. Gets the editor via `useLexicalComposerContext()`\n2. Calls `setEditor(editor)` on the context\n3. Cleans up by calling `setEditor(null)` on unmount\n\n### Implementation\n\n```typescript\n// Inside apps/desktop/renderer/src/components/Editor/EditorRoot.tsx\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { useEditorCommandSetter } from './EditorCommandContext';\n\n/**\n * Bridge plugin that exposes the editor instance to EditorCommandContext.\n * This enables cross-component communication between Editor and ContextPanel.\n * \n * Must be placed inside LexicalComposer to access editor context.\n */\nfunction EditorCommandBridge(): null {\n  const [editor] = useLexicalComposerContext();\n  const { setEditor } = useEditorCommandSetter();\n\n  useEffect(() =\u003e {\n    setEditor(editor);\n    return () =\u003e setEditor(null);\n  }, [editor, setEditor]);\n\n  return null;\n}\n```\n\n### Placement in EditorRoot\n\n```typescript\n// EditorRoot.tsx (lines ~170-180)\nreturn (\n  \u003cdiv className={styles.editorRoot}\u003e\n    \u003cLexicalComposer initialConfig={editorConfig}\u003e\n      \u003cdiv className={styles.editorContainer}\u003e\n        \u003cRichTextPlugin ... /\u003e\n        \u003cHistoryPlugin /\u003e\n        {/* ... other plugins ... */}\n        \u003cFocusNodePlugin /\u003e\n        \u003cEditorCommandBridge /\u003e  {/* NEW - add after FocusNodePlugin */}\n      \u003c/div\u003e\n    \u003c/LexicalComposer\u003e\n  \u003c/div\u003e\n);\n```\n\n### Why a Plugin?\n\n1. **Access to editor**: Only components inside `LexicalComposer` can use `useLexicalComposerContext()`\n2. **Lifecycle management**: React effects handle mount/unmount cleanup\n3. **Consistent pattern**: Follows the plugin pattern used throughout EditorRoot\n4. **No render**: Returns `null` - purely for side effects\n\n### Lifecycle Flow\n\n1. EditorCommandProvider renders in App.tsx (creates `setEditor` function)\n2. EditorRoot renders inside the provider\n3. LexicalComposer creates the editor instance\n4. EditorCommandBridge mounts, calls `setEditor(editor)`\n5. Context now has editor reference, `focusNode()` can dispatch commands\n6. On unmount (e.g., switching views), `setEditor(null)` cleans up\n\n### Edge Cases\n\n1. **Multiple EditorRoots**: Not expected in current architecture, but if it happened, last one wins\n2. **Hot reload**: Effect cleanup handles this correctly\n3. **Lazy loading**: Works fine - context gracefully handles null editor\n\n### Files to Modify\n\n- `apps/desktop/renderer/src/components/Editor/EditorRoot.tsx`\n  - Import `useEditorCommandSetter`\n  - Add `EditorCommandBridge` component\n  - Add `\u003cEditorCommandBridge /\u003e` inside LexicalComposer\n\n### Testing Notes\n\nIntegration tests should verify:\n- Bridge sets editor on mount\n- Bridge clears editor on unmount\n- focusNode works after bridge is mounted\n\n### Definition of Done\n\n- [ ] `EditorCommandBridge` component implemented\n- [ ] Added to EditorRoot inside LexicalComposer\n- [ ] Proper cleanup on unmount\n- [ ] TypeScript compiles without errors","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-22T19:09:07.604932-06:00","updated_at":"2025-12-22T19:38:21.932698-06:00","closed_at":"2025-12-22T19:38:21.932698-06:00","dependencies":[{"issue_id":"scribe-pzw.8","depends_on_id":"scribe-pzw","type":"parent-child","created_at":"2025-12-22T19:09:07.605329-06:00","created_by":"daemon"},{"issue_id":"scribe-pzw.8","depends_on_id":"scribe-pzw.2","type":"blocks","created_at":"2025-12-22T19:16:50.202371-06:00","created_by":"daemon"}]}
{"id":"scribe-pzw.9","title":"Wrap App with EditorCommandProvider","description":"## Task: Wrap App with EditorCommandProvider\n\n### Purpose\nAdd the EditorCommandProvider to App.tsx at a level that wraps both EditorRoot and ContextPanel, enabling cross-component command dispatch.\n\n### Dependencies\n- scribe-pzw.2 (EditorCommandContext) - Need the provider component\n- scribe-pzw.8 (EditorCommandBridge) - Bridge must be in place to set editor\n\n### Current Architecture\n\n```tsx\n// App.tsx (simplified structure)\n\u003cdiv className={styles.app}\u003e\n  \u003cSidebar ... /\u003e\n  \u003cdiv className={styles.mainContent}\u003e\n    {/* Editor here, inside WikiLink/PersonMention providers */}\n    \u003cWikiLinkProvider\u003e\n      \u003cPersonMentionProvider\u003e\n        \u003cEditorRoot noteState={noteState} /\u003e\n      \u003c/PersonMentionProvider\u003e\n    \u003c/WikiLinkProvider\u003e\n  \u003c/div\u003e\n  \u003cContextPanel ... /\u003e  {/* Sibling to mainContent */}\n\u003c/div\u003e\n```\n\n### Required Change\n\nWrap both `mainContent` (containing EditorRoot) and `ContextPanel` with `EditorCommandProvider`:\n\n```tsx\n// App.tsx (after change)\nimport { EditorCommandProvider } from './components/Editor/EditorCommandContext';\n\n// ... in render ...\n\n\u003cdiv className={styles.app}\u003e\n  \u003cSidebar ... /\u003e\n  \u003cEditorCommandProvider\u003e\n    \u003cdiv className={styles.mainContent}\u003e\n      \u003cWikiLinkProvider\u003e\n        \u003cPersonMentionProvider\u003e\n          \u003cEditorRoot noteState={noteState} /\u003e\n        \u003c/PersonMentionProvider\u003e\n      \u003c/WikiLinkProvider\u003e\n    \u003c/div\u003e\n    \u003cContextPanel ... /\u003e\n  \u003c/EditorCommandProvider\u003e\n\u003c/div\u003e\n```\n\n### Alternative: Fragment Wrapper\n\nIf we want to avoid an extra div in the DOM, we can use a Fragment:\n\n```tsx\n\u003cEditorCommandProvider\u003e\n  \u003c\u003e\n    \u003cdiv className={styles.mainContent}\u003e...\u003c/div\u003e\n    \u003cContextPanel ... /\u003e\n  \u003c/\u003e\n\u003c/EditorCommandProvider\u003e\n```\n\nHowever, since EditorCommandProvider likely just returns `{children}` anyway, no extra DOM element is added.\n\n### Placement Considerations\n\n**Why not wrap entire `\u003cApp /\u003e`?**\n- EditorCommandProvider only makes sense when there's an editor\n- Sidebar doesn't need it\n- Keeps context scope minimal for performance\n\n**Why not wrap just mainContent?**\n- ContextPanel is a sibling, not a child\n- OutlineWidget in ContextPanel needs to call `useEditorCommand()`\n- Must encompass both components\n\n### Impact Analysis\n\n1. **No breaking changes**: Just adds a provider, doesn't change props\n2. **Performance**: Provider only re-renders when editor changes (on mount/unmount)\n3. **Error handling**: If used outside provider, hook throws (good for debugging)\n\n### Files to Modify\n\n- `apps/desktop/renderer/src/App.tsx`\n  - Import `EditorCommandProvider`\n  - Wrap mainContent + ContextPanel with provider\n\n### Exact Change Location\n\n```typescript\n// App.tsx around line 255\n// BEFORE\n\u003cdiv className={styles.mainContent}\u003e\n  ...\n\u003c/div\u003e\n\u003cErrorBoundary name=\"Context Panel\"\u003e\n  \u003cContextPanel ... /\u003e\n\u003c/ErrorBoundary\u003e\n\n// AFTER\n\u003cEditorCommandProvider\u003e\n  \u003cdiv className={styles.mainContent}\u003e\n    ...\n  \u003c/div\u003e\n  \u003cErrorBoundary name=\"Context Panel\"\u003e\n    \u003cContextPanel ... /\u003e\n  \u003c/ErrorBoundary\u003e\n\u003c/EditorCommandProvider\u003e\n```\n\n### Testing Notes\n\nIntegration tests should verify:\n- OutlineWidget can call focusNode without errors\n- Clicking outline item scrolls editor to heading\n- Works correctly on initial load\n- Works after note changes\n\n### Definition of Done\n\n- [ ] Import `EditorCommandProvider` added\n- [ ] Provider wraps both mainContent and ContextPanel\n- [ ] TypeScript compiles without errors\n- [ ] No visual/layout changes from the provider\n- [ ] Manual test: outline navigation works end-to-end","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-22T19:09:07.683384-06:00","updated_at":"2025-12-22T19:39:53.868571-06:00","closed_at":"2025-12-22T19:39:53.868571-06:00","dependencies":[{"issue_id":"scribe-pzw.9","depends_on_id":"scribe-pzw","type":"parent-child","created_at":"2025-12-22T19:09:07.683695-06:00","created_by":"daemon"},{"issue_id":"scribe-pzw.9","depends_on_id":"scribe-pzw.2","type":"blocks","created_at":"2025-12-22T19:16:50.249353-06:00","created_by":"daemon"},{"issue_id":"scribe-pzw.9","depends_on_id":"scribe-pzw.8","type":"blocks","created_at":"2025-12-22T19:16:50.301217-06:00","created_by":"daemon"}]}
