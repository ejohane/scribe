{"id":"linked-1","title":"Implement WikiLinkNode (Lexical custom node)","description":"Create the custom Lexical DecoratorNode for wiki-links.\n\n## Details\n- File: renderer/src/components/Editor/plugins/WikiLinkNode.ts\n- Extends DecoratorNode\u003cJSX.Element\u003e\n\n## Properties\n- __noteTitle: string - Target note title (e.g., 'Meeting Notes')\n- __displayText: string - What to show (alias or title)\n- __targetId: NoteId | null - Resolved note ID (null if unresolved)\n\n## Methods to implement\n- static getType(): 'wiki-link'\n- static clone(node): WikiLinkNode\n- constructor(noteTitle, displayText, targetId, key?)\n- createDOM(): span with class 'wiki-link'\n- updateDOM(): return false (decorator handles updates)\n- decorate(): return WikiLinkComponent JSX\n- exportJSON(): serialize all properties\n- static importJSON(json): deserialize node\n- isInline(): return true\n- getTextContent(): return displayText (for copy/paste)\n\n## Implementation Skeleton\n```typescript\nimport { DecoratorNode, NodeKey, SerializedLexicalNode, Spread } from 'lexical';\nimport type { NoteId } from '@scribe/shared';\n\nexport type SerializedWikiLinkNode = Spread\u003c\n  {\n    noteTitle: string;\n    displayText: string;\n    targetId: NoteId | null;\n  },\n  SerializedLexicalNode\n\u003e;\n\nexport class WikiLinkNode extends DecoratorNode\u003cJSX.Element\u003e {\n  __noteTitle: string;\n  __displayText: string;\n  __targetId: NoteId | null;\n\n  static getType(): string {\n    return 'wiki-link';\n  }\n\n  static clone(node: WikiLinkNode): WikiLinkNode {\n    return new WikiLinkNode(\n      node.__noteTitle,\n      node.__displayText,\n      node.__targetId,\n      node.__key\n    );\n  }\n\n  constructor(\n    noteTitle: string,\n    displayText: string,\n    targetId: NoteId | null,\n    key?: NodeKey\n  ) {\n    super(key);\n    this.__noteTitle = noteTitle;\n    this.__displayText = displayText;\n    this.__targetId = targetId;\n  }\n\n  createDOM(): HTMLElement {\n    const span = document.createElement('span');\n    span.className = 'wiki-link';\n    return span;\n  }\n\n  updateDOM(): boolean {\n    return false;\n  }\n\n  decorate(): JSX.Element {\n    return (\n      \u003cWikiLinkComponent\n        noteTitle={this.__noteTitle}\n        displayText={this.__displayText}\n        targetId={this.__targetId}\n        nodeKey={this.__key}\n      /\u003e\n    );\n  }\n\n  exportJSON(): SerializedWikiLinkNode {\n    return {\n      ...super.exportJSON(),\n      type: 'wiki-link',\n      noteTitle: this.__noteTitle,\n      displayText: this.__displayText,\n      targetId: this.__targetId,\n      version: 1,\n    };\n  }\n\n  static importJSON(json: SerializedWikiLinkNode): WikiLinkNode {\n    return $createWikiLinkNode(\n      json.noteTitle,\n      json.displayText,\n      json.targetId\n    );\n  }\n\n  isInline(): boolean {\n    return true;\n  }\n\n  getTextContent(): string {\n    return this.__displayText;\n  }\n}\n\nexport function $createWikiLinkNode(\n  noteTitle: string,\n  displayText: string,\n  targetId: NoteId | null\n): WikiLinkNode {\n  return new WikiLinkNode(noteTitle, displayText, targetId);\n}\n\nexport function $isWikiLinkNode(node: unknown): node is WikiLinkNode {\n  return node instanceof WikiLinkNode;\n}\n```\n\n## WikiLinkComponent (inner React component)\n```typescript\ninterface WikiLinkComponentProps {\n  noteTitle: string;\n  displayText: string;\n  targetId: NoteId | null;\n  nodeKey: NodeKey;\n}\n\nfunction WikiLinkComponent({ displayText }: WikiLinkComponentProps) {\n  // Click handler will be added via context in linked-10\n  return \u003cspan\u003e{displayText}\u003c/span\u003e;\n}\n```\n\n## Important Notes\n- NoteId type from @scribe/shared\n- Node should be selectable but not editable (DecoratorNode behavior)\n- The click handler is NOT implemented here - see linked-10\n\n## Acceptance Criteria\n- [ ] Node can be created with noteTitle, displayText, targetId\n- [ ] Node serializes/deserializes correctly (JSON round-trip)\n- [ ] Node renders as inline span with wiki-link class\n- [ ] Node displays displayText (not noteTitle when different)\n- [ ] getTextContent() returns displayText for copy/paste\n- [ ] $createWikiLinkNode and $isWikiLinkNode helpers exported","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-26T14:39:40.682059-06:00","updated_at":"2025-11-26T15:03:31.359631-06:00","closed_at":"2025-11-26T15:03:31.359631-06:00","dependencies":[{"issue_id":"linked-1","depends_on_id":"linked-notes-1","type":"parent-child","created_at":"0001-01-01T00:00:00Z","created_by":""}]}
{"id":"linked-10","title":"Implement wiki-link click navigation","description":"Handle click events on wiki-links to navigate to the target note.\n\n## Details\n- Files:\n  - renderer/src/components/Editor/plugins/WikiLinkNode.ts (update WikiLinkComponent)\n  - renderer/src/components/Editor/plugins/WikiLinkContext.tsx (new context)\n\n## Architecture Decision\nUse React Context to provide navigation callbacks to WikiLinkComponent. This keeps the DecoratorNode clean and allows the navigation logic to be managed at the App level.\n\n## New File: WikiLinkContext.tsx\n```typescript\nimport { createContext, useContext, ReactNode } from 'react';\nimport type { NoteId } from '@scribe/shared';\n\ninterface WikiLinkContextValue {\n  currentNoteId: NoteId | null;\n  onLinkClick: (noteTitle: string, targetId: NoteId | null) =\u003e Promise\u003cvoid\u003e;\n}\n\nconst WikiLinkContext = createContext\u003cWikiLinkContextValue | null\u003e(null);\n\nexport function useWikiLinkContext() {\n  const context = useContext(WikiLinkContext);\n  if (!context) {\n    throw new Error('useWikiLinkContext must be used within WikiLinkProvider');\n  }\n  return context;\n}\n\ninterface WikiLinkProviderProps {\n  children: ReactNode;\n  currentNoteId: NoteId | null;\n  onLinkClick: (noteTitle: string, targetId: NoteId | null) =\u003e Promise\u003cvoid\u003e;\n}\n\nexport function WikiLinkProvider({ \n  children, \n  currentNoteId, \n  onLinkClick \n}: WikiLinkProviderProps) {\n  return (\n    \u003cWikiLinkContext.Provider value={{ currentNoteId, onLinkClick }}\u003e\n      {children}\n    \u003c/WikiLinkContext.Provider\u003e\n  );\n}\n```\n\n## Update WikiLinkComponent in WikiLinkNode.ts\n```typescript\nimport { useWikiLinkContext } from './WikiLinkContext';\n\nfunction WikiLinkComponent({ \n  noteTitle, \n  displayText, \n  targetId \n}: WikiLinkComponentProps) {\n  const { currentNoteId, onLinkClick } = useWikiLinkContext();\n\n  const handleClick = async (e: React.MouseEvent) =\u003e {\n    e.preventDefault();\n    e.stopPropagation();\n    \n    // Self-link check\n    if (targetId === currentNoteId) {\n      return;\n    }\n    \n    await onLinkClick(noteTitle, targetId);\n  };\n\n  return (\n    \u003cspan className=\"wiki-link\" onClick={handleClick}\u003e\n      {displayText}\n    \u003c/span\u003e\n  );\n}\n```\n\n## Link Resolution Logic (in App.tsx or parent)\nThe onLinkClick handler should implement:\n```typescript\nconst handleWikiLinkClick = async (noteTitle: string, targetId: NoteId | null) =\u003e {\n  let resolvedId = targetId;\n  \n  // If no targetId, try to find by title\n  if (!resolvedId) {\n    const note = await window.scribe.notes.findByTitle(noteTitle);\n    if (note) {\n      resolvedId = note.id;\n    }\n  }\n  \n  if (resolvedId) {\n    // Navigate to existing note\n    navigateToNote(resolvedId, true);\n  } else {\n    // Create new note with this title (future: set title on create)\n    const newNote = await window.scribe.notes.create();\n    navigateToNote(newNote.id, true);\n  }\n};\n```\n\n## Integration with EditorRoot\nWrap LexicalComposer children with WikiLinkProvider:\n```typescript\n\u003cLexicalComposer initialConfig={editorConfig}\u003e\n  \u003cWikiLinkProvider \n    currentNoteId={noteState.currentNoteId}\n    onLinkClick={handleWikiLinkClick}\n  \u003e\n    {/* existing content */}\n  \u003c/WikiLinkProvider\u003e\n\u003c/LexicalComposer\u003e\n```\n\n## Important Notes\n- Self-link check prevents infinite loops\n- Navigation function comes from useNavigationHistory (linked-11)\n- findByTitle API comes from linked-5\n- Note creation doesn't set title yet (acceptable for MVP)\n\n## Acceptance Criteria\n- [ ] WikiLinkContext created with currentNoteId and onLinkClick\n- [ ] WikiLinkComponent uses context for click handling\n- [ ] Click on wiki-link triggers navigation\n- [ ] Self-links (link to current note) are no-op\n- [ ] Resolved links navigate directly\n- [ ] Unresolved links attempt findByTitle lookup\n- [ ] Missing notes are created automatically\n- [ ] Navigation pushes to history stack","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-26T14:42:18.400947-06:00","updated_at":"2025-11-26T15:13:47.276808-06:00","closed_at":"2025-11-26T15:13:47.276808-06:00","dependencies":[{"issue_id":"linked-10","depends_on_id":"linked-notes-1","type":"parent-child","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"linked-10","depends_on_id":"linked-5","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"linked-10","depends_on_id":"linked-7","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"linked-10","depends_on_id":"linked-11","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""}]}
{"id":"linked-11","title":"Implement useNavigationHistory hook","description":"Create a React hook to manage navigation history state.\n\n## Details\n- File: renderer/src/hooks/useNavigationHistory.ts\n\n## Interface\n```typescript\nimport { useState, useCallback } from 'react';\nimport type { NoteId } from '@scribe/shared';\n\ninterface UseNavigationHistoryReturn {\n  /** Stack of previously visited note IDs */\n  history: NoteId[];\n  \n  /** Whether back navigation is available */\n  canGoBack: boolean;\n  \n  /** Navigate to a note, optionally adding current to history */\n  navigateToNote: (noteId: NoteId, addToHistory?: boolean) =\u003e void;\n  \n  /** Go back to previous note */\n  navigateBack: () =\u003e void;\n  \n  /** Clear all history (used on fresh navigation) */\n  clearHistory: () =\u003e void;\n}\n```\n\n## Implementation\n```typescript\nimport { useState, useCallback } from 'react';\nimport type { NoteId } from '@scribe/shared';\n\nexport function useNavigationHistory(\n  currentNoteId: NoteId | null,\n  loadNote: (id: NoteId) =\u003e Promise\u003cvoid\u003e\n): UseNavigationHistoryReturn {\n  const [history, setHistory] = useState\u003cNoteId[]\u003e([]);\n  \n  const canGoBack = history.length \u003e 0;\n  \n  const navigateToNote = useCallback((noteId: NoteId, addToHistory = true) =\u003e {\n    if (addToHistory \u0026\u0026 currentNoteId) {\n      setHistory(prev =\u003e [...prev, currentNoteId]);\n    }\n    loadNote(noteId);\n  }, [currentNoteId, loadNote]);\n  \n  const navigateBack = useCallback(() =\u003e {\n    if (history.length === 0) return;\n    \n    const newHistory = [...history];\n    const prevNoteId = newHistory.pop()!;\n    setHistory(newHistory);\n    loadNote(prevNoteId);\n  }, [history, loadNote]);\n  \n  const clearHistory = useCallback(() =\u003e {\n    setHistory([]);\n  }, []);\n  \n  return {\n    history,\n    canGoBack,\n    navigateToNote,\n    navigateBack,\n    clearHistory,\n  };\n}\n```\n\n## Usage in App.tsx\n```typescript\n// Import the hook\nimport { useNavigationHistory } from './hooks/useNavigationHistory';\n\nfunction App() {\n  const noteState = useNoteState();\n  \n  // Initialize navigation history\n  const { \n    canGoBack, \n    navigateToNote, \n    navigateBack, \n    clearHistory \n  } = useNavigationHistory(noteState.currentNoteId, noteState.loadNote);\n  \n  // Use navigateToNote for wiki-link clicks\n  // Use clearHistory when opening via command palette\n  // Use navigateBack for back button/Cmd+[\n}\n```\n\n## Important Notes\n- Session-only storage (no persistence across app restarts)\n- State resets on page reload\n- Uses array spread for immutable updates\n- loadNote is from useNoteState hook (returns Promise\u003cvoid\u003e)\n\n## Tests\nFile: renderer/src/hooks/useNavigationHistory.test.ts\n- navigateToNote pushes to history when addToHistory=true\n- navigateToNote does NOT push when addToHistory=false\n- navigateToNote does NOT push null currentNoteId\n- navigateBack pops and loads previous note\n- navigateBack does nothing when history empty\n- canGoBack is true only when history has items\n- clearHistory empties the stack and sets canGoBack false\n\n## Acceptance Criteria\n- [ ] Hook manages history stack correctly (LIFO)\n- [ ] navigateToNote pushes current note to history before loading new\n- [ ] navigateBack loads previous and removes from stack\n- [ ] canGoBack is true only when history exists\n- [ ] clearHistory empties the stack\n- [ ] Session-only (no persistence)\n- [ ] Type-safe with NoteId from @scribe/shared","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-26T14:42:43.597491-06:00","updated_at":"2025-11-26T15:03:34.138918-06:00","closed_at":"2025-11-26T15:03:34.138918-06:00","dependencies":[{"issue_id":"linked-11","depends_on_id":"linked-notes-1","type":"parent-child","created_at":"0001-01-01T00:00:00Z","created_by":""}]}
{"id":"linked-12","title":"Implement back button UI","description":"Add the back navigation button to the editor UI.\n\n## Details\n- Files:\n  - renderer/src/components/BackButton/BackButton.tsx (new)\n  - renderer/src/components/BackButton/BackButton.css (new)\n  - renderer/src/components/BackButton/index.ts (new)\n\n## Component Implementation\n```typescript\n// BackButton.tsx\nimport './BackButton.css';\n\ninterface BackButtonProps {\n  visible: boolean;\n  onClick: () =\u003e void;\n}\n\nexport function BackButton({ visible, onClick }: BackButtonProps) {\n  if (!visible) return null;\n  \n  return (\n    \u003cbutton \n      className=\"back-button\"\n      onClick={onClick}\n      aria-label=\"Go back to previous note\"\n      title=\"Go back (⌘[)\"\n      type=\"button\"\n    \u003e\n      ←\n    \u003c/button\u003e\n  );\n}\n```\n\n```typescript\n// index.ts\nexport { BackButton } from './BackButton';\n```\n\n## CSS (BackButton.css)\n```css\n.back-button {\n  position: absolute;\n  top: 1rem;\n  left: 1rem;\n  z-index: 10;\n  background: none;\n  border: none;\n  font-size: 1.25rem;\n  cursor: pointer;\n  color: #666;\n  padding: 0.5rem;\n  border-radius: 4px;\n  transition: background-color 0.15s, color 0.15s;\n  line-height: 1;\n}\n\n.back-button:hover {\n  background-color: rgba(0, 0, 0, 0.05);\n  color: #333;\n}\n\n.back-button:focus {\n  outline: 2px solid #007bff;\n  outline-offset: 2px;\n}\n\n.back-button:active {\n  background-color: rgba(0, 0, 0, 0.1);\n}\n\n/* Dark mode */\n[data-theme='dark'] .back-button {\n  color: #999;\n}\n\n[data-theme='dark'] .back-button:hover {\n  background-color: rgba(255, 255, 255, 0.1);\n  color: #fff;\n}\n\n[data-theme='dark'] .back-button:focus {\n  outline-color: #58a6ff;\n}\n```\n\n## Layout Position\nThe button sits in the upper left of the app, outside the editor content area:\n```\n┌──────────────────────────────────────────────────────┐\n│                                                      │\n│  ←                                                   │\n│                                                      │\n│        # Meeting Notes                               │\n│                                                      │\n│        Today we discussed [[Project Alpha]]...       │\n│                                                      │\n└──────────────────────────────────────────────────────┘\n```\n\n## Integration in App.tsx\nAdd to the return JSX (the .app div needs position: relative):\n```typescript\n\u003cdiv className=\"app\"\u003e\n  \u003cBackButton visible={canGoBack} onClick={navigateBack} /\u003e\n  \u003cEditorRoot noteState={noteState} /\u003e\n  {/* ... other components */}\n\u003c/div\u003e\n```\n\nEnsure App.css has:\n```css\n.app {\n  position: relative;\n  /* ... existing styles */\n}\n```\n\n## Accessibility\n- aria-label for screen readers\n- title shows keyboard shortcut hint\n- Focusable via Tab key\n- Clear focus ring for keyboard users\n- type=\"button\" prevents form submission issues\n\n## Acceptance Criteria\n- [ ] Button component created in BackButton directory\n- [ ] Button renders only when visible=true\n- [ ] Button hidden when visible=false (returns null)\n- [ ] Click triggers onClick callback\n- [ ] Accessible (aria-label, keyboard focusable)\n- [ ] Tooltip shows keyboard shortcut (⌘[)\n- [ ] Proper positioning in upper-left\n- [ ] Works in light and dark themes\n- [ ] Focus ring visible on keyboard focus","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-26T14:43:00.964936-06:00","updated_at":"2025-11-26T15:05:32.445713-06:00","closed_at":"2025-11-26T15:05:32.445713-06:00","dependencies":[{"issue_id":"linked-12","depends_on_id":"linked-notes-1","type":"parent-child","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"linked-12","depends_on_id":"linked-11","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""}]}
{"id":"linked-13","title":"Implement Cmd+[ keyboard shortcut for back navigation","description":"Add keyboard shortcut for back navigation.\n\n## Details\n- File: renderer/src/App.tsx\n\n## Note\nThis task is now part of linked-14 (Integration task). The keyboard handler will be added as part of the full App.tsx integration. This task documents the specific requirements.\n\n## Shortcut\n- Mac: Cmd+[\n- Windows/Linux: Ctrl+[\n\n## Implementation\nAdd to existing keyboard handler in App.tsx useEffect (around line 147-183):\n\n```typescript\nuseEffect(() =\u003e {\n  const handleKeyDown = (e: KeyboardEvent) =\u003e {\n    // ... existing shortcuts (Cmd+K, Cmd+O, Cmd+N)\n    \n    // Cmd+[ / Ctrl+[: Navigate back\n    if ((e.metaKey || e.ctrlKey) \u0026\u0026 e.key === '[') {\n      e.preventDefault();\n      if (canGoBack) {\n        navigateBack();\n      }\n    }\n  };\n  \n  window.addEventListener('keydown', handleKeyDown);\n  return () =\u003e window.removeEventListener('keydown', handleKeyDown);\n}, [isPaletteOpen, noteState, canGoBack, navigateBack]);  // Add canGoBack, navigateBack to deps\n```\n\n## Behavior\n- Only triggers if canGoBack is true\n- Does nothing silently if history is empty\n- Prevents default browser behavior (some browsers use [ for other shortcuts)\n- Works alongside existing ⌘K, ⌘O, ⌘N shortcuts\n\n## Accessibility Notes\n- Back button tooltip should mention ⌘[ (handled in linked-12)\n- Consistent with browser back shortcut on Mac\n\n## Test Scenarios\n1. With history: Press Cmd+[ → navigates back\n2. Without history: Press Cmd+[ → nothing happens (no error)\n3. Works on both Mac (Cmd) and Windows (Ctrl)\n\n## Acceptance Criteria\n- [ ] Cmd+[ triggers navigateBack on Mac\n- [ ] Ctrl+[ triggers navigateBack on Windows/Linux\n- [ ] Does nothing when no history (canGoBack false)\n- [ ] Prevents default browser behavior\n- [ ] No errors logged when history empty\n- [ ] Integrated with existing keyboard handlers\n- [ ] useEffect deps array includes canGoBack and navigateBack","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-26T14:43:13.331004-06:00","updated_at":"2025-11-26T15:19:15.175657-06:00","closed_at":"2025-11-26T15:19:15.175657-06:00","dependencies":[{"issue_id":"linked-13","depends_on_id":"linked-notes-1","type":"parent-child","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"linked-13","depends_on_id":"linked-11","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""}]}
{"id":"linked-14","title":"Integrate navigation history with App.tsx","description":"Wire up navigation history with existing note state and command palette. This is the final integration task that brings all wiki-link navigation pieces together.\n\n## Details\n- File: renderer/src/App.tsx\n\n## Prerequisites (blocked by)\n- linked-11: useNavigationHistory hook\n- linked-12: BackButton component\n- linked-13: Cmd+[ keyboard shortcut\n- linked-10: Wiki-link click navigation (WikiLinkContext)\n\n## Changes Needed\n\n### 1. Import new modules\n```typescript\nimport { useNavigationHistory } from './hooks/useNavigationHistory';\nimport { BackButton } from './components/BackButton';\nimport { WikiLinkProvider } from './components/Editor/plugins/WikiLinkContext';\n```\n\n### 2. Initialize useNavigationHistory hook\nAdd after useNoteState (around line 23):\n```typescript\nconst noteState = useNoteState();\n\n// Add navigation history\nconst { canGoBack, navigateToNote, navigateBack, clearHistory } = \n  useNavigationHistory(noteState.currentNoteId, noteState.loadNote);\n```\n\n### 3. Update command palette navigation\nModify onSearchResultSelect and onNoteSelect to clear history (around line 235-244):\n```typescript\nonSearchResultSelect={(result) =\u003e {\n  clearHistory();  // Fresh navigation - clear wiki-link history\n  noteState.loadNote(result.id);\n  setIsPaletteOpen(false);\n}}\n// ...\nonNoteSelect={(noteId) =\u003e {\n  clearHistory();  // Fresh navigation\n  noteState.loadNote(noteId);\n}}\n```\n\n### 4. Clear history on new note creation\nUpdate the ⌘N handler (around line 174-178):\n```typescript\nif ((e.metaKey || e.ctrlKey) \u0026\u0026 e.key === 'n') {\n  e.preventDefault();\n  setIsPaletteOpen(false);\n  clearHistory();  // Add this\n  noteState.createNote();\n}\n```\n\nAnd update the 'new-note' command (around line 46-48):\n```typescript\nrun: async (context) =\u003e {\n  clearHistory();  // Add this\n  await context.createNote();\n},\n```\n\n### 5. Add Cmd+[ handler\nAdd to existing keyboard handler (around line 179):\n```typescript\n// Cmd+[ / Ctrl+[: Navigate back\nif ((e.metaKey || e.ctrlKey) \u0026\u0026 e.key === '[') {\n  e.preventDefault();\n  if (canGoBack) {\n    navigateBack();\n  }\n}\n```\n\n### 6. Create wiki-link click handler\nAdd function in App component:\n```typescript\nconst handleWikiLinkClick = useCallback(async (\n  noteTitle: string, \n  targetId: NoteId | null\n) =\u003e {\n  let resolvedId = targetId;\n  \n  if (!resolvedId) {\n    const note = await window.scribe.notes.findByTitle(noteTitle);\n    if (note) {\n      resolvedId = note.id;\n    }\n  }\n  \n  if (resolvedId) {\n    navigateToNote(resolvedId, true);\n  } else {\n    const newNote = await window.scribe.notes.create();\n    navigateToNote(newNote.id, true);\n  }\n}, [navigateToNote]);\n```\n\n### 7. Pass wiki-link context to EditorRoot\nUpdate EditorRoot to accept and use WikiLinkProvider:\n```typescript\n\u003cEditorRoot \n  noteState={noteState}\n  onWikiLinkClick={handleWikiLinkClick}\n  currentNoteId={noteState.currentNoteId}\n/\u003e\n```\n\n### 8. Render back button\nAdd BackButton alongside EditorRoot in the return JSX:\n```typescript\n\u003cdiv className=\"app\"\u003e\n  \u003cBackButton visible={canGoBack} onClick={navigateBack} /\u003e\n  \u003cEditorRoot noteState={noteState} ... /\u003e\n  {/* rest of components */}\n\u003c/div\u003e\n```\n\n## Important Notes\n- clearHistory must be called before noteState.loadNote, not after\n- Keyboard handler deps must include canGoBack and navigateBack\n- The 'new-note' command needs clearHistory in its context or closure\n\n## Acceptance Criteria\n- [ ] useNavigationHistory integrated in App.tsx\n- [ ] Command palette navigation clears history before loading\n- [ ] New note creation clears history\n- [ ] Cmd+[/Ctrl+[ triggers navigateBack when history exists\n- [ ] Wiki-link clicks use navigateToNote with history\n- [ ] Back button receives canGoBack and navigateBack\n- [ ] Full navigation flow works end-to-end:\n  1. Click wiki-link -\u003e pushes to history -\u003e loads note\n  2. Click back/Cmd+[ -\u003e pops from history -\u003e loads previous\n  3. Open via palette -\u003e clears history -\u003e loads note","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-26T14:43:33.607749-06:00","updated_at":"2025-11-26T15:19:16.240362-06:00","closed_at":"2025-11-26T15:19:16.240362-06:00","dependencies":[{"issue_id":"linked-14","depends_on_id":"linked-notes-1","type":"parent-child","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"linked-14","depends_on_id":"linked-11","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"linked-14","depends_on_id":"linked-12","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"linked-14","depends_on_id":"linked-13","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"linked-14","depends_on_id":"linked-10","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""}]}
{"id":"linked-15","title":"Unit tests for WikiLinkNode","description":"Write comprehensive unit tests for the WikiLinkNode.\n\n## Details\n- File: renderer/src/components/Editor/plugins/WikiLinkNode.test.ts\n\n## Test cases\n\n### Node creation\n- Create node with all properties (noteTitle, displayText, targetId)\n- Create node with null targetId (unresolved link)\n- Create node where displayText equals noteTitle (no alias)\n\n### Serialization\n- exportJSON produces correct structure\n- importJSON recreates node correctly\n- Round-trip: export → import preserves all data\n\n### DOM creation\n- createDOM returns span element\n- Span has 'wiki-link' class\n- updateDOM returns false\n\n### Cloning\n- clone() preserves noteTitle\n- clone() preserves displayText\n- clone() preserves targetId\n\n### Text content\n- getTextContent() returns displayText\n- Works for aliased links\n- Works for non-aliased links\n\n### Type checking\n- getType() returns 'wiki-link'\n- isInline() returns true\n\n## Test setup\n```typescript\nimport { WikiLinkNode, $createWikiLinkNode } from './WikiLinkNode';\nimport { $getRoot, $createParagraphNode, createEditor } from 'lexical';\n\ndescribe('WikiLinkNode', () =\u003e {\n  let editor: LexicalEditor;\n  \n  beforeEach(() =\u003e {\n    editor = createEditor({\n      nodes: [WikiLinkNode],\n    });\n  });\n  \n  // ... tests\n});\n```\n\n## Acceptance Criteria\n- [ ] All node creation tests pass\n- [ ] Serialization round-trip works\n- [ ] DOM creation tests pass\n- [ ] Clone preserves all properties\n- [ ] getTextContent returns correct value","status":"closed","priority":2,"issue_type":"task","created_at":"2025-11-26T14:44:00.903119-06:00","updated_at":"2025-11-26T15:21:42.726831-06:00","closed_at":"2025-11-26T15:21:42.726831-06:00","dependencies":[{"issue_id":"linked-15","depends_on_id":"linked-notes-1","type":"parent-child","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"linked-15","depends_on_id":"linked-1","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""}]}
{"id":"linked-16","title":"Unit tests for useNavigationHistory hook","description":"Write unit tests for the navigation history hook.\n\n## Details\n- File: renderer/src/hooks/useNavigationHistory.test.ts\n\n## Test cases\n\n### Initial state\n- history starts empty\n- canGoBack is false initially\n\n### navigateToNote\n- Adds current note to history when addToHistory=true\n- Does not add to history when addToHistory=false\n- Does not add null currentNoteId to history\n- Calls loadNote with correct ID\n\n### navigateBack\n- Pops last item from history\n- Calls loadNote with popped ID\n- Does nothing when history is empty\n- canGoBack updates after pop\n\n### clearHistory\n- Empties the history array\n- canGoBack becomes false\n\n### canGoBack\n- Returns true when history has items\n- Returns false when history is empty\n- Updates reactively\n\n## Test setup\n```typescript\nimport { renderHook, act } from '@testing-library/react';\nimport { useNavigationHistory } from './useNavigationHistory';\n\ndescribe('useNavigationHistory', () =\u003e {\n  const mockLoadNote = vi.fn();\n  \n  beforeEach(() =\u003e {\n    mockLoadNote.mockClear();\n  });\n  \n  it('starts with empty history', () =\u003e {\n    const { result } = renderHook(() =\u003e \n      useNavigationHistory('note-1', mockLoadNote)\n    );\n    \n    expect(result.current.history).toEqual([]);\n    expect(result.current.canGoBack).toBe(false);\n  });\n  \n  // ... more tests\n});\n```\n\n## Acceptance Criteria\n- [ ] All initial state tests pass\n- [ ] navigateToNote tests pass\n- [ ] navigateBack tests pass\n- [ ] clearHistory tests pass\n- [ ] canGoBack reactive updates work","status":"closed","priority":2,"issue_type":"task","created_at":"2025-11-26T14:44:13.988142-06:00","updated_at":"2025-11-26T15:21:30.448759-06:00","closed_at":"2025-11-26T15:21:30.448759-06:00","dependencies":[{"issue_id":"linked-16","depends_on_id":"linked-notes-1","type":"parent-child","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"linked-16","depends_on_id":"linked-11","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""}]}
{"id":"linked-17","title":"Component tests for WikiLinkAutocomplete","description":"Write component tests for the autocomplete UI.\n\n## Details\n- File: renderer/src/components/Editor/plugins/WikiLinkAutocomplete.test.tsx\n\n## Test cases\n\n### Rendering\n- Renders nothing when isOpen=false\n- Renders popup when isOpen=true\n- Positions popup at specified coordinates\n- Shows loading state when isLoading=true\n\n### Results display\n- Renders all results\n- Truncates long titles\n- Shows 'No matching notes' when results empty\n\n### Selection state\n- Highlights item at selectedIndex\n- Scrolls selected item into view\n\n### Interactions\n- Calls onSelect when item clicked\n- Calls onClose when clicking outside (if applicable)\n\n### Keyboard (passed via props)\n- Selected index changes visible highlight\n\n## Test setup\n```typescript\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport { WikiLinkAutocomplete } from './WikiLinkAutocomplete';\n\nconst mockResults = [\n  { id: '1', title: 'Meeting Notes', snippet: '', score: 1, matches: [] },\n  { id: '2', title: 'Project Plan', snippet: '', score: 0.8, matches: [] },\n];\n\ndescribe('WikiLinkAutocomplete', () =\u003e {\n  it('renders results when open', () =\u003e {\n    render(\n      \u003cWikiLinkAutocomplete\n        isOpen={true}\n        query=\"meet\"\n        position={{ top: 100, left: 200 }}\n        results={mockResults}\n        selectedIndex={0}\n        onSelect={vi.fn()}\n        onClose={vi.fn()}\n        isLoading={false}\n      /\u003e\n    );\n    \n    expect(screen.getByText('Meeting Notes')).toBeInTheDocument();\n    expect(screen.getByText('Project Plan')).toBeInTheDocument();\n  });\n  \n  // ... more tests\n});\n```\n\n## Acceptance Criteria\n- [ ] Visibility tests pass\n- [ ] Position tests pass\n- [ ] Results rendering tests pass\n- [ ] Selection highlight tests pass\n- [ ] Click interaction tests pass","status":"closed","priority":2,"issue_type":"task","created_at":"2025-11-26T14:44:28.057866-06:00","updated_at":"2025-11-26T15:21:30.991777-06:00","closed_at":"2025-11-26T15:21:30.991777-06:00","dependencies":[{"issue_id":"linked-17","depends_on_id":"linked-notes-1","type":"parent-child","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"linked-17","depends_on_id":"linked-8","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""}]}
{"id":"linked-18","title":"Integration tests for linked notes feature","description":"Write end-to-end integration tests for the linked notes feature.\n\n## Details\n- File: apps/desktop/linked-notes.integration.test.ts\n\n## Prerequisites\nThis test should run after all other tasks are complete. It validates the full feature works end-to-end.\n\n## Test Setup\nUse existing test helpers from apps/desktop/test-helpers.ts:\n```typescript\nimport { expect, test, _electron, ElectronApplication } from '@playwright/test';\nimport { launchApp, createNote, getEditorContent, typeInEditor } from './test-helpers';\n```\n\n## Test Flows\n\n### Flow 1: Create and follow link to new note\n```typescript\ntest('wiki-link creates and navigates to new note', async () =\u003e {\n  const app = await launchApp();\n  \n  // Create initial note\n  await createNote(app, 'Alpha');\n  \n  // Type wiki-link to non-existent note\n  await typeInEditor(app, '[[Beta]]');\n  \n  // Verify WikiLinkNode created (check serialized content)\n  const content = await getEditorContent(app);\n  expect(content).toContain('\"type\":\"wiki-link\"');\n  expect(content).toContain('\"noteTitle\":\"Beta\"');\n  \n  // Click the link\n  await app.click('.wiki-link');\n  \n  // Verify new note created and loaded\n  await expect(app.locator('.editor-input')).toContainText('Beta');\n  \n  // Click back button\n  await app.click('.back-button');\n  \n  // Verify returned to Alpha\n  await expect(app.locator('.editor-input')).toContainText('Alpha');\n});\n```\n\n### Flow 2: Autocomplete selection\n```typescript\ntest('autocomplete shows matching notes', async () =\u003e {\n  const app = await launchApp();\n  \n  // Create test notes\n  await createNote(app, 'Project Alpha');\n  await createNote(app, 'Project Beta');\n  await createNote(app, 'Other Note');\n  \n  // Start new note and trigger autocomplete\n  await createNote(app, 'Test');\n  await typeInEditor(app, '[[Proj');\n  \n  // Verify autocomplete shows\n  await expect(app.locator('.wiki-link-autocomplete')).toBeVisible();\n  await expect(app.locator('.wiki-link-autocomplete-item')).toHaveCount(2);\n  \n  // Select with keyboard\n  await app.keyboard.press('ArrowDown');\n  await app.keyboard.press('Enter');\n  \n  // Verify link inserted with targetId\n  const content = await getEditorContent(app);\n  expect(content).toContain('\"targetId\"');\n});\n```\n\n### Flow 3: Alias syntax\n```typescript\ntest('alias syntax displays custom text', async () =\u003e {\n  const app = await launchApp();\n  \n  await createNote(app, 'Meeting Notes');\n  await createNote(app, 'Test');\n  await typeInEditor(app, '[[Meeting Notes|yesterday]]');\n  \n  // Verify displays alias text\n  await expect(app.locator('.wiki-link')).toContainText('yesterday');\n  \n  // Click and verify correct note loads\n  await app.click('.wiki-link');\n  await expect(app.locator('.editor-input')).toContainText('Meeting Notes');\n});\n```\n\n### Flow 4: Back navigation with Cmd+[\n```typescript\ntest('Cmd+[ navigates back', async () =\u003e {\n  const app = await launchApp();\n  \n  await createNote(app, 'Alpha');\n  await typeInEditor(app, '[[Beta]]');\n  await app.click('.wiki-link');\n  \n  // Press Cmd+[\n  await app.keyboard.press('Meta+[');\n  \n  // Verify back at Alpha\n  await expect(app.locator('.editor-input')).toContainText('Alpha');\n  \n  // Press again - should do nothing\n  await app.keyboard.press('Meta+[');\n  await expect(app.locator('.editor-input')).toContainText('Alpha');\n});\n```\n\n### Flow 5: Graph backlinks integration\n```typescript\ntest('wiki-links appear in backlinks', async () =\u003e {\n  const app = await launchApp();\n  \n  // Create note B first\n  const noteB = await createNote(app, 'Note B');\n  \n  // Create note A with link to B\n  await createNote(app, 'Note A');\n  await typeInEditor(app, 'See [[Note B]] for info');\n  \n  // Navigate to B\n  await app.click('.wiki-link');\n  \n  // Open backlinks (Cmd+K, \"Show Backlinks\")\n  await app.keyboard.press('Meta+k');\n  await typeInEditor(app, 'backlinks');\n  await app.keyboard.press('Enter');\n  \n  // Verify A appears in backlinks\n  await expect(app.locator('.backlink-item')).toContainText('Note A');\n});\n```\n\n## Test Helpers to Add\n```typescript\n// In test-helpers.ts\nexport async function clickWikiLink(app: ElectronApplication, linkText: string) {\n  await app.locator('.wiki-link', { hasText: linkText }).click();\n}\n\nexport async function waitForNoteTitle(app: ElectronApplication, title: string) {\n  // Wait for note with given title to be visible in editor\n  await app.locator('.editor-input').waitFor();\n  // Check first paragraph contains title\n}\n```\n\n## Acceptance Criteria\n- [ ] Flow 1: Link creation and navigation works\n- [ ] Flow 2: Autocomplete selection works  \n- [ ] Flow 3: Alias syntax displays correctly\n- [ ] Flow 4: Back navigation (button and keyboard) works\n- [ ] Flow 5: Graph backlinks integration works\n- [ ] All tests pass in CI\n- [ ] Tests use existing test-helper patterns","status":"closed","priority":2,"issue_type":"task","created_at":"2025-11-26T14:44:46.454759-06:00","updated_at":"2025-11-26T15:27:45.880184-06:00","closed_at":"2025-11-26T15:27:45.880184-06:00","dependencies":[{"issue_id":"linked-18","depends_on_id":"linked-notes-1","type":"parent-child","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"linked-18","depends_on_id":"linked-14","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"linked-18","depends_on_id":"linked-9","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"linked-18","depends_on_id":"linked-4","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""}]}
{"id":"linked-19","title":"Unit tests for metadata extraction (wiki-links)","description":"Add tests for wiki-link extraction in metadata.ts.\n\n## Details\n- File: packages/engine-core/src/metadata.test.ts\n\n## Test cases\n\n### extractLinks with wiki-links\n- Extracts targetId from wiki-link nodes\n- Ignores wiki-links with null targetId\n- Extracts multiple wiki-links from same document\n- Works alongside existing link node types\n- Returns unique IDs (no duplicates)\n\n## Test data\n```typescript\nconst contentWithWikiLinks: LexicalState = {\n  root: {\n    type: 'root',\n    children: [\n      {\n        type: 'paragraph',\n        children: [\n          { type: 'text', text: 'See ' },\n          { \n            type: 'wiki-link', \n            noteTitle: 'Meeting Notes',\n            displayText: 'Meeting Notes',\n            targetId: 'note-123'\n          },\n          { type: 'text', text: ' for details.' }\n        ]\n      }\n    ]\n  }\n};\n\nconst contentWithUnresolvedLink: LexicalState = {\n  root: {\n    type: 'root',\n    children: [\n      {\n        type: 'paragraph',\n        children: [\n          { \n            type: 'wiki-link', \n            noteTitle: 'New Note',\n            displayText: 'New Note',\n            targetId: null  // Unresolved\n          }\n        ]\n      }\n    ]\n  }\n};\n```\n\n## Tests\n```typescript\ndescribe('extractLinks', () =\u003e {\n  it('extracts wiki-link targetId', () =\u003e {\n    const links = extractLinks(contentWithWikiLinks);\n    expect(links).toContain('note-123');\n  });\n  \n  it('ignores wiki-links with null targetId', () =\u003e {\n    const links = extractLinks(contentWithUnresolvedLink);\n    expect(links).toEqual([]);\n  });\n  \n  it('combines wiki-links with other link types', () =\u003e {\n    // Test with mixed link types\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] Wiki-link extraction tests pass\n- [ ] Null targetId handling tested\n- [ ] Multiple links extraction tested\n- [ ] Mixed link types tested","status":"closed","priority":2,"issue_type":"task","created_at":"2025-11-26T14:45:00.820759-06:00","updated_at":"2025-11-26T15:21:43.471919-06:00","closed_at":"2025-11-26T15:21:43.471919-06:00","dependencies":[{"issue_id":"linked-19","depends_on_id":"linked-notes-1","type":"parent-child","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"linked-19","depends_on_id":"linked-4","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""}]}
{"id":"linked-2","title":"Register WikiLinkNode in EditorRoot","description":"Register the WikiLinkNode in the Lexical editor configuration.\n\n## Details\n- File: renderer/src/components/Editor/EditorRoot.tsx\n\n## Changes Required\n\n### 1. Import WikiLinkNode\nAdd import at top of file (after other plugin imports around line 22-26):\n```typescript\nimport { WikiLinkNode } from './plugins/WikiLinkNode';\n```\n\n### 2. Add to nodes array\nAdd WikiLinkNode to the editorConfig.nodes array (around line 75-84):\n```typescript\nnodes: [\n  HeadingNode,\n  QuoteNode,\n  ListNode,\n  ListItemNode,\n  CodeNode,\n  CodeHighlightNode,\n  LinkNode,\n  HorizontalRuleNode,\n  WikiLinkNode,  // Add this\n],\n```\n\n## Why this is needed\n- Lexical requires custom nodes to be registered before they can be used\n- Without registration, existing notes containing wiki-links won't load correctly\n- The node registration must happen before any content is loaded\n\n## Verification Steps\n1. Editor initializes without errors\n2. Console shows no \"unknown node type\" warnings\n3. Any existing test notes with wiki-link JSON load correctly\n\n## Acceptance Criteria\n- [ ] WikiLinkNode imported in EditorRoot.tsx\n- [ ] WikiLinkNode added to editorConfig.nodes array\n- [ ] Editor initializes without errors\n- [ ] No console warnings about unknown node types","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-26T14:39:52.060706-06:00","updated_at":"2025-11-26T15:05:29.972715-06:00","closed_at":"2025-11-26T15:05:29.972715-06:00","dependencies":[{"issue_id":"linked-2","depends_on_id":"linked-notes-1","type":"parent-child","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"linked-2","depends_on_id":"linked-1","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""}]}
{"id":"linked-3","title":"Add wiki-link CSS styles","description":"Add CSS styles for wiki-links in the editor.\n\n## Details\n- File: renderer/src/components/Editor/EditorRoot.css\n\n## Styles to add\nAdd at the end of the file:\n\n```css\n/* Wiki Links */\n.wiki-link {\n  color: #007bff;\n  cursor: pointer;\n  border-radius: 2px;\n  padding: 0 2px;\n  margin: 0 1px;\n}\n\n.wiki-link:hover {\n  text-decoration: underline;\n  background-color: rgba(0, 123, 255, 0.1);\n}\n\n/* Dark mode support */\n[data-theme='dark'] .wiki-link {\n  color: #58a6ff;\n}\n\n[data-theme='dark'] .wiki-link:hover {\n  background-color: rgba(88, 166, 255, 0.15);\n}\n```\n\n## Design Notes\n- Blue color (#007bff) matches standard link styling\n- Subtle padding creates slight \"pill\" effect\n- Hover shows underline for clear link affordance  \n- Background tint on hover provides visual feedback\n- Dark mode uses GitHub's dark link color (#58a6ff)\n\n## Verification\n1. Create a note with wiki-link via `[[Note Name]]`\n2. Link displays as blue text\n3. Hovering shows underline and background tint\n4. Toggle to dark mode, verify colors adapt\n5. Link remains visible and clickable in both themes\n\n## Acceptance Criteria\n- [ ] .wiki-link class added to EditorRoot.css\n- [ ] Wiki-links display as blue text\n- [ ] Cursor changes to pointer on hover\n- [ ] Underline appears on hover\n- [ ] Subtle background highlight on hover\n- [ ] Works in both light and dark themes","status":"closed","priority":2,"issue_type":"task","created_at":"2025-11-26T14:40:05.164624-06:00","updated_at":"2025-11-26T15:05:30.650629-06:00","closed_at":"2025-11-26T15:05:30.650629-06:00","dependencies":[{"issue_id":"linked-3","depends_on_id":"linked-notes-1","type":"parent-child","created_at":"0001-01-01T00:00:00Z","created_by":""}]}
{"id":"linked-4","title":"Update metadata extraction for wiki-link nodes","description":"Update the metadata extraction in engine-core to recognize and extract wiki-link nodes.\n\n## Details\n- File: packages/engine-core/src/metadata.ts\n\n## Changes to extractLinks()\nAdd handling for wiki-link nodes in the traverseNodes callback (around line 93-116):\n\n```typescript\n// Recursively traverse nodes to find links\ntraverseNodes(content.root.children, (node) =\u003e {\n  // Standard link nodes with note references\n  if (node.type === 'link' \u0026\u0026 typeof node.url === 'string') {\n    const noteId = extractNoteIdFromUrl(node.url);\n    if (noteId) {\n      links.add(noteId);\n    }\n  }\n\n  // Custom entity reference nodes\n  if (\n    node.type === 'entity-reference' \u0026\u0026\n    node.entityType === 'note' \u0026\u0026\n    typeof node.id === 'string'\n  ) {\n    links.add(node.id);\n  }\n\n  // Custom note reference nodes\n  if (node.type === 'note-reference' \u0026\u0026 typeof node.noteId === 'string') {\n    links.add(node.noteId);\n  }\n\n  // Wiki-link nodes (NEW)\n  if (node.type === 'wiki-link' \u0026\u0026 typeof node.targetId === 'string') {\n    links.add(node.targetId);\n  }\n});\n```\n\n## Why this matters\n- Ensures wiki-links are indexed in the graph engine\n- Enables backlinks queries to find wiki-links  \n- Makes wiki-links part of the knowledge graph\n- Existing \"Show Backlinks\" command will find wiki-links\n\n## Important Notes\n- Only extract targetId if it's a non-null string\n- Unresolved links (targetId === null) should NOT be added to links\n- The node.type will be 'wiki-link' exactly as defined in WikiLinkNode.getType()\n\n## Tests to add in metadata.test.ts\n```typescript\ndescribe('extractLinks', () =\u003e {\n  it('extracts wiki-link nodes with resolved targetId', () =\u003e {\n    const content = {\n      root: {\n        children: [{\n          type: 'paragraph',\n          children: [{\n            type: 'wiki-link',\n            noteTitle: 'Meeting Notes',\n            displayText: 'Meeting Notes',\n            targetId: 'note-123'\n          }]\n        }]\n      }\n    };\n    expect(extractLinks(content)).toEqual(['note-123']);\n  });\n\n  it('ignores wiki-link nodes with null targetId', () =\u003e {\n    const content = {\n      root: {\n        children: [{\n          type: 'paragraph', \n          children: [{\n            type: 'wiki-link',\n            noteTitle: 'New Note',\n            displayText: 'New Note',\n            targetId: null\n          }]\n        }]\n      }\n    };\n    expect(extractLinks(content)).toEqual([]);\n  });\n\n  it('extracts mix of wiki-links and regular links', () =\u003e {\n    const content = {\n      root: {\n        children: [{\n          type: 'paragraph',\n          children: [\n            { type: 'wiki-link', noteTitle: 'A', displayText: 'A', targetId: 'id-1' },\n            { type: 'link', url: 'note://id-2' }\n          ]\n        }]\n      }\n    };\n    expect(extractLinks(content)).toContain('id-1');\n    expect(extractLinks(content)).toContain('id-2');\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] extractLinks() recognizes 'wiki-link' node type\n- [ ] Only extracts links with non-null string targetId\n- [ ] Unit tests pass for all scenarios\n- [ ] Graph engine shows backlinks for wiki-linked notes","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-26T14:40:22.097864-06:00","updated_at":"2025-11-26T15:05:31.540421-06:00","closed_at":"2025-11-26T15:05:31.540421-06:00","dependencies":[{"issue_id":"linked-4","depends_on_id":"linked-notes-1","type":"parent-child","created_at":"0001-01-01T00:00:00Z","created_by":""}]}
{"id":"linked-5","title":"Implement notes:findByTitle IPC handler","description":"Add IPC handler to find a note by its title for link resolution.\n\n## Details\n- Files: \n  - apps/desktop/electron/main/src/main.ts (handler)\n  - apps/desktop/electron/preload/src/preload.ts (API)\n\n## IPC Channel: notes:findByTitle\n\n### Input\n```typescript\ntitle: string\n```\n\n### Output  \n```typescript\nNote | null\n```\n\n### Resolution Logic\n1. Exact match: Find note where metadata.title === title\n2. Case-insensitive match: Find note where metadata.title.toLowerCase() === title.toLowerCase()\n3. Multiple matches: Return most recently updated (highest updatedAt)\n4. No match: Return null\n\n## Main process handler\n```typescript\n// Add to main.ts after existing notes handlers\nipcMain.handle('notes:findByTitle', async (_event, title: string) =\u003e {\n  if (!vault) {\n    throw new Error('Vault not initialized');\n  }\n  const notes = vault.list();\n  \n  // Exact match first\n  let match = notes.find(n =\u003e n.metadata.title === title);\n  \n  // Case-insensitive fallback\n  if (!match) {\n    const lowerTitle = title.toLowerCase();\n    const matches = notes.filter(n =\u003e \n      n.metadata.title?.toLowerCase() === lowerTitle\n    );\n    // Most recently updated wins\n    match = matches.sort((a, b) =\u003e b.updatedAt - a.updatedAt)[0];\n  }\n  \n  return match ?? null;\n});\n```\n\n## Preload API\n```typescript\nnotes: {\n  // ... existing methods (list, read, create, save, delete)\n  findByTitle: (title: string): Promise\u003cNote | null\u003e =\u003e\n    ipcRenderer.invoke('notes:findByTitle', title),\n}\n```\n\n## Important Notes\n- Uses `vault.list()` (synchronous) not `storage.list()` - see main.ts:109\n- vault is of type FileSystemVault\n- Note type from @scribe/shared\n\n## Tests\n- Find note by exact title match\n- Find note by case-insensitive match\n- Return most recent when multiple matches\n- Return null when no match\n\n## Acceptance Criteria\n- [ ] IPC handler implemented in main.ts\n- [ ] Preload API exposed with correct types\n- [ ] Exact match takes priority\n- [ ] Case-insensitive fallback works\n- [ ] Most recent note returned for duplicates\n- [ ] Returns null (not undefined) when no match","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-26T14:40:37.726372-06:00","updated_at":"2025-11-26T15:03:32.670799-06:00","closed_at":"2025-11-26T15:03:32.670799-06:00","dependencies":[{"issue_id":"linked-5","depends_on_id":"linked-notes-1","type":"parent-child","created_at":"0001-01-01T00:00:00Z","created_by":""}]}
{"id":"linked-6","title":"Implement notes:searchTitles IPC handler","description":"Add IPC handler to search note titles for autocomplete suggestions.\n\n## Details\n- Files: \n  - apps/desktop/electron/main/src/main.ts (handler)\n  - apps/desktop/electron/preload/src/preload.ts (API)\n\n## IPC Channel: notes:searchTitles\n\n### Input\n```typescript\nquery: string, limit?: number\n```\n\n### Output  \n```typescript\nSearchResult[]\n```\n\n### Behavior\n- Search metadata.title field only (not content)\n- Fuzzy matching using existing search infrastructure\n- Return max 10 results by default\n- Results sorted by relevance score\n- Exclude notes with null/empty titles\n\n## Implementation (using simple substring match for MVP)\n```typescript\n// Add to main.ts after notes:findByTitle handler\nipcMain.handle('notes:searchTitles', async (_event, query: string, limit = 10) =\u003e {\n  if (!vault) {\n    throw new Error('Vault not initialized');\n  }\n  \n  // Empty query returns empty results\n  if (!query.trim()) {\n    return [];\n  }\n  \n  const notes = vault.list();\n  const lowerQuery = query.toLowerCase();\n  \n  const matches = notes\n    .filter(n =\u003e n.metadata.title) // Has title\n    .filter(n =\u003e n.metadata.title!.toLowerCase().includes(lowerQuery))\n    .slice(0, limit)\n    .map(n =\u003e ({\n      id: n.id,\n      title: n.metadata.title!,\n      snippet: '',\n      score: 1,\n      matches: []\n    }));\n  \n  return matches;\n});\n```\n\n## Preload API\n```typescript\nnotes: {\n  // ... existing methods\n  searchTitles: (query: string, limit?: number): Promise\u003cSearchResult[]\u003e =\u003e\n    ipcRenderer.invoke('notes:searchTitles', query, limit ?? 10),\n}\n```\n\n## Important Notes\n- Uses `vault.list()` (synchronous) - see existing handlers in main.ts\n- SearchResult type from @scribe/shared\n- Empty query should return empty array (not all notes)\n- Consider adding score calculation based on match position later\n\n## Future Enhancement\nFor better fuzzy matching, could integrate with SearchEngine:\n```typescript\n// Optional: Use existing search engine with title-only filter\nconst results = searchEngine.search(query, { field: 'title', limit });\n```\n\n## Tests\n- Search returns matching titles\n- Empty query returns empty array\n- Limit parameter respected\n- Results include note ID and title\n- Partial matches work (substring)\n\n## Acceptance Criteria\n- [ ] IPC handler implemented in main.ts\n- [ ] Preload API exposed with correct types\n- [ ] Substring matching works\n- [ ] Results limited to specified count\n- [ ] Empty titles excluded from results\n- [ ] Empty query returns empty array","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-26T14:40:52.953425-06:00","updated_at":"2025-11-26T15:03:33.952279-06:00","closed_at":"2025-11-26T15:03:33.952279-06:00","dependencies":[{"issue_id":"linked-6","depends_on_id":"linked-notes-1","type":"parent-child","created_at":"0001-01-01T00:00:00Z","created_by":""}]}
{"id":"linked-7","title":"Implement WikiLinkPlugin - bracket detection and node insertion","description":"Create the core WikiLinkPlugin that detects [[ typing and manages wiki-link creation.\n\n## Details\n- File: renderer/src/components/Editor/plugins/WikiLinkPlugin.tsx\n\n## Responsibilities\n1. Detect when user types `[[` \n2. Track the position where autocomplete should appear\n3. Insert WikiLinkNode when link is finalized\n4. Handle manual link closure with `]]`\n\n## Implementation\n\n### Plugin Structure\n```typescript\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { useEffect, useCallback, useState } from 'react';\nimport { \n  $getSelection, \n  $isRangeSelection,\n  $getNodeByKey,\n  TextNode,\n  COMMAND_PRIORITY_LOW,\n  KEY_ESCAPE_COMMAND,\n} from 'lexical';\nimport { $createWikiLinkNode } from './WikiLinkNode';\n\ninterface WikiLinkPluginProps {\n  onTrigger: (query: string, position: { top: number; left: number }) =\u003e void;\n  onQueryChange: (query: string) =\u003e void;\n  onClose: () =\u003e void;\n  currentNoteId: string | null;\n}\n\ninterface TriggerState {\n  isActive: boolean;\n  startOffset: number;\n  anchorKey: string;\n  query: string;\n}\n\nexport function WikiLinkPlugin({ \n  onTrigger, \n  onQueryChange,\n  onClose, \n  currentNoteId \n}: WikiLinkPluginProps) {\n  const [editor] = useLexicalComposerContext();\n  const [triggerState, setTriggerState] = useState\u003cTriggerState | null\u003e(null);\n\n  // ... implementation\n  return null;\n}\n```\n\n### Key Detection Logic\nUse editor.registerUpdateListener to monitor text changes:\n```typescript\nuseEffect(() =\u003e {\n  return editor.registerUpdateListener(({ editorState }) =\u003e {\n    editorState.read(() =\u003e {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) return;\n      \n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      \n      if (!(anchorNode instanceof TextNode)) return;\n      \n      const text = anchorNode.getTextContent();\n      const offset = anchor.offset;\n      \n      // Check for [[ pattern\n      if (text.slice(offset - 2, offset) === '[[') {\n        // Start tracking\n        const domNode = editor.getElementByKey(anchorNode.getKey());\n        if (domNode) {\n          const rect = domNode.getBoundingClientRect();\n          onTrigger('', { top: rect.bottom, left: rect.left });\n          setTriggerState({\n            isActive: true,\n            startOffset: offset - 2,\n            anchorKey: anchorNode.getKey(),\n            query: ''\n          });\n        }\n      }\n      \n      // If tracking, update query\n      if (triggerState?.isActive \u0026\u0026 anchorNode.getKey() === triggerState.anchorKey) {\n        const query = text.slice(triggerState.startOffset + 2, offset);\n        \n        // Check for ]] closure\n        if (query.endsWith(']]')) {\n          const linkText = query.slice(0, -2);\n          insertWikiLink(linkText);\n          setTriggerState(null);\n          onClose();\n        } else {\n          onQueryChange(query);\n        }\n      }\n    });\n  });\n}, [editor, triggerState, onTrigger, onQueryChange, onClose]);\n```\n\n### WikiLinkNode Insertion\n```typescript\nconst insertWikiLink = useCallback((linkText: string) =\u003e {\n  editor.update(() =\u003e {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection) || !triggerState) return;\n    \n    // Parse alias syntax: \"note title|display text\"\n    const pipeIndex = linkText.lastIndexOf('|');\n    let noteTitle: string;\n    let displayText: string;\n    \n    if (pipeIndex \u003e 0) {\n      noteTitle = linkText.slice(0, pipeIndex).trim();\n      displayText = linkText.slice(pipeIndex + 1).trim();\n    } else {\n      noteTitle = linkText.trim();\n      displayText = noteTitle;\n    }\n    \n    // Get anchor node and remove [[...]] text\n    const anchorNode = $getNodeByKey(triggerState.anchorKey);\n    if (anchorNode instanceof TextNode) {\n      const text = anchorNode.getTextContent();\n      const before = text.slice(0, triggerState.startOffset);\n      const after = text.slice(selection.anchor.offset);\n      \n      // Create wiki-link node\n      const wikiLinkNode = $createWikiLinkNode(noteTitle, displayText, null);\n      \n      // Replace text with before + node + after\n      anchorNode.setTextContent(before);\n      anchorNode.insertAfter(wikiLinkNode);\n      \n      if (after) {\n        const afterNode = new TextNode(after);\n        wikiLinkNode.insertAfter(afterNode);\n        afterNode.select(0, 0);\n      } else {\n        wikiLinkNode.selectNext();\n      }\n    }\n  });\n}, [editor, triggerState]);\n```\n\n### Escape Key Handling\n```typescript\nuseEffect(() =\u003e {\n  return editor.registerCommand(\n    KEY_ESCAPE_COMMAND,\n    () =\u003e {\n      if (triggerState?.isActive) {\n        // Remove [[ text and cancel\n        editor.update(() =\u003e {\n          const node = $getNodeByKey(triggerState.anchorKey);\n          if (node instanceof TextNode) {\n            const text = node.getTextContent();\n            const newText = text.slice(0, triggerState.startOffset) + \n                           text.slice(triggerState.startOffset + 2 + triggerState.query.length);\n            node.setTextContent(newText);\n          }\n        });\n        setTriggerState(null);\n        onClose();\n        return true;\n      }\n      return false;\n    },\n    COMMAND_PRIORITY_LOW\n  );\n}, [editor, triggerState, onClose]);\n```\n\n## Props Interface\n```typescript\ninterface WikiLinkPluginProps {\n  onTrigger: (query: string, position: { top: number; left: number }) =\u003e void;\n  onQueryChange: (query: string) =\u003e void;\n  onClose: () =\u003e void;\n  currentNoteId: string | null;\n}\n```\n\n## Acceptance Criteria\n- [ ] Detects [[ typing pattern\n- [ ] Tracks cursor position for autocomplete popup\n- [ ] Converts [[text]] to WikiLinkNode on closure\n- [ ] Parses alias syntax (pipe separator) - last | wins\n- [ ] Cancels on Escape key and removes [[ text\n- [ ] Handles edge cases (end of document, selection changes)\n- [ ] Exposes insertWikiLink for programmatic insertion from autocomplete","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-26T14:41:18.904575-06:00","updated_at":"2025-11-26T15:13:46.54482-06:00","closed_at":"2025-11-26T15:13:46.54482-06:00","dependencies":[{"issue_id":"linked-7","depends_on_id":"linked-notes-1","type":"parent-child","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"linked-7","depends_on_id":"linked-1","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"linked-7","depends_on_id":"linked-2","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""}]}
{"id":"linked-8","title":"Implement WikiLinkAutocomplete UI component","description":"Create the autocomplete popup UI that shows note suggestions.\n\n## Details\n- Files: \n  - renderer/src/components/Editor/plugins/WikiLinkAutocomplete.tsx\n  - renderer/src/components/Editor/plugins/WikiLinkAutocomplete.css\n\n## Component Interface\n```typescript\nimport type { SearchResult } from '@scribe/shared';\n\ninterface WikiLinkAutocompleteProps {\n  isOpen: boolean;\n  query: string;\n  position: { top: number; left: number };\n  results: SearchResult[];\n  selectedIndex: number;\n  onSelect: (result: SearchResult) =\u003e void;\n  onClose: () =\u003e void;\n  isLoading: boolean;\n}\n```\n\n## Implementation\n```typescript\nimport { useEffect, useRef } from 'react';\nimport type { SearchResult } from '@scribe/shared';\nimport './WikiLinkAutocomplete.css';\n\nexport function WikiLinkAutocomplete({\n  isOpen,\n  query,\n  position,\n  results,\n  selectedIndex,\n  onSelect,\n  onClose,\n  isLoading,\n}: WikiLinkAutocompleteProps) {\n  const listRef = useRef\u003cHTMLDivElement\u003e(null);\n  const selectedRef = useRef\u003cHTMLDivElement\u003e(null);\n\n  // Scroll selected item into view\n  useEffect(() =\u003e {\n    if (selectedRef.current) {\n      selectedRef.current.scrollIntoView({ block: 'nearest' });\n    }\n  }, [selectedIndex]);\n\n  if (!isOpen) return null;\n\n  return (\n    \u003cdiv \n      className=\"wiki-link-autocomplete\"\n      style={{ top: position.top, left: position.left }}\n    \u003e\n      \u003cdiv className=\"wiki-link-autocomplete-list\" ref={listRef}\u003e\n        {isLoading ? (\n          \u003cdiv className=\"wiki-link-autocomplete-loading\"\u003eSearching...\u003c/div\u003e\n        ) : results.length === 0 ? (\n          \u003cdiv className=\"wiki-link-autocomplete-empty\"\u003e\n            {query ? 'No matching notes' : 'Type to search notes'}\n          \u003c/div\u003e\n        ) : (\n          results.map((result, index) =\u003e (\n            \u003cdiv\n              key={result.id}\n              ref={index === selectedIndex ? selectedRef : null}\n              className={`wiki-link-autocomplete-item ${\n                index === selectedIndex ? 'wiki-link-autocomplete-item--selected' : ''\n              }`}\n              onClick={() =\u003e onSelect(result)}\n              onMouseEnter={() =\u003e {/* optionally update selectedIndex */}}\n            \u003e\n              \u003cspan className=\"wiki-link-autocomplete-title\"\u003e\n                {result.title || 'Untitled'}\n              \u003c/span\u003e\n            \u003c/div\u003e\n          ))\n        )}\n      \u003c/div\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n## CSS (WikiLinkAutocomplete.css)\n```css\n.wiki-link-autocomplete {\n  position: fixed;\n  z-index: 1000;\n  width: 280px;\n  max-height: 300px;\n  background: white;\n  border: 1px solid #e0e0e0;\n  border-radius: 6px;\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\n  overflow: hidden;\n}\n\n.wiki-link-autocomplete-list {\n  overflow-y: auto;\n  max-height: 300px;\n}\n\n.wiki-link-autocomplete-item {\n  padding: 10px 12px;\n  cursor: pointer;\n  border-bottom: 1px solid #f0f0f0;\n}\n\n.wiki-link-autocomplete-item:last-child {\n  border-bottom: none;\n}\n\n.wiki-link-autocomplete-item:hover,\n.wiki-link-autocomplete-item--selected {\n  background-color: #f5f5f5;\n}\n\n.wiki-link-autocomplete-title {\n  display: block;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  font-size: 14px;\n}\n\n.wiki-link-autocomplete-empty,\n.wiki-link-autocomplete-loading {\n  padding: 12px;\n  color: #666;\n  font-size: 13px;\n  text-align: center;\n}\n\n/* Dark mode */\n[data-theme='dark'] .wiki-link-autocomplete {\n  background: #1e1e1e;\n  border-color: #404040;\n}\n\n[data-theme='dark'] .wiki-link-autocomplete-item:hover,\n[data-theme='dark'] .wiki-link-autocomplete-item--selected {\n  background-color: #2d2d2d;\n}\n\n[data-theme='dark'] .wiki-link-autocomplete-item {\n  border-color: #333;\n}\n\n[data-theme='dark'] .wiki-link-autocomplete-empty,\n[data-theme='dark'] .wiki-link-autocomplete-loading {\n  color: #999;\n}\n```\n\n## Specifications\n| Element | Value |\n|---------|-------|\n| Width | 280px fixed |\n| Max height | 300px (scrollable) |\n| Item height | ~40px (10px padding + content) |\n| Position | Fixed, at cursor location |\n| Z-index | 1000 (above editor) |\n\n## Important Notes\n- Use `position: fixed` not `absolute` for correct positioning in Lexical\n- SearchResult type from @scribe/shared\n- Keyboard handling is done by parent (WikiLinkPlugin), this is just UI\n\n## Acceptance Criteria\n- [ ] Popup renders at correct position (fixed positioning)\n- [ ] Results display with proper styling\n- [ ] Selected item highlighted with background\n- [ ] Empty state shows \"No matching notes\"\n- [ ] Loading state shows \"Searching...\"\n- [ ] Click on item triggers onSelect callback\n- [ ] Scroll works for long lists\n- [ ] Selected item scrolls into view\n- [ ] Works in both light and dark themes","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-26T14:41:37.376174-06:00","updated_at":"2025-11-26T15:03:34.351415-06:00","closed_at":"2025-11-26T15:03:34.351415-06:00","dependencies":[{"issue_id":"linked-8","depends_on_id":"linked-notes-1","type":"parent-child","created_at":"0001-01-01T00:00:00Z","created_by":""}]}
{"id":"linked-9","title":"Integrate autocomplete with search API","description":"Connect the autocomplete popup to the notes:searchTitles API.\n\n## Details\n- File: renderer/src/components/Editor/plugins/WikiLinkPlugin.tsx\n\nThis task extends WikiLinkPlugin to manage autocomplete state and integrate with the search API.\n\n## State Management\nAdd to WikiLinkPlugin:\n```typescript\nconst [autocompleteState, setAutocompleteState] = useState\u003c{\n  isOpen: boolean;\n  query: string;\n  results: SearchResult[];\n  selectedIndex: number;\n  position: { top: number; left: number };\n  isLoading: boolean;\n}\u003e({\n  isOpen: false,\n  query: '',\n  results: [],\n  selectedIndex: 0,\n  position: { top: 0, left: 0 },\n  isLoading: false,\n});\n```\n\n## Search Integration with Debounce\n```typescript\nimport { useCallback, useRef, useEffect } from 'react';\nimport type { SearchResult } from '@scribe/shared';\n\n// Debounce search calls\nconst searchTimeoutRef = useRef\u003cNodeJS.Timeout | null\u003e(null);\n\nconst performSearch = useCallback(async (query: string) =\u003e {\n  if (!query.trim()) {\n    setAutocompleteState(s =\u003e ({ ...s, results: [], isLoading: false }));\n    return;\n  }\n  \n  setAutocompleteState(s =\u003e ({ ...s, isLoading: true }));\n  \n  try {\n    const results = await window.scribe.notes.searchTitles(query, 10);\n    // Filter out current note\n    const filtered = results.filter(r =\u003e r.id !== currentNoteId);\n    setAutocompleteState(s =\u003e ({\n      ...s,\n      results: filtered,\n      selectedIndex: 0,\n      isLoading: false,\n    }));\n  } catch (error) {\n    console.error('Search failed:', error);\n    setAutocompleteState(s =\u003e ({ ...s, results: [], isLoading: false }));\n  }\n}, [currentNoteId]);\n\n// Called when query changes\nconst handleQueryChange = useCallback((query: string) =\u003e {\n  setAutocompleteState(s =\u003e ({ ...s, query }));\n  \n  // Debounce\n  if (searchTimeoutRef.current) {\n    clearTimeout(searchTimeoutRef.current);\n  }\n  searchTimeoutRef.current = setTimeout(() =\u003e {\n    performSearch(query);\n  }, 150);\n}, [performSearch]);\n\n// Cleanup timeout on unmount\nuseEffect(() =\u003e {\n  return () =\u003e {\n    if (searchTimeoutRef.current) {\n      clearTimeout(searchTimeoutRef.current);\n    }\n  };\n}, []);\n```\n\n## Keyboard Handling\n```typescript\nuseEffect(() =\u003e {\n  if (!autocompleteState.isOpen) return;\n  \n  const handleKeyDown = (e: KeyboardEvent) =\u003e {\n    switch (e.key) {\n      case 'ArrowDown':\n        e.preventDefault();\n        setAutocompleteState(s =\u003e ({\n          ...s,\n          selectedIndex: Math.min(s.selectedIndex + 1, s.results.length - 1)\n        }));\n        break;\n      case 'ArrowUp':\n        e.preventDefault();\n        setAutocompleteState(s =\u003e ({\n          ...s,\n          selectedIndex: Math.max(s.selectedIndex - 1, 0)\n        }));\n        break;\n      case 'Tab':\n      case 'Enter':\n        e.preventDefault();\n        const selected = autocompleteState.results[autocompleteState.selectedIndex];\n        if (selected) {\n          handleSelect(selected);\n        }\n        break;\n      case 'Escape':\n        e.preventDefault();\n        handleCancel();\n        break;\n    }\n  };\n  \n  document.addEventListener('keydown', handleKeyDown, true);\n  return () =\u003e document.removeEventListener('keydown', handleKeyDown, true);\n}, [autocompleteState.isOpen, autocompleteState.selectedIndex, autocompleteState.results]);\n```\n\n## Selection Handling\n```typescript\nconst handleSelect = useCallback((result: SearchResult) =\u003e {\n  // Insert WikiLinkNode with selected note\n  editor.update(() =\u003e {\n    // Use the insertWikiLink from WikiLinkPlugin\n    // noteTitle: result.title\n    // displayText: result.title (no alias from autocomplete)\n    // targetId: result.id\n  });\n  \n  setAutocompleteState(s =\u003e ({\n    ...s,\n    isOpen: false,\n    query: '',\n    results: [],\n    selectedIndex: 0,\n  }));\n}, [editor, triggerState]);\n```\n\n## Render Autocomplete\n```typescript\nreturn (\n  \u003c\u003e\n    \u003cWikiLinkAutocomplete\n      isOpen={autocompleteState.isOpen}\n      query={autocompleteState.query}\n      position={autocompleteState.position}\n      results={autocompleteState.results}\n      selectedIndex={autocompleteState.selectedIndex}\n      onSelect={handleSelect}\n      onClose={handleCancel}\n      isLoading={autocompleteState.isLoading}\n    /\u003e\n  \u003c/\u003e\n);\n```\n\n## Important Notes\n- Debounce delay: 150ms (fast enough to feel responsive)\n- Filter out currentNoteId from results (no self-linking from autocomplete)\n- Use capture phase for keyboard events to intercept before editor\n- SearchResult type from @scribe/shared\n\n## Acceptance Criteria\n- [ ] Search triggers on query change (debounced)\n- [ ] Debouncing prevents excessive API calls\n- [ ] Loading state shown during fetch\n- [ ] Current note excluded from results\n- [ ] Arrow keys navigate results\n- [ ] Tab/Enter selects current result\n- [ ] Escape cancels autocomplete\n- [ ] Selected note inserted as WikiLinkNode with targetId\n- [ ] Focus returns to editor after selection","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-26T14:41:57.718368-06:00","updated_at":"2025-11-26T15:19:14.234566-06:00","closed_at":"2025-11-26T15:19:14.234566-06:00","dependencies":[{"issue_id":"linked-9","depends_on_id":"linked-notes-1","type":"parent-child","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"linked-9","depends_on_id":"linked-6","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"linked-9","depends_on_id":"linked-7","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"linked-9","depends_on_id":"linked-8","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""}]}
{"id":"linked-notes-1","title":"Linked Notes Feature","description":"Implement Obsidian-style wiki-links ([[note title]]) with autocomplete, navigation, and back button. See features/linked-notes/spec.md for full specification.\n\n## Summary\nAdd wiki-link support to enable users to create linked notes using [[Note Title]] syntax, navigate between linked notes with a single click, and use back navigation to return to previously viewed notes.\n\n## Key Features\n1. **Wiki-link syntax**: Type [[Note Title]] to create links\n2. **Autocomplete**: Popup shows matching notes as you type\n3. **Click navigation**: Click any wiki-link to navigate to that note\n4. **Back navigation**: Button and Cmd+[ to return to previous note\n5. **Graph integration**: Wiki-links appear in backlinks\n\n## Task Organization\n\n### Foundation (no blockers - start here)\n- linked-1: WikiLinkNode (Lexical custom node)\n- linked-4: Metadata extraction for wiki-links\n- linked-5: notes:findByTitle IPC handler\n- linked-6: notes:searchTitles IPC handler\n- linked-8: WikiLinkAutocomplete UI\n- linked-11: useNavigationHistory hook\n- linked-3: Wiki-link CSS styles\n\n### Core Implementation (blocked by foundation)\n- linked-2: Register WikiLinkNode in EditorRoot (blocked by linked-1)\n- linked-7: WikiLinkPlugin - bracket detection (blocked by linked-1, linked-2)\n- linked-12: Back button UI (blocked by linked-11)\n- linked-13: Cmd+[ keyboard shortcut (blocked by linked-11)\n- linked-10: Wiki-link click navigation (blocked by linked-5, linked-7, linked-11)\n\n### Integration (blocked by core)\n- linked-9: Autocomplete + search API (blocked by linked-6, linked-7, linked-8)\n- linked-14: Full App.tsx integration (blocked by linked-10, linked-11, linked-12, linked-13)\n\n### Testing (blocked by integration)\n- linked-15: WikiLinkNode unit tests\n- linked-16: useNavigationHistory unit tests\n- linked-17: WikiLinkAutocomplete component tests\n- linked-18: Integration tests (full feature)\n- linked-19: Metadata extraction tests\n\n## Implementation Order (Recommended)\n1. Start with foundation tasks in parallel (linked-1, linked-4, linked-5, linked-6, linked-8, linked-11, linked-3)\n2. Complete core tasks as blockers are resolved\n3. Integration tasks bring everything together\n4. Testing tasks can run alongside or after implementation\n\n## Files Modified/Created\nSee individual task descriptions for specific file locations.","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-11-26T14:39:22.403206-06:00","updated_at":"2025-11-26T15:27:57.56767-06:00","closed_at":"2025-11-26T15:27:57.56767-06:00"}
